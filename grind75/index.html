



<!DOCTYPE html>
<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/website/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/website/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="alternate" type="application/rss+xml" title="Joseph's Blog" href="http://localhost:4000/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Joseph's Blog" href="http://localhost:4000/atom.xml" />
<link rel="alternate" type="application/json" title="Joseph's Blog" href="http://localhost:4000/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/website/css/app.css?v=0.2.5">

<!-- KaTeX CSS for inline math support -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />

<!-- MathJax v3 for LaTeX 渲染 -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Prism.js CSS for code highlighting -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-tomorrow.css" />


<script src="/website/js/algolia/algoliasearchLite.min.js?v=0.2.5"></script>
<script src="/website/js/algolia/instantsearch.min.js?v=0.2.5"></script>
<script src="/website/js/algolia/algoliaSearch.js?v=0.2.5"></script>

  

<link rel="canonical" href="http://localhost:4000/grind75/">



  <title>LeetCode Grind 75 |
Hi~~ = Joseph's Blog</title>
<meta name="generator" content="Hexo 7.3.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode Grind 75
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/website/" rel="start">Hi~~</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclimtf7dj20zk0m8qav.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-tw">
  <link itemprop="mainEntityOfPage" href="http://localhost:4000/grind75/index.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/website/images/avatar.jpg">
    <meta itemprop="name" content="品逸">
    <meta itemprop="description" content=", 品逸的網站">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Joseph's Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="grind-75"><a class="markdownIt-Anchor" href="#grind-75">#</a> Grind 75</h1>
<blockquote>
<p>Grind 75 是 Leetcode 推出的刷題路線，適合給準備面試的朋友們，加油。</p>
</blockquote>
<h2 id="week-1-1313"><a class="markdownIt-Anchor" href="#week-1-1313">#</a> Week 1 (13/13)</h2>
<h3 id="two-sum"><a class="markdownIt-Anchor" href="#two-sum">#</a> Two Sum</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">題目連結</span><br>
<strong>標籤</strong>: Array, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given an array of integers  <code>nums</code>  and an integer  <code>target</code> , return indices of the two numbers such that they add up to  <code>target</code> .</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>You can return the answer in any order.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: nums = [2,7,11,15], target = 9<br>
Output: [0,1]<br>
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: nums = [3,2,4], target = 6<br>
Output: [1,2]</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: nums = [3,3], target = 6<br>
Output: [0,1]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>2 &lt;= nums.length &lt;= 10^4</li>
<li>-10^9 &lt;= nums[i] &lt;= 10^9</li>
<li>-10^9 &lt;= target &lt;= 10^9</li>
<li>只有一個有效答案</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>用 Hash Map 儲存已經看過的數字及其 index</li>
<li>遍歷陣列，對於每個數字  <code>nums[i]</code> ，檢查  <code>target - nums[i]</code>  是否已經在 map 裡</li>
<li>如果有，回傳  <code>&#123; map[補數], i &#125;</code></li>
<li>否則把  <code>nums[i]</code>  加進 map</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; num_to_complement_idx; <span class="comment">// 儲存「補數 → 索引」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 遍歷 nums 陣列</span></span><br><span class="line">            <span class="keyword">auto</span> it = num_to_complement_idx.<span class="built_in">find</span>(nums[i]); <span class="comment">// 查找當前值是否為之前存的補數</span></span><br><span class="line">            <span class="keyword">if</span> (it != num_to_complement_idx.<span class="built_in">end</span>()) &#123;       <span class="comment">// 若找到匹配</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;                    <span class="comment">// 回傳「先前元素的索引, 當前索引」</span></span><br><span class="line">            &#125;</span><br><span class="line">            num_to_complement_idx[target - nums[i]] = i;    <span class="comment">// 存入「target - nums[i]（補數） → i（索引）」</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 理論上不會執行到，因為題目保證至少有一組解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>我們只需一次迴圈遍歷整個陣列，對每個元素執行一次雜湊表（Hash Map）的查找與插入操作，而這些操作均攤銷為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>最壞情況下，雜湊表需要儲存所有 n 個元素的（補數→索引）對。</li>
</ul>
</li>
</ul>
<h3 id="valid-parentheses"><a class="markdownIt-Anchor" href="#valid-parentheses">#</a> Valid Parentheses</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">題目連結</span><br>
<strong>標籤</strong>: Stack, String<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a string  <code>s</code>  containing just the characters  <code>'('</code> ,  <code>')'</code> ,  <code>'&#123;'</code> ,  <code>'&#125;'</code> ,  <code>'['</code>  and  <code>']'</code> , determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
</blockquote>
<p><strong>範例（Input &amp; Output）</strong></p>
<blockquote>
<p>Input: s = “()”<br>
Output: true</p>
</blockquote>
<blockquote>
<p>Input: s = “()<span></span>{}”<br>
Output: true</p>
</blockquote>
<blockquote>
<p>Input: s = “(]”<br>
Output: false</p>
</blockquote>
<blockquote>
<p>Input: s = “{[]}”<br>
Output: true</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code></li>
<li><code>s</code>  consists only of the characters  <code>'('</code> ,  <code>')'</code> ,  <code>'&#123;'</code> ,  <code>'&#125;'</code> ,  <code>'['</code> ,  <code>']'</code> .</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用一個  <code>stack&lt;char&gt;</code>  來追蹤尚未配對的開括號。</li>
<li>遍歷字串中每個字元  <code>c</code> ：
<ol>
<li>若  <code>c</code>  是開括號（ <code>'('</code> 、 <code>'&#123;'</code> 、 <code>'['</code> ），則推入堆疊。</li>
<li>否則若  <code>c</code>  是閉括號，必須檢查堆疊頂端是否有對應的開括號：
<ul>
<li>如果堆疊為空，或頂端字元不是對應類型的開括號，即可立即回傳  <code>false</code> 。</li>
<li>否則彈出堆疊頂端，繼續遍歷。</li>
</ul>
</li>
</ol>
</li>
<li>最後遍歷完字串，如果堆疊為空表示所有括號都正確配對，回傳  <code>true</code> ；否則回傳  <code>false</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;                    <span class="comment">// 用來存放開括號</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;                 <span class="comment">// 遍歷字串中的每個字元</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);                <span class="comment">// 若是開括號，推入堆疊</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若遇到閉括號但堆疊空，無法配對 -&gt; false</span></span><br><span class="line">                <span class="type">char</span> top = st.<span class="built_in">top</span>();      <span class="comment">// 取出堆疊頂端開括號</span></span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || <span class="comment">// 檢查是否為對應的左括號</span></span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">// 若不匹配，回傳 false</span></span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();                 <span class="comment">// 匹配成功，彈出堆疊頂端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();                <span class="comment">// 遍歷結束後若堆疊為空，代表所有括號都配對成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>一次遍歷長度為 n 的字串，對每個字元做常數次的  <code>stack</code>  操作（ <code>push</code> 、 <code>pop</code> 、 <code>empty</code> 、 <code>top</code> ），皆為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>最壞情況下所有字元都是開括號， <code>stack</code>  大小會達到 n，故額外空間為 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="merge-two-sorted-lists"><a class="markdownIt-Anchor" href="#merge-two-sorted-lists">#</a> Merge Two Sorted Lists</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">題目連結</span><br>
<strong>標籤</strong>: Linked List, Recursion<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are given the heads of two sorted linked lists  <code>l1</code>  and  <code>l2</code> .</p>
<p>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return the head of the merged linked list.</p>
</blockquote>
<p><strong>範例（Input &amp; Output）</strong></p>
<blockquote>
<p>Input: l1 = [1, 2, 4], l2 = [1, 3, 4]<br>
Output: [1, 1, 2, 3, 4, 4]</p>
</blockquote>
<blockquote>
<p>Input: l1 = [], l2 = []<br>
Output: []</p>
</blockquote>
<blockquote>
<p>Input: l1 = [], l2 = [0]<br>
Output: [0]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in both lists is in the range  <code>[0, 50]</code> .</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>Both  <code>l1</code>  and  <code>l2</code>  are sorted in non-decreasing order.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用一個虛擬頭節點（dummy head）來簡化合併過程的邊界處理。</li>
<li>令  <code>curr</code>  指向這個虛擬頭節點，當作合併後鏈結串列的尾巴指標。</li>
<li>同時維護指標  <code>p1</code>  指向  <code>l1</code>  的當前節點， <code>p2</code>  指向  <code>l2</code>  的當前節點。</li>
<li>迴圈比較  <code>p1-&gt;val</code>  和  <code>p2-&gt;val</code> ：
<ol>
<li>如果  <code>p1-&gt;val &lt;= p2-&gt;val</code> ，將  <code>p1</code>  節點接到  <code>curr-&gt;next</code> ，並讓  <code>p1</code>  移到下一個節點；</li>
<li>否則，將  <code>p2</code>  節點接到  <code>curr-&gt;next</code> ，並讓  <code>p2</code>  移到下一個節點；</li>
<li>將  <code>curr</code>  一併移到剛接上的節點，保證尾巴始終指向最新節點。</li>
</ol>
</li>
<li>當  <code>l1</code>  或  <code>l2</code>  其中一方先到達末端（ <code>nullptr</code> ）時，直接把另一個尚未遍歷完的鏈結串列「接」到  <code>curr-&gt;next</code> 。</li>
<li>最後回傳  <code>dummy-&gt;next</code>  作為合併後的頭節點。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立虛擬頭節點，方便處理合併時的邊界</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指標 p1 指向 l1，p2 指向 l2</span></span><br><span class="line">        ListNode* p1 = l1;</span><br><span class="line">        ListNode* p2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要兩個串列都還沒走到尾端，就繼續比較並合併</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt;= p2-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 若 l1 節點較小或相等，就把 p1 節點接到 curr</span></span><br><span class="line">                curr-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;  <span class="comment">// p1 移到下一個</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否則把 p2 節點接到 curr</span></span><br><span class="line">                curr-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;  <span class="comment">// p2 移到下一個</span></span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;  <span class="comment">// curr 移到最新接上的節點</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當其中一個串列提前結束，直接把另一串列剩餘部分接上</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curr-&gt;next = p1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合併後的頭節點是 dummy-&gt;next</span></span><br><span class="line">        ListNode* head = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;  <span class="comment">// 釋放虛擬頭節點</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n + m)</p>
<ul>
<li>其中 n 為 l1 節點數，m 為 l2 節點數；合併過程中每個節點只會被訪問一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>除了輸入的兩個鏈結串列節點外，只使用了常數個輔助指標（dummy、curr、p1、p2），不額外配置與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="best-time-to-buy-and-sell-stock"><a class="markdownIt-Anchor" href="#best-time-to-buy-and-sell-stock">#</a> Best Time to Buy and Sell Stock</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">題目連結</span><br>
<strong>標籤</strong>: Array, Dynamic Programming<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are given an array  <code>prices</code>  where  <code>prices[i]</code>  is the price of a given stock on the i-th day.</p>
<p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return  <code>0</code> .</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: prices = [7,1,5,3,6,4]<br>
Output: 5<br>
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</p>
<p>Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: prices = [7,6,4,3,1]<br>
Output: 0<br>
Explanation: In this case, no transaction is done and the max profit = 0.</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10^5</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>只需一次遍歷陣列，記錄到目前為止見過的最低價格  <code>minPrice</code> ，以及最大收益  <code>maxProfit</code> 。</li>
<li>對於第  <code>i</code>  天的價格  <code>prices[i]</code> ：
<ol>
<li>如果  <code>prices[i] &lt; minPrice</code> ，則更新  <code>minPrice = prices[i]</code> 。</li>
<li>否則，計算當前收益  <code>prices[i] - minPrice</code> ，若大於  <code>maxProfit</code> ，則更新  <code>maxProfit</code> 。</li>
</ol>
</li>
<li>最終  <code>maxProfit</code>  即為答案，如果始終沒有正收益，則回傳  <code>0</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minPrice = INT_MAX;    <span class="comment">// 初始化為極大值</span></span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;         <span class="comment">// 初始化最大收益為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 更新見過的最低價格</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) &#123;</span><br><span class="line">                minPrice = price;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 計算當前收益，並更新最大收益</span></span><br><span class="line">                <span class="type">int</span> profit = price - minPrice;</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxProfit) &#123;</span><br><span class="line">                    maxProfit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需要遍歷一次長度為 n 的陣列，對每個元素進行常數次操作。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用固定數量的輔助變數，與輸入規模無關。</li>
</ul>
</li>
</ul>
<h3 id="valid-palindrome"><a class="markdownIt-Anchor" href="#valid-palindrome">#</a> Valid Palindrome</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">題目連結</span><br>
<strong>標籤</strong>: Two Pointers, String<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a string  <code>s</code> , determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</p>
<p>Return  <code>true</code>  if it is a palindrome, otherwise return  <code>false</code> .</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: s =  <code>&quot;A man, a plan, a canal: Panama&quot;</code> <br>
Output:  <code>true</code> <br>
Explanation:  <code>&quot;amanaplanacanalpanama&quot;</code>  is a palindrome.</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: s =  <code>&quot;race a car&quot;</code> <br>
Output:  <code>false</code> <br>
Explanation:  <code>&quot;raceacar&quot;</code>  is not a palindrome.</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: s =  <code>&quot; &quot;</code> <br>
Output:  <code>true</code> <br>
Explanation: 空字串視為回文。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 10^5</code></li>
<li><code>s</code>  只包含英文字母、數字、空格，以及標點符號等可列印字符。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用左右兩個指標  <code>left</code> 、 <code>right</code>  分別指向字串開頭與結尾。</li>
<li>迴圈中：
<ol>
<li>若  <code>s[left]</code>  不是字母或數字，就將  <code>left</code>  向右移動直到遇到合法字符或  <code>left &gt;= right</code> 。</li>
<li>若  <code>s[right]</code>  不是字母或數字，就將  <code>right</code>  向左移動直到遇到合法字符或  <code>left &gt;= right</code> 。</li>
<li>當左右指標都指向合法字符時，比較將  <code>s[left]</code> 、 <code>s[right]</code>  都轉為小寫之後是否相等；
<ul>
<li>若不相等，直接回傳  <code>false</code> 。</li>
<li>若相等，則  <code>left++</code> 、 <code>right--</code> ，繼續下一輪比較。</li>
</ul>
</li>
</ol>
</li>
<li>若整個過程中都未發現不相等的情況，最終  <code>left &gt;= right</code>  時，回傳  <code>true</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = (<span class="type">int</span>)s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 左指標跳過非字母或數字字符</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右指標跳過非字母或數字字符</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比較忽略大小寫後的字符</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">char</span> c1 = <span class="built_in">tolower</span>(s[left]);</span><br><span class="line">                <span class="type">char</span> c2 = <span class="built_in">tolower</span>(s[right]);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 發現不匹配，直接回傳 false</span></span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 走到這裡表示所有字符都匹配，回傳 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需一次從頭到尾的掃描，左右指標共移動至多 n 次，對每個字符做常數次 isalnum 和 tolower 操作。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>僅使用常數個指標與臨時變數，不依賴額外與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="invert-binary-tree"><a class="markdownIt-Anchor" href="#invert-binary-tree">#</a> Invert Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search, Breadth-First Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given the root of a binary tree, invert the tree, and return its root.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>root = [4,2,7,1,3,6,9]</code> <br>
Output:  <code>[4,7,2,9,6,3,1]</code> <br>
Explanation:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \ / \</span><br><span class="line">1  3 6  9</span><br><span class="line"></span><br><span class="line">Output:  </span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  7   2</span><br><span class="line"> / \ / \</span><br><span class="line">9  6 3  1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input:  <code>root = [2,1,3]</code> <br>
Output:  <code>[2,3,1]</code></p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>root = []</code> <br>
Output:  <code>[]</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in the tree is in the range  <code>[0, 100]</code> .</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題可利用遞迴（DFS）或層序遍歷（BFS）來交換每個節點的左右子樹。</li>
<li>遞迴（DFS）做法：
<ol>
<li>若當前節點為  <code>nullptr</code> ，直接回傳  <code>nullptr</code> 。</li>
<li>交換當前節點的左右子節點指標。</li>
<li>對左右子節點分別遞迴執行相同操作。</li>
<li>最後回傳當前節點。</li>
</ol>
</li>
<li>或者使用迴圈搭配佇列（BFS）：
<ol>
<li>將根節點放入佇列。</li>
<li>每次從佇列取出一個節點，交換其左右子節點，並將非空的左右子節點推入佇列。</li>
<li>直到佇列為空，最後回傳根節點。</li>
</ol>
</li>
<li>遞迴版本較為簡潔，空間複雜度取決於遞迴深度；BFS 版本需要額外佇列空間。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 遞迴（DFS）解法</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先交換左右子節點</span></span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="comment">// 分別對交換後的左右子樹遞迴調用</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若要使用 BFS（迴圈）解法，可替換為以下函式：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TreeNode* invertTree(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">        if (root == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return nullptr;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        queue&lt;TreeNode*&gt; q;</span></span><br><span class="line"><span class="comment">        q.push(root);</span></span><br><span class="line"><span class="comment">        while (!q.empty()) &#123;</span></span><br><span class="line"><span class="comment">            TreeNode* node = q.front();</span></span><br><span class="line"><span class="comment">            q.pop();</span></span><br><span class="line"><span class="comment">            // 交換當前節點的左右子節點</span></span><br><span class="line"><span class="comment">            TreeNode* temp = node-&gt;left;</span></span><br><span class="line"><span class="comment">            node-&gt;left = node-&gt;right;</span></span><br><span class="line"><span class="comment">            node-&gt;right = temp;</span></span><br><span class="line"><span class="comment">            if (node-&gt;left) q.push(node-&gt;left);</span></span><br><span class="line"><span class="comment">            if (node-&gt;right) q.push(node-&gt;right);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return root;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>時間複雜度：O (n)
<ul>
<li>每個節點訪問一次並交換左右子節點，總計 n 個節點，因此時間複雜度為 O (n)。</li>
</ul>
</li>
<li>空間複雜度（遞迴版本）：O (h)
<ul>
<li>h 為二元樹高度，最壞情況（樹為一條鍊狀）時 h = n，空間複雜度為 O (n)。平均情況下若為平衡樹，h = O (log n)。</li>
</ul>
</li>
<li>空間複雜度（BFS 版本）：O (n)
<ul>
<li>需使用佇列儲存節點，最壞情況時可能將 O (n/2) 個節點同時放入佇列，空間複雜度為 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="valid-anagram"><a class="markdownIt-Anchor" href="#valid-anagram">#</a> Valid Anagram</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">題目連結</span><br>
<strong>標籤</strong>: Hash Table, String, Sorting<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given two strings  <code>s</code>  and  <code>t</code> , return  <code>true</code>  <em>if</em>  <code>t</code>  <em>is an anagram of</em>  <code>s</code> , and  <code>false</code>  <em>otherwise</em>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: s =  <code>&quot;anagram&quot;</code> , t =  <code>&quot;nagaram&quot;</code> <br>
Output:  <code>true</code></p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: s =  <code>&quot;rat&quot;</code> , t =  <code>&quot;car&quot;</code> <br>
Output:  <code>false</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code></li>
<li><code>s</code>  和  <code>t</code>  只包含小寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>
<p>方法一（排序 Sort）：</p>
<ol>
<li>如果  <code>s.length() != t.length()</code> ，直接回傳  <code>false</code> 。</li>
<li>將  <code>s</code> 、 <code>t</code>  轉為字母陣列並排序。</li>
<li>如果排序後的兩個字串相等，回傳  <code>true</code> ；否則回傳  <code>false</code> 。</li>
</ol>
<ul>
<li>時間複雜度主要在排序：O (n log n)，其中 n 為字串長度。</li>
<li>空間複雜度取決於排序所需緩衝（取決於標準庫實現），額外可視為 O (1)。</li>
</ul>
</li>
<li>
<p>方法二（雜湊表 Hash Table / 計數）：</p>
<ol>
<li>如果  <code>s.length() != t.length()</code> ，直接回傳  <code>false</code> 。</li>
<li>建立長度為 26 的整數陣列  <code>count[26]</code> ，初始化為 0。</li>
<li>迴圈遍歷  <code>s</code> ，對每個字符  <code>c = s[i]</code>  做  <code>count[c - 'a']++</code> 。</li>
<li>迴圈遍歷  <code>t</code> ，對每個字符  <code>c = t[i]</code>  做  <code>count[c - 'a']--</code> ，若減到小於 0，代表字符出現次數不匹配，可直接回傳  <code>false</code> 。</li>
<li>最後如果所有  <code>count[i] == 0</code> ，回傳  <code>true</code> ；否則  <code>false</code> 。</li>
</ol>
<ul>
<li>時間複雜度為 O (n)，只需兩次線性掃描（n 為字串長度）。</li>
<li>空間複雜度為 O (1)，由於計數陣列大小固定為 26。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 長度不同則不可能為 anagram</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用長度為 26 的計數陣列</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 對 s 中字符計數 +1，對 t 中字符計數 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            count[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 檢查是否全部歸零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需對長度為 n 的字串各做一次線性掃描，計數與檢查操作均為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>使用固定大小為 26 的整數陣列作為計數，與輸入長度無關。</li>
</ul>
</li>
</ul>
<h3 id="binary-search"><a class="markdownIt-Anchor" href="#binary-search">#</a> Binary Search</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">題目連結</span><br>
<strong>標籤</strong>: Array, Binary Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given an array of integers  <code>nums</code>  which is sorted in ascending order, and an integer  <code>target</code> , write a function to search  <code>target</code>  in  <code>nums</code> . If  <code>target</code>  exists, then return its index. Otherwise, return  <code>-1</code> .</p>
<p>You must write an algorithm with O(log n) runtime complexity.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: nums = [-1,0,3,5,9,12], target = 9<br>
Output: 4<br>
Explanation: 9 exists in nums and its index is 4</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: nums = [-1,0,3,5,9,12], target = 2<br>
Output: -1<br>
Explanation: 2 does not exist in nums so return -1</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt; nums[i], target &lt; 10^4</code></li>
<li>All the integers in  <code>nums</code>  are <strong>unique</strong>.</li>
<li><code>nums</code>  is sorted in ascending order.</li>
<li><code>target</code>  is an integer.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用二分搜尋法（Binary Search）。</li>
<li>設定兩個指標  <code>left = 0</code>  與  <code>right = nums.size() - 1</code> ，維護當前搜尋範圍。</li>
<li>迴圈條件為  <code>left &lt;= right</code> ：
<ol>
<li>計算  <code>mid = left + (right - left) / 2</code> （避免整數溢位）。</li>
<li>若  <code>nums[mid] == target</code> ，則找到目標，回傳  <code>mid</code> 。</li>
<li>若  <code>nums[mid] &lt; target</code> ，代表目標在右半段，將  <code>left = mid + 1</code> 。</li>
<li>否則  <code>nums[mid] &gt; target</code> ，代表目標在左半段，將  <code>right = mid - 1</code> 。</li>
</ol>
</li>
<li>若迴圈結束都沒找到，回傳  <code>-1</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 避免 (left+right) 溢位</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (log n)</p>
<ul>
<li>每次都將搜尋範圍對半，最多需要 log n 次比較。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個輔助變數，不額外配置與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="flood-fill"><a class="markdownIt-Anchor" href="#flood-fill">#</a> Flood Fill</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmxvb2QtZmlsbC8=">題目連結</span><br>
<strong>標籤</strong>: Depth-First Search, Breadth-First Search, Matrix<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>An image is represented by a 2D integer grid  <code>image</code>  where  <code>image[i][j]</code>  represents the pixel value of the image.</p>
<p>You are also given three integers  <code>sr</code> ,  <code>sc</code> , and  <code>newColor</code> .</p>
<p>You should perform a “flood fill” on the image starting from the pixel  <code>image[sr][sc]</code> .</p>
<p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</p>
<p>Replace the color of all of the aforementioned pixels with  <code>newColor</code> .</p>
<p>Return the modified image after performing the flood fill.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image = [[1,1,1],  </span><br><span class="line">         [1,1,0],  </span><br><span class="line">         [1,0,1]],  </span><br><span class="line">  sr = 1, sc = 1, newColor = 2  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Output: [[2,2,2],[2,2,0],[2,0,1]]</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[2,2,2],  </span><br><span class="line"> [2,2,0],  </span><br><span class="line"> [2,0,1]] </span><br></pre></td></tr></table></figure>
<blockquote>
<p>Explanation:<br>
From the center of the image (position (1,1)), all pixels connected by a path of the same color as the starting pixel are colored.<br>
 初始的 image（3×3 矩陣）：<br>
1  1  1<br>
1  1  0<br>
1  0  1<br>
 起始位置 (sr, sc) = (1, 1)，newColor = 2</p>
</blockquote>
<blockquote>
<p>─── 填色過程 ───<br>
從 image [1][1]（數值為 1）開始，將和它「上下左右相連且數字相同」的所有 1 全部改成 2。</p>
</blockquote>
<blockquote>
<p>(1) 先把中心點 (1,1) 換色：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  1  1        1  1  1</span><br><span class="line">1 [1] 0   →    1 [2] 0</span><br><span class="line">1  0  1        1  0  1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(2) 看 (1,1) 的上下左右：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上方 (0,1) = 1 → 也要改成 2  </span><br><span class="line">下方 (2,1) = 0 → 不同，跳過  </span><br><span class="line">左方 (1,0) = 1 → 也要改成 2  </span><br><span class="line">右方 (1,2) = 0 → 跳過  </span><br><span class="line"></span><br><span class="line">**此時的狀態**：  </span><br><span class="line">   1  [2]  1        1  [2]  1</span><br><span class="line">  [2]  2   0   →   [2]  2   0</span><br><span class="line">   1   0   1        1   0   1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(3) 再繼續往外擴散：<br>
- 處理 (0,1)（目前值 2）的相鄰：<br>
(0,0)=1、(0,2)=1、(1,1)=2（已改）、(-1,1) 不存在<br>
其中 (0,0)=1、(0,2)=1 都屬於要改的範圍 → 改成 2<br>
- 處理 (1,0)（目前值 2）的相鄰：<br>
(0,0)=1（剛才改過了）、(2,0)=1 → 改成 2、(1,-1) 不存在、(1,1)=2（已改）<br>
- 不用再看 (1,2)、(2,1) 因為它們一開始就不是「1」。</p>
</blockquote>
<pre><code>**此時的狀態**：  
  [2]  [2]  [2]        [2]  [2]  [2]
  [2]  [2]  0   →     [2]  [2]  0
  [2]   0   1         [2]   0   1
</code></pre>
<blockquote>
<p>(4) 接著 (2,0) 原本是 1，因為跟 (1,0) 相連，也要改成 2，(2,2)=1 則和任何「已改成 2」都不相鄰（中間隔了 0），所以不要改。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**最終結果**：  </span><br><span class="line">  2   2   2</span><br><span class="line">  2   2   0</span><br><span class="line">  2   0   1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 0<br>
Output: [[0,0,0],[0,0,0]]<br>
Explanation: The new color is the same as the color of the starting pixel, so no changes are made.</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == image.length</code></li>
<li><code>n == image[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 50</code></li>
<li><code>0 &lt;= image[i][j], newColor &lt; 2^16</code></li>
<li><code>0 &lt;= sr &lt; m</code></li>
<li><code>0 &lt;= sc &lt; n</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用深度優先搜尋（DFS）或廣度優先搜尋（BFS）來遍歷與起始像素顏色相同且 4 方向相連的所有像素，並將它們的顏色換為  <code>newColor</code> 。</li>
<li>首先記錄起始點的顏色  <code>originalColor</code> ，如果  <code>originalColor == newColor</code> ，則直接回傳  <code>image</code> （因為無需更改）。</li>
<li>定義方向陣列  <code>dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;</code>  方便遍歷 4 個方向。</li>
<li>使用遞迴函式  <code>dfs(r, c)</code> ：
<ol>
<li>如果當前坐標  <code>(r, c)</code>  越界或  <code>image[r][c] != originalColor</code> ，則返回。</li>
<li>否則將  <code>image[r][c]</code>  設為  <code>newColor</code> 。</li>
<li>依序對 4 個方向呼叫  <code>dfs(r + dr, c + dc)</code> 。</li>
</ol>
</li>
<li>主函式調用  <code>dfs(sr, sc)</code>  後，回傳更新後的  <code>image</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> newColor) &#123;</span><br><span class="line">        <span class="type">int</span> m = image.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> originalColor = image[sr][sc];</span><br><span class="line">        <span class="comment">// 若原色與新色相同，直接回傳</span></span><br><span class="line">        <span class="keyword">if</span> (originalColor == newColor) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方向陣列：下、上、右、左</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 開始 DFS</span></span><br><span class="line">        <span class="built_in">dfs</span>(image, sr, sc, originalColor, newColor, m, n, dirs);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> originalColor, <span class="type">int</span> newColor, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&amp; dirs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 邊界條件與顏色檢查</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || image[r][c] != originalColor) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替換顏色</span></span><br><span class="line">        image[r][c] = newColor;</span><br><span class="line">        <span class="comment">// 遞迴探索四個方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> nr = r + d.first;</span><br><span class="line">            <span class="type">int</span> nc = c + d.second;</span><br><span class="line">            <span class="built_in">dfs</span>(image, nr, nc, originalColor, newColor, m, n, dirs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m * n)</p>
<ul>
<li>最壞情況下，所有像素都需要被訪問一次，因此需要遍歷 m*n 個格子。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (m * n)（遞迴棧）</p>
<ul>
<li>最壞情況下，遞迴深度可能達到 m*n，若圖像所有像素同色且連通。</li>
</ul>
</li>
</ul>
<h3 id="lowest-common-ancestor-of-a-binary-search-tree"><a class="markdownIt-Anchor" href="#lowest-common-ancestor-of-a-binary-search-tree">#</a> Lowest Common Ancestor of a Binary Search Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">題目連結</span><br>
<strong>標籤</strong>: Tree, Binary Search Tree<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a binary search tree (BST), find the  <code>lowest common ancestor (LCA)</code>  node of two given nodes in the BST.</p>
<p>The lowest common ancestor is defined between two nodes  <code>p</code>  and  <code>q</code>  as the lowest node in  <code>T</code>  that has both  <code>p</code>  and  <code>q</code>  as descendants (where we allow a node to be a descendant of itself).</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> / \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line">  / \</span><br><span class="line"> 3   5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</code> <br>
Output:  <code>6</code> <br>
Explanation: 節點 2 和 8 的 LCA 是 6。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   6</span><br><span class="line">   / \</span><br><span class="line">  2   8</span><br><span class="line"> / \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line">  / \</span><br><span class="line"> 3   5</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</code> <br>
Output:  <code>2</code> <br>
Explanation: 節點 2 和 4 的 LCA 是 2（因為 2 是 4 的祖先）。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>root = [2, 1], p = 2, q = 4</code> <br>
Output:  <code>2</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數量在範圍  <code>[2, 10^5]</code> 。</li>
<li><code>-10^9 &lt;= Node.val &lt;= 10^9</code> ，且樹中的所有  <code>Node.val</code>  皆互不相同。</li>
<li><code>p</code>  和  <code>q</code>  都是樹中存在的不同節點。</li>
<li>BST 保證左子樹所有節點值小於根節點值，右子樹所有節點值大於根節點值。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>利用 BST 性質：對於當前節點  <code>cur</code> ，比較  <code>p-&gt;val</code> 、 <code>q-&gt;val</code>  與  <code>cur-&gt;val</code> ：
<ol>
<li>若  <code>p-&gt;val &lt; cur-&gt;val</code>  且  <code>q-&gt;val &lt; cur-&gt;val</code> ，代表兩個節點都在左子樹，則將  <code>cur</code>  移至  <code>cur-&gt;left</code>  繼續搜尋。</li>
<li>若  <code>p-&gt;val &gt; cur-&gt;val</code>  且  <code>q-&gt;val &gt; cur-&gt;val</code> ，代表兩個節點都在右子樹，則將  <code>cur</code>  移至  <code>cur-&gt;right</code>  繼續搜尋。</li>
<li>否則（即一個小於或等於  <code>cur-&gt;val</code> ，另一個大於或等於  <code>cur-&gt;val</code> ），當前  <code>cur</code>  即為最近公共祖先，可直接回傳。</li>
</ol>
</li>
<li>由於每次都往該方向跨越一個子樹，最壞情況需遍歷至樹高。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 若兩者都小於當前節點，往左子樹找</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; cur-&gt;val &amp;&amp; q-&gt;val &lt; cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若兩者都大於當前節點，往右子樹找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; cur-&gt;val &amp;&amp; q-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否則當前節點即為 LCA</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 理論上不會到這裡，因為 p 和 q 一定存在於 BST 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (h)</p>
<ul>
<li>h 為樹的高度。最壞情況（退化成鏈）時 h = n，時間為 O (n)；若為平衡 BST，h = O (log n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個指標，不需額外空間儲存與遞迴棧。</li>
</ul>
</li>
</ul>
<h3 id="balanced-binary-tree"><a class="markdownIt-Anchor" href="#balanced-binary-tree">#</a> Balanced Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a binary tree, determine if it is height-balanced.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>root = [3,9,20,null,null,15,7]</code> <br>
Output:  <code>true</code> <br>
Explanation:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   / \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input:  <code>root = [1,2,2,3,3,null,null,4,4]</code> <br>
Output:  <code>false</code> <br>
Explanation:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 3:<br>
Input:  <code>root = []</code> <br>
Output:  <code>true</code> <br>
Explanation: 空樹被視為平衡二元樹。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>二元樹節點數量在範圍  <code>[0, 10^4]</code> 。</li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>我們可以透過遞迴（DFS）在一次遍歷中，同時計算子樹高度並檢查平衡性。</li>
<li>定義一個輔助函式  <code>height(TreeNode* node)</code> ，回傳該節點為根時的子樹高度；若該子樹不平衡，則回傳  <code>-1</code>  作為標記。
<ol>
<li>如果  <code>node</code>  為  <code>nullptr</code> ，回傳高度  <code>0</code> 。</li>
<li>遞迴計算左子樹高度  <code>leftH = height(node-&gt;left)</code> ，若  <code>leftH == -1</code> ，直接回傳  <code>-1</code> （代表左子樹已經不平衡）。</li>
<li>遞迴計算右子樹高度  <code>rightH = height(node-&gt;right)</code> ，若  <code>rightH == -1</code> ，直接回傳  <code>-1</code> （代表右子樹已經不平衡）。</li>
<li>如果  <code>abs(leftH - rightH) &gt; 1</code> ，代表當前節點不平衡，回傳  <code>-1</code> 。</li>
<li>否則回傳  <code>max(leftH, rightH) + 1</code>  作為當前子樹高度。</li>
</ol>
</li>
<li>最後在主函式  <code>isBalanced(TreeNode* root)</code>  中，只需檢查  <code>height(root) != -1</code>  即可判定是否為平衡二元樹。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若子樹不平衡，回傳 -1；否則回傳子樹高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 計算左子樹高度</span></span><br><span class="line">        <span class="type">int</span> leftH = <span class="built_in">height</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftH == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 左子樹不平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 計算右子樹高度</span></span><br><span class="line">        <span class="type">int</span> rightH = <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightH == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 右子樹不平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右高度差超過 1，當前節點不平衡</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftH - rightH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否則回傳當前節點子樹的高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>每個節點只會被訪問一次；透過遞迴自底向上計算高度並檢查平衡，總共 O (n) 次呼叫。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (h)（遞迴棧）</p>
<ul>
<li>h 為二元樹高度；最壞情況（樹為一條鏈）時 h = n，空間複雜度為 O (n)；若為平衡樹，h = O (log n)。</li>
</ul>
</li>
</ul>
<h3 id="linked-list-cycle"><a class="markdownIt-Anchor" href="#linked-list-cycle">#</a> Linked List Cycle</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">題目連結</span><br>
<strong>標籤</strong>：鏈表 (Linked List)、雙指針 (Two Pointers)<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個單向鏈表的頭節點  <code>head</code> ，判斷鏈表中是否存在環 (cycle)。如果存在，則返回  <code>true</code> ；否則返回  <code>false</code> 。<br>
Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the  <code>next</code>  pointer.</p>
<p>Internally,  <code>pos</code>  is used to denote the index of the node that tail’s  <code>next</code>  pointer is connected to.</p>
<p><code>Note that pos is not passed as a parameter.</code></p>
<p>Return  <code>true</code>  if there is a cycle in the linked list. Otherwise, return  <code>false</code> .<br>
<strong> 範例</strong></p>
</blockquote>
<blockquote>
<p>Example 1:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(3) → (2) → (0) → (-4)</span><br><span class="line">       ↑           │</span><br><span class="line">       └───────────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Input: head = [3,2,0,-4], pos = 1<br>
Output: true<br>
Explanation: 尾節點指向第二個節點，形成環。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) → (2)</span><br><span class="line"> ↑     │</span><br><span class="line"> └─────┘</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Input: head = [1,2], pos = 0<br>
Output: true<br>
Explanation: 尾節點指向第一個節點，形成環。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: head = [1], pos = -1<br>
Output: false<br>
Explanation: 無環，pos = -1 表示沒有環。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為  <code>[0, 10^4]</code> 。</li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code> 。</li>
<li><code>pos</code>  表示尾節點指向的位置索引， <code>pos = -1</code>  表示沒有環。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用「快慢指針」(tortoise and hare) 方法：
<ol>
<li>初始化慢指針  <code>slow = head</code> ，快指針  <code>fast = head</code> 。</li>
<li>每一步中，慢指針前進一個節點 ( <code>slow = slow-&gt;next</code> )，快指針前進兩個節點 ( <code>fast = fast-&gt;next-&gt;next</code> )。</li>
<li>如果在某一步驟中  <code>fast == nullptr</code>  或  <code>fast-&gt;next == nullptr</code> ，說明鏈表到達末端，沒有環，返回  <code>false</code> 。</li>
<li>如果  <code>slow == fast</code> ，說明快指針已經追上慢指針，存在環，返回  <code>true</code> 。</li>
<li>重複步驟直到返回結果。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空鏈表或僅一個節點，不可能有環</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;          <span class="comment">// 慢指針，每次走一步</span></span><br><span class="line">        ListNode *fast = head-&gt;next;    <span class="comment">// 快指針，每次走兩步</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 快指針到達末端，無環</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;           <span class="comment">// 慢指針向前一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;     <span class="comment">// 快指針向前兩步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 慢指針與快指針相遇，有環</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>快慢指針最多各自遍歷 O (n) 次，在鏈表長度為 n 時，通過有限次迭代即可判斷是否有環。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個指針，不需要額外記憶體，空間複雜度為常數。</li>
</ul>
</li>
</ul>
<h3 id="implement-queue-using-stacks"><a class="markdownIt-Anchor" href="#implement-queue-using-stacks">#</a> Implement Queue using Stacks</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">題目連結</span><br>
<strong>標籤</strong>: Stack, Design<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue ( <code>push</code> ,  <code>pop</code> ,  <code>peek</code> , and  <code>empty</code> ).</p>
<p>Implement the  <code>MyQueue</code>  class:</p>
<ul>
<li><code>void push(int x)</code>  Pushes element  <code>x</code>  to the back of the queue.</li>
<li><code>int pop()</code>  Removes the element from the front of the queue and returns it.</li>
<li><code>int peek()</code>  Returns the element at the front of the queue.</li>
<li><code>boolean empty()</code>  Returns  <code>true</code>  if the queue is empty,  <code>false</code>  otherwise.</li>
</ul>
<p><strong>Notes:</strong></p>
<ul>
<li>You must use only standard operations of a stack, which means only  <code>push to top</code> ,  <code>peek/pop from top</code> ,  <code>size</code> , and  <code>is empty</code>  operations are valid.</li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack using a list or deque (as long as you use only standard stack operations).</li>
</ul>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>Input<br>
[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>
[[], [1], [2], [], [], []]<br>
Output<br>
[null, null, null, 1, 1, false]<br>
Explanation<br>
MyQueue myQueue = new MyQueue();<br>
myQueue.push(1); // queue is: [1]<br>
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>
myQueue.peek();  // return 1<br>
myQueue.pop();   // return 1, queue is [2]<br>
myQueue.empty(); // return false</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多呼叫  <code>push</code> ,  <code>pop</code> ,  <code>peek</code> ,  <code>empty</code>  共  <code>100</code>  次</li>
<li>當呼叫  <code>pop</code>  或  <code>peek</code>  時，保證隊列不為空</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用兩個堆疊：一個作為「輸入棧（inStack）」用來接收  <code>push</code>  的元素；另一個作為「輸出棧（outStack）」用來做  <code>pop</code>  或  <code>peek</code>  操作。</li>
<li>當執行  <code>push(x)</code>  時，直接將  <code>x</code>  推入  <code>inStack</code> 。</li>
<li>當執行  <code>pop()</code>  或  <code>peek()</code>  時，若  <code>outStack</code>  為空，則將  <code>inStack</code>  內所有元素依次彈出並推入  <code>outStack</code> （這樣可以將最早推入的元素放到  <code>outStack</code>  頂部）。之後， <code>pop()</code>  就從  <code>outStack.top()</code>  取出並  <code>pop</code> ； <code>peek()</code>  則回傳  <code>outStack.top()</code> 。</li>
<li><code>empty()</code>  只需檢查  <code>inStack</code>  和  <code>outStack</code>  是否都為空。</li>
<li>這樣可以保證隊列操作的正確性：每當需要出隊時，如果  <code>outStack</code>  有元素就直接對應隊首，否則就把所有「輸入棧」的元素移到「輸出棧」，完成先進先出行為。</li>
<li>每個元素最多從  <code>inStack</code>  移到  <code>outStack</code>  一次，因此攤銷時間複雜度仍為 O (1)。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveInToOut</span>();</span><br><span class="line">        <span class="type">int</span> frontVal = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> frontVal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveInToOut</span>();</span><br><span class="line">        <span class="keyword">return</span> outStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack;   <span class="comment">// 用來接收 push 的元素</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack;  <span class="comment">// 用來執行 pop 和 peek</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 inStack 中的所有元素移動到 outStack，僅在 outStack 為空時呼叫</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveInToOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (1)</p>
<ul>
<li>每個元素最多被移動一次：從 inStack 推到 outStack；其餘操作（push、pop、peek、empty）均為常數時間。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>需要額外使用兩個堆疊來儲存最多 n 個元素。</li>
</ul>
</li>
</ul>
<h2 id="week-2-1212"><a class="markdownIt-Anchor" href="#week-2-1212">#</a> Week 2 (12/12)</h2>
<h3 id="first-bad-version"><a class="markdownIt-Anchor" href="#first-bad-version">#</a> First Bad Version</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">題目連結</span><br>
<strong>標籤</strong>: Binary Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>
<p>Suppose you have  <code>n</code>  versions  <code>[1, 2, ..., n]</code>  and you want to find out the first bad one, which causes all the following ones to be bad.</p>
<p>You are given an API  <code>bool isBadVersion(version)</code>  which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>n = 5</code> ,  <code>bad = 4</code> <br>
Output:  <code>4</code> <br>
Explanation:<br>
call  <code>isBadVersion(3)</code>  → false<br>
call  <code>isBadVersion(5)</code>  → true<br>
call  <code>isBadVersion(4)</code>  → true<br>
So, 4 is the first bad version.</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>n = 1</code> ,  <code>bad = 1</code> <br>
Output:  <code>1</code> <br>
Explanation: Only one version and it is bad.</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= bad &lt;= n &lt;= 2^31 - 1</code></li>
<li>呼叫 API  <code>isBadVersion</code>  次數應盡量少。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用二分搜尋法（Binary Search）定位第一個壞版本：
<ol>
<li>設定  <code>left = 1</code> ,  <code>right = n</code> 。</li>
<li>在迴圈中計算  <code>mid = left + (right - left) / 2</code> （防止溢位）。</li>
<li>呼叫  <code>isBadVersion(mid)</code> ：
<ul>
<li>如果返回  <code>true</code> ，代表第  <code>mid</code>  版是壞的，壞版本範圍縮至  <code>[left, mid]</code> ，因此將  <code>right = mid</code> 。</li>
<li>如果返回  <code>false</code> ，代表第  <code>mid</code>  版是好的，壞版本必在  <code>mid+1</code>  到  <code>right</code> ，因此將  <code>left = mid + 1</code> 。</li>
</ul>
</li>
<li>直到  <code>left == right</code> ，此時  <code>left</code>  或  <code>right</code>  即為第一個壞版本，返回  <code>left</code> 。</li>
</ol>
</li>
<li>二分搜尋可保證最少化函式調用次數，時間複雜度為  <code>O(log n)</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                <span class="comment">// mid 及之後皆為壞版本，向左收縮</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mid 為好版本，壞版本在 mid+1 之後</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (log n)</p>
<ul>
<li>每次二分搜尋都將範圍縮減一半，最壞情況下需 log n 次呼叫 isBadVersion。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個輔助變數（left, right, mid），不依賴額外空間。</li>
</ul>
</li>
</ul>
<h3 id="ransom-note"><a class="markdownIt-Anchor" href="#ransom-note">#</a> Ransom Note</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">題目連結</span><br>
<strong>標籤</strong>: Hash Table, String<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given two strings  <code>ransomNote</code>  and  <code>magazine</code> , return  <code>true</code>  if  <code>ransomNote</code>  can be constructed by using the letters from  <code>magazine</code>  and  <code>false</code>  otherwise.</p>
<p>Each letter in  <code>magazine</code>  can only be used once in  <code>ransomNote</code> .</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: ransomNote =  <code>&quot;a&quot;</code> , magazine =  <code>&quot;b&quot;</code> <br>
Output:  <code>false</code></p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: ransomNote =  <code>&quot;aa&quot;</code> , magazine =  <code>&quot;ab&quot;</code> <br>
Output:  <code>false</code></p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: ransomNote =  <code>&quot;aa&quot;</code> , magazine =  <code>&quot;aab&quot;</code> <br>
Output:  <code>true</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code></li>
<li><code>ransomNote</code>  和  <code>magazine</code>  只包含小寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>方法一（計數陣列）：
<ol>
<li>如果  <code>ransomNote.length() &gt; magazine.length()</code> ，直接回傳  <code>false</code> ，因為信件請求長度大於雜誌字母總數，不可能構造。</li>
<li>建立長度為 26 的整數陣列  <code>count[26]</code> ，初始化為 0。</li>
<li>遍歷  <code>magazine</code> ，對  <code>magazine[i]</code>  字符做  <code>count[magazine[i] - 'a']++</code> 。</li>
<li>遍歷  <code>ransomNote</code> ，對  <code>ransomNote[i]</code>  字符做  <code>count[ransomNote[i] - 'a']--</code> ，若減到小於 0，說明雜誌中該字符不足，返回  <code>false</code> 。</li>
<li>整個過程若未出現不足，即可回傳  <code>true</code> 。</li>
</ol>
<ul>
<li>時間複雜度 O (n + m)，n 為  <code>magazine</code>  長度，m 為  <code>ransomNote</code>  長度。</li>
<li>空間複雜度 O (1)，計數陣列大小固定為 26。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="type">const</span> string&amp; ransomNote, <span class="type">const</span> string&amp; magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 對 magazine 中字符計數 +1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine) &#123;</span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 對 ransomNote 中字符計數 -1，若不足則回傳 false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--count[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n + m)</p>
<ul>
<li>需遍歷 magazine 長度 n 做一次計數，以及遍歷 ransomNote 長度 m 做一次扣減，總共為 O (n + m)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>使用固定大小為 26 的整數陣列，不隨輸入長度變化。</li>
</ul>
</li>
</ul>
<h3 id="climbing-stairs"><a class="markdownIt-Anchor" href="#climbing-stairs">#</a> Climbing Stairs</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">題目連結</span><br>
<strong>標籤</strong>: Dynamic Programming, Math<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are climbing a staircase. It takes  <code>n</code>  steps to reach the top.</p>
<p>Each time you can either climb  <code>1</code>  or  <code>2</code>  steps. In how many distinct ways can you climb to the top?</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: n = 2<br>
Output: 2<br>
Explanation: There are two ways to climb to the top:</p>
<ol>
<li>1 step + 1 step</li>
<li>2 steps</li>
</ol>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: n = 3<br>
Output: 3<br>
Explanation: There are three ways to climb to the top:</p>
<ol>
<li>1 step + 1 step + 1 step</li>
<li>1 step + 2 steps</li>
<li>2 steps + 1 step</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題屬於經典的動態規劃 (Dynamic Programming) 問題，也可用數學的方法（Fibonacci）解決。</li>
<li>設  <code>dp[i]</code>  為爬到第  <code>i</code>  級台階的所有可能方式數。</li>
<li>由於每次只能爬 1 或 2 級，因此到達第  <code>i</code>  級的方式可由到達第  <code>i-1</code>  級再跨 1 步，或到達第  <code>i-2</code>  級再跨 2 步：
<blockquote>
<p><code>dp[i] = dp[i-1] + dp[i-2]</code></p>
</blockquote>
</li>
<li>初始條件：
<blockquote>
<p><code>dp[1] = 1</code>  （只有一種方式：跨 1 步）<br>
 <code>dp[2] = 2</code>  （兩種方式：1+1 或 2）</p>
</blockquote>
</li>
<li>依此遞推至  <code>dp[n]</code>  即為答案。</li>
<li>為節省空間，可只用兩個變數滾動更新，不需整個  <code>dp</code>  陣列。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prev2 代表 dp[i-2]，初始為 dp[1] = 1</span></span><br><span class="line">        <span class="type">int</span> prev2 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// prev1 代表 dp[i-1]，初始為 dp[2] = 2</span></span><br><span class="line">        <span class="type">int</span> prev1 = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            curr = prev1 + prev2; <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">            prev2 = prev1;        <span class="comment">// 滾動更新：下一輪的 dp[i-2]</span></span><br><span class="line">            prev1 = curr;         <span class="comment">// 更新 dp[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需要一次從 3 到 n 的迴圈，每次操作為常數時間。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個變數，不需額外與 n 線性相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="longest-palindrome"><a class="markdownIt-Anchor" href="#longest-palindrome">#</a> Longest Palindrome</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">題目連結</span><br>
<strong>標籤</strong>: Hash Table, String, Greedy<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由大小寫英文字母組成的字串  <code>s</code> ，請你找出可以由這些字母「組成」的最長回文串的長度。你可以假設字母的大小寫有區分，例如  <code>'A'</code>  和  <code>'a'</code>  被視為不同字元。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: s =  <code>&quot;abccccdd&quot;</code> <br>
Output:  <code>7</code> <br>
Explanation: 可以構造的最長回文串為  <code>&quot;dccaccd&quot;</code> ，長度為 7。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: s =  <code>&quot;a&quot;</code> <br>
Output:  <code>1</code> <br>
Explanation: 回文串就是  <code>&quot;a&quot;</code> ，長度為 1。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code>  只包含英文字母（大寫、小寫）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>要構造最長回文串，回文的特性是中間可以有一個單獨的字元，其餘字元必須成對出現（左右對稱）。</li>
<li>可以先統計每個字元出現次數，對於每個字元：
<ol>
<li>如果該字元出現次數為偶數，則可全部用於回文，長度直接加上該偶數。</li>
<li>如果該字元出現次數為奇數，則可用  <code>count - 1</code> （偶數部分）來組成對稱部分，並且保留一個候選作為中心字元（如果尚未使用中心字元）。</li>
</ol>
</li>
<li>最終，只要有至少一個字元出現次數為奇數，就可以在中心放置一個字元讓回文長度加 1。</li>
<li>因此流程為：
<ol>
<li>建立  <code>unordered_map&lt;char,int&gt;</code>  或長度 128 的陣列來統計字元出現次數。</li>
<li>遍歷所有字元計算總可用偶數長度，並記錄是否存在奇數出現。</li>
<li>如果存在任一奇數，總長度再加 1；否則直接回傳偶數總和。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用大小為 128 的計數陣列統計所有 ASCII 字元</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> hasOdd = <span class="literal">false</span>; <span class="comment">// 標記是否存在出現次數為奇數的字元</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> freq : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 偶數次數全部可以用</span></span><br><span class="line">                length += freq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 奇數次數只能用 freq - 1，並標記可放置中心字元</span></span><br><span class="line">                length += freq - <span class="number">1</span>;</span><br><span class="line">                hasOdd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有任何一個字元出現次數為奇數，可以把其中一個放到回文中心</span></span><br><span class="line">        <span class="keyword">if</span> (hasOdd) &#123;</span><br><span class="line">            length += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>n 為字串長度。需要一次掃描字串進行統計，然後再掃描長度固定（128）的計數陣列。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>使用固定大小（128）的計數陣列，與輸入長度無關。</li>
</ul>
</li>
</ul>
<h3 id="reverse-linked-list"><a class="markdownIt-Anchor" href="#reverse-linked-list">#</a> Reverse Linked List</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">題目連結</span><br>
<strong>標籤</strong>: Linked List, Iteration, Recursion<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個單向鏈表的頭節點  <code>head</code> ，將該鏈表反轉，並返回反轉後的頭節點。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>head = [1,2,3,4,5]</code> <br>
Output:  <code>[5,4,3,2,1]</code></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始鏈結串列：</span><br><span class="line">(1) → (2) → (3) → (4) → (5)</span><br><span class="line"></span><br><span class="line">              ↓</span><br><span class="line">              ↓</span><br><span class="line"></span><br><span class="line">反轉後鏈結串列：</span><br><span class="line">(5) → (4) → (3) → (2) → (1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input:  <code>head = [1,2]</code> <br>
Output:  <code>[2,1]</code></p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始：</span><br><span class="line">(1) → (2)</span><br><span class="line"></span><br><span class="line">   ↓</span><br><span class="line"></span><br><span class="line">反轉後：</span><br><span class="line">(2) → (1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 3:<br>
Input:  <code>head = []</code> <br>
Output:  <code>[]</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為  <code>[0, 5000]</code> 。</li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code> 。</li>
<li>必須在 O (n) 時間內完成，且使用 O (1) 額外空間（不含遞迴棧空間）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>
<p><strong>迭代法 (Iteration)</strong>：</p>
<ol>
<li>使用三個指標： <code>prev = nullptr</code> （指向已反轉部分的尾節點）、 <code>curr = head</code> （當前要處理的節點）、 <code>nextTemp</code> （暫存  <code>curr-&gt;next</code> ）。</li>
<li>迴圈條件為  <code>curr != nullptr</code> ：
<ul>
<li>先將  <code>curr-&gt;next</code>  暫存到  <code>nextTemp</code> 。</li>
<li>將  <code>curr-&gt;next</code>  指向  <code>prev</code> ，完成節點反向指向。</li>
<li>更新  <code>prev = curr</code> （新的已反轉部分尾巴），並將  <code>curr = nextTemp</code> （繼續處理下一個節點）。</li>
</ul>
</li>
<li>迴圈結束時， <code>prev</code>  即為反轉後的新頭節點，返回  <code>prev</code> 。</li>
</ol>
<ul>
<li>此方法只需一趟遍歷，並且使用常數級輔助變數。</li>
</ul>
</li>
<li>
<p><strong>遞迴法 (Recursion)</strong>：</p>
<ol>
<li>如果  <code>head == nullptr</code>  或  <code>head-&gt;next == nullptr</code> ，直接返回  <code>head</code> （空表或單節點就是反轉後本身）。</li>
<li>呼叫  <code>ListNode* p = reverseList(head-&gt;next)</code>  取得反轉後的尾部節點  <code>p</code> 。</li>
<li>將  <code>head-&gt;next-&gt;next = head</code> ，使下一節點指回  <code>head</code> ，再將  <code>head-&gt;next = nullptr</code>  斷開。</li>
<li>返回  <code>p</code> （整個反轉後的頭節點）。</li>
</ol>
<ul>
<li>遞迴法的呼叫深度為鏈表長度 h，因此額外空間為遞迴棧 O (h)。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next; <span class="comment">// 暫存下一節點</span></span><br><span class="line">            curr-&gt;next = prev;               <span class="comment">// 反轉指向</span></span><br><span class="line">            prev = curr;                     <span class="comment">// 移動 prev</span></span><br><span class="line">            curr = nextTemp;                 <span class="comment">// 處理下一節點</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 即為新的頭節點</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遞迴法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ListNode* reverseList(ListNode* head) &#123;</span></span><br><span class="line"><span class="comment">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ListNode* p = reverseList(head-&gt;next); </span></span><br><span class="line"><span class="comment">        head-&gt;next-&gt;next = head; // 下個節點指回 current</span></span><br><span class="line"><span class="comment">        head-&gt;next = nullptr;    // 斷開 current 節點的 next</span></span><br><span class="line"><span class="comment">        return p;                // p 是反轉後的新頭節點</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>單趟遍歷整個鏈表，共有 n 個節點，每個節點只處理一次。</li>
</ul>
</li>
<li>
<p>空間複雜度 (迭代法)：O (1)</p>
<ul>
<li>只使用常數個指標變數，不額外配置與 n 相關的空間。</li>
</ul>
</li>
<li>
<p>空間複雜度 (遞迴法)：O (n)（遞迴棧）</p>
<ul>
<li>遞迴深度等於鏈表長度 n，遞迴棧使用空間為 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="majority-element"><a class="markdownIt-Anchor" href="#majority-element">#</a> Majority Element</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWFqb3JpdHktZWxlbWVudC8=">題目連結</span><br>
<strong>標籤</strong>: Array, Divide and Conquer, Hash Table, Sorting<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個大小為  <code>n</code>  的陣列  <code>nums</code> ，請找出其中的「主元素」（Majority Element），即在陣列中出現次數 <strong>嚴格大於</strong> ⌊n/2⌋ 的元素。<br>
你可以假設主元素一定存在於陣列中。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>nums = [3,2,3]</code> <br>
Output:  <code>3</code></p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>nums = [2,2,1,1,1,2,2]</code> <br>
Output:  <code>2</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
<li>主元素一定存在。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以使用 <strong>Boyer–Moore 投票演算法（Boyer–Moore Voting Algorithm）</strong>，時間複雜度 O (n)、空間複雜度 O (1)。</p>
<p>演算法流程：</p>
<ol>
<li>初始化  <code>candidate</code> （候選元素）為任意值、 <code>count = 0</code> 。</li>
<li>遍歷陣列  <code>nums</code>  中的每個元素  <code>num</code> ：
<ul>
<li>當  <code>count == 0</code>  時，將  <code>candidate = num</code> 。</li>
<li>若  <code>num == candidate</code> ， <code>count++</code> ；否則  <code>count--</code> 。</li>
</ul>
</li>
<li>最終  <code>candidate</code>  即為主元素。</li>
</ol>
<p>原理：因為主元素出現次數大於 ⌊n/2⌋，當我們遍歷時，凡是當前值與候選相同，就增加計數；若不同，就抵消一個候選的影響。由於主元素出現次數占大多數，最終剩下的候選必為主元素。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需一次線性掃描陣列。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>僅使用常數個輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="add-binary"><a class="markdownIt-Anchor" href="#add-binary">#</a> Add Binary</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWRkLWJpbmFyeS8=">題目連結</span><br>
<strong>標籤</strong>: String, Math<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定兩個二進位字串  <code>a</code>  和  <code>b</code> ，請回傳它們相加後的二進位字串。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: a =  <code>&quot;11&quot;</code> , b =  <code>&quot;1&quot;</code> <br>
Output:  <code>&quot;100&quot;</code></p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: a =  <code>&quot;1010&quot;</code> , b =  <code>&quot;1011&quot;</code> <br>
Output:  <code>&quot;10101&quot;</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code></li>
<li><code>a</code>  和  <code>b</code>  只包含字符  <code>'0'</code>  或  <code>'1'</code> 。</li>
<li>每個字串除非整串為  <code>&quot;0&quot;</code> ，否則不含前導零。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用雙指標從字串末端開始遍歷，同時維護進位  <code>carry</code> 。</li>
<li>設定  <code>i = a.length() - 1</code> ,  <code>j = b.length() - 1</code> 。</li>
<li>當  <code>i &gt;= 0 || j &gt;= 0 || carry != 0</code> ：
<ol>
<li>取  <code>digitA = (i &gt;= 0) ? a[i] - '0' : 0</code> ， <code>digitB = (j &gt;= 0) ? b[j] - '0' : 0</code> 。</li>
<li>計算總和  <code>sum = digitA + digitB + carry</code> 。</li>
<li>當前位結果為  <code>sum % 2</code> ，更新  <code>carry = sum / 2</code> 。</li>
<li>將  <code>(sum % 2)</code>  推入答案字串（先收集後反轉）。</li>
<li><code>i--</code> ,  <code>j--</code> ，重複上述步驟。</li>
</ol>
</li>
<li>最後反轉收集到的結果並回傳。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = (<span class="type">int</span>)b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> digitA = (i &gt;= <span class="number">0</span>) ? a[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> digitB = (j &gt;= <span class="number">0</span>) ? b[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = digitA + digitB + carry;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + (sum % <span class="number">2</span>)));</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (max (m, n))</p>
<ul>
<li>其中 m = a.length (), n = b.length ()；需要遍歷最長字串長度次數。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (max (m, n))</p>
<ul>
<li>用於存儲結果的字串長度最多為 max (m, n) + 1。</li>
</ul>
</li>
</ul>
<h3 id="diameter-of-binary-tree"><a class="markdownIt-Anchor" href="#diameter-of-binary-tree">#</a> Diameter of Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search, Recursion<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點  <code>root</code> ，請你計算並回傳該二元樹的「直徑」（diameter）。</p>
<p>二元樹的直徑定義為任意兩個節點之間的最長路徑邊數。這條路徑可以不經過根節點。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>root = [1,2,3,4,5]</code> <br>
Output:  <code>3</code> <br>
Explanation: 最長路徑為節點 4 → 2 → 1 → 3（或 5 → 2 → 1 → 3），邊的數量為 3。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>root = [1,2]</code> <br>
Output:  <code>1</code> <br>
Explanation: 最長路徑為節點 2 → 1，邊的數量為 1。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>二元樹節點數量在範圍  <code>[1, 10^4]</code> 。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code> 。</li>
<li>結果保證在 32 位整數範圍內。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>我們需要計算任意兩個節點之間的最長路徑邊數。</li>
<li>對於某個節點  <code>node</code> ，以該節點為「橋梁」的最長路徑長度可以表示為「左子樹最大深度」加上「右子樹最大深度」。</li>
<li>因此，只要在一次遞迴遍歷中，同時計算每個節點的子樹高度，並在計算過程中更新全域的  <code>diameter</code>  為  <code>max(diameter, leftHeight + rightHeight)</code> ，即可得到最終答案。</li>
<li>定義輔助函式  <code>height(TreeNode* node)</code> ：
<ol>
<li>若  <code>node == nullptr</code> ，回傳高度 0。</li>
<li>透過遞迴，先取得  <code>leftH = height(node-&gt;left)</code> ，再取得  <code>rightH = height(node-&gt;right)</code> 。</li>
<li>更新全域變數  <code>diameter = max(diameter, leftH + rightH)</code> 。</li>
<li>回傳  <code>max(leftH, rightH) + 1</code>  作為該節點的高度。</li>
</ol>
</li>
<li>最後在主函式中呼叫  <code>height(root)</code> ，並回傳紀錄到的  <code>diameter</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        diameter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> diameter;  <span class="comment">// 紀錄當前最長直徑（邊數）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以 node 為根的子樹高度，同時更新 diameter</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftH = <span class="built_in">height</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightH = <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">// 以當前節點為橋梁，左右子樹高度之和就是通過此節點的最大邊數</span></span><br><span class="line">        diameter = <span class="built_in">max</span>(diameter, leftH + rightH);</span><br><span class="line">        <span class="comment">// 返回該子樹高度：較高的子樹高度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>每個節點只會被訪問一次，計算左右子樹高度與更新 diameter 均為常數時間。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (h)（遞迴棧空間）</p>
<ul>
<li>h 為二元樹高度，最壞情況（樹退化為鏈）時 h = n，空間複雜度為 O (n)；若為平衡樹，h = O (log n)。</li>
</ul>
</li>
</ul>
<h3 id="middle-of-the-linked-list"><a class="markdownIt-Anchor" href="#middle-of-the-linked-list">#</a> Middle of the Linked List</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">題目連結</span><br>
<strong>標籤</strong>: Linked List, Two Pointers<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定單向鏈表的頭節點  <code>head</code> ，請返回鏈表的中間節點。如果鏈表有兩個中間節點，則返回第二個中間節點。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: head = [1,2,3,4,5]<br>
Output: [3,4,5]<br>
 Explanation: 中間節點為 3。返回節點 3 及其後所有節點。<br>
(1) → (2) → [3] → (4) → (5)</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: head = [1,2,3,4,5,6]<br>
Output: [4,5,6]<br>
 Explanation: 鏈表有兩個中間節點（3 和 4），因此返回第二個中間節點 4 及其後所有節點。<br>
(1) → (2) → (3) → [4] → (5) → (6)</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為  <code>[1, 100]</code> 。</li>
<li><code>1 &lt;= Node.val &lt;= 100</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用「快慢指針」（Two Pointers）：
<ol>
<li>初始化兩個指針  <code>slow = head</code> （每次走一步）和  <code>fast = head</code> （每次走兩步）。</li>
<li>當  <code>fast</code>  不為  <code>nullptr</code>  且  <code>fast-&gt;next</code>  不為  <code>nullptr</code>  時，執行：
<ul>
<li><code>slow = slow-&gt;next;</code></li>
<li><code>fast = fast-&gt;next-&gt;next;</code></li>
</ul>
</li>
<li>當迴圈結束時， <code>slow</code>  指向的即為中間節點（如果長度為偶數，則指向第二個中間節點）。</li>
<li>直接返回  <code>slow</code> 。</li>
</ol>
</li>
<li>此方法只需一次遍歷，時間複雜度 O (n)，且空間複雜度 O (1)。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指針都從 head 開始</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="comment">// fast 每次走兩步，slow 每次走一步</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最後 slow 指向中間節點（若為偶數長度，為第二中間節點）</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需一次遍歷鏈表，快指針走兩步、慢指針走一步，最多迴圈 ⌈n/2⌉ 次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個輔助指針，不使用額外空間。</li>
</ul>
</li>
</ul>
<h3 id="maximum-depth-of-binary-tree"><a class="markdownIt-Anchor" href="#maximum-depth-of-binary-tree">#</a> Maximum Depth of Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search, Breadth-First Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given the root of a binary tree, return its maximum depth.</p>
<p>A binary tree’s  <code>maximum depth</code>  is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>root = [3,9,20,null,null,15,7]</code> <br>
Output:  <code>3</code> <br>
Explanation: The maximum depth is 3 because the longest path is 3 → 20 → 7 (or 3 → 20 → 15).</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  (3)</span><br><span class="line">  /   \</span><br><span class="line">(9)   (20)</span><br><span class="line">      /  \</span><br><span class="line">   (15)  (7)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input:  <code>root = [1,null,2]</code> <br>
Output:  <code>2</code></p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>root = []</code> <br>
Output:  <code>0</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in the tree is in the range  <code>[0, 10^4]</code> .</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>可以使用遞迴（Depth-First Search）或迭代（Breadth-First Search）來計算最大深度。</li>
<li><strong>遞迴（DFS）做法</strong>：
<ol>
<li>如果當前節點為  <code>nullptr</code> ，回傳深度  <code>0</code> 。</li>
<li>否則遞迴計算左子樹深度  <code>leftDepth = maxDepth(root-&gt;left)</code> ，再計算右子樹深度  <code>rightDepth = maxDepth(root-&gt;right)</code> 。</li>
<li>當前節點的最大深度即為  <code>max(leftDepth, rightDepth) + 1</code> ，其中  <code>+1</code>  代表包含當前節點。</li>
</ol>
</li>
<li><strong>迭代（BFS）做法</strong>：
<ol>
<li>如果根為  <code>nullptr</code> ，回傳  <code>0</code> 。</li>
<li>使用一個佇列  <code>queue&lt;TreeNode*&gt; q</code> ，先將  <code>root</code>  推入佇列。</li>
<li>初始化  <code>depth = 0</code> 。</li>
<li>當佇列不為空時：
<ul>
<li>令  <code>levelSize = q.size()</code> （當前層節點數），並遍歷這一層所有節點：
<ul>
<li>取出節點  <code>node = q.front()</code>  並  <code>q.pop()</code> ，若  <code>node-&gt;left</code>  非空則  <code>q.push(node-&gt;left)</code> 、若  <code>node-&gt;right</code>  非空則  <code>q.push(node-&gt;right)</code> 。</li>
</ul>
</li>
<li>這一層處理完畢後， <code>depth++</code>  表示深度加 1。</li>
</ul>
</li>
<li>最終  <code>depth</code>  即為最大深度。</li>
</ol>
</li>
<li>在簡單易實現的情況下，遞迴寫法最為直觀。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>需要訪問每個節點一次，n 為節點總數。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (h)（遞迴棧空間）</p>
<ul>
<li>h 為樹的高度；最壞情況（樹退化成鏈）時 h = n，空間複雜度為 O (n)；若樹較平衡，h = O (log n)。</li>
</ul>
</li>
</ul>
<h3 id="contains-duplicate"><a class="markdownIt-Anchor" href="#contains-duplicate">#</a> Contains Duplicate</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">題目連結</span><br>
<strong>標籤</strong>: Array, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 10 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列  <code>nums</code> ，判斷是否存在至少一個值在陣列中出現兩次。如果任意值出現至少兩次，回傳  <code>true</code> ；如果所有元素皆只出現一次，回傳  <code>false</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: nums = [1,2,3,1]<br>
Output: true</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: nums = [1,2,3,4]<br>
Output: false</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: nums = [1,1,1,3,3,4,3,2,4,2]<br>
Output: true</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>方法一（使用哈希集合）：
<ol>
<li>建立一個空的  <code>unordered_set&lt;int&gt; seen</code> 。</li>
<li>遍歷陣列  <code>nums</code>  的每個元素  <code>x</code> ：
<ul>
<li>如果  <code>x</code>  已存在於  <code>seen</code>  中，表示該值重複，立即回傳  <code>true</code> 。</li>
<li>否則將  <code>x</code>  插入  <code>seen</code>  中。</li>
</ul>
</li>
<li>如果遍歷結束都沒有發現重複元素，則回傳  <code>false</code> 。</li>
</ol>
</li>
<li>方法二（排序）：
<ol>
<li>將  <code>nums</code>  進行排序，時間複雜度為 O (n log n)。</li>
<li>遍歷排序後的陣列，檢查任意相鄰元素是否相等，如果相等，則回傳  <code>true</code> 。</li>
<li>若遍歷完整沒有相等的相鄰元素，回傳  <code>false</code> 。</li>
</ol>
</li>
<li>由於限制 n 可達 10^5，方法一時間複雜度 O (n)、空間複雜度 O (n)；方法二時間為 O (n log n)、空間為 O (1)（排序視為額外空間由語言實現決定）。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>時間複雜度：O (n)
<ul>
<li>遍歷陣列一次，對每個元素進行哈希集合查找和插入，平均均攤時間為 O (1)。</li>
</ul>
</li>
<li>空間複雜度：O (n)
<ul>
<li>最壞情況下，所有元素都被插入集合，共需額外 O (n) 空間。</li>
</ul>
</li>
</ul>
<h3 id="maximum-subarray"><a class="markdownIt-Anchor" href="#maximum-subarray">#</a> Maximum Subarray</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">題目連結</span><br>
<strong>標籤</strong>: Array, Dynamic Programming, Divide and Conquer<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列  <code>nums</code> ，請計算具有最大和的連續子陣列，並返回其最大和。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code> <br>
Output:  <code>6</code> <br>
Explanation: 最大子陣列為  <code>[4,-1,2,1]</code> ，其和為 6。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>nums = [1]</code> <br>
Output:  <code>1</code></p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>nums = [5,4,-1,7,8]</code> <br>
Output:  <code>23</code></p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>常見解法是 <strong>Kadane’s Algorithm</strong>，時間複雜度 O (n)，只需一次線性掃描。</li>
<li>使用兩個變數： <code>currentSum</code>  表示以當前位置結尾且和最大的子陣列和， <code>maxSum</code>  表示迄今為止見過的最大子陣列和。</li>
<li>初始化：
<ul>
<li><code>currentSum = nums[0]</code></li>
<li><code>maxSum = nums[0]</code></li>
</ul>
</li>
<li>從索引 1 開始，對每個元素  <code>num = nums[i]</code> ：
<ol>
<li>如果在  <code>currentSum + num</code>  與  <code>num</code>  之間， <code>num</code>  本身比較大，表示重新從當前元素開始累積，因此  <code>currentSum = max(num, currentSum + num)</code> 。</li>
<li>更新  <code>maxSum = max(maxSum, currentSum)</code> 。</li>
</ol>
</li>
<li>掃描結束後， <code>maxSum</code>  即為答案。</li>
<li>此方法的核心在於：若前面累積的和是負數，加上後續的元素只會讓總和更小，因此在遇到負累積時就重置為當前元素。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            currentSum = <span class="built_in">max</span>(nums[i], currentSum + nums[i]);</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需一次遍歷長度為 n 的陣列，每次計算和更新均為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>僅使用固定數量的輔助變數，不依賴輸入規模。</li>
</ul>
</li>
</ul>
<h2 id="week-3-88"><a class="markdownIt-Anchor" href="#week-3-88">#</a> Week 3 (8/8)</h2>
<h3 id="insert-interval"><a class="markdownIt-Anchor" href="#insert-interval">#</a> Insert Interval</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">題目連結</span><br>
<strong>標籤</strong>: Array, Sorting<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由不重疊且依照起點排序的區間列表  <code>intervals</code> ，以及一個新的區間  <code>newInterval</code> ，請在列表中插入  <code>newInterval</code> ，並確保最終結果中的區間仍然是不重疊且已排序。如果插入後有任何區間重疊，請將它們合併為一個區間。</p>
<p>每個區間由  <code>[start, end]</code>  表示，且  <code>start &lt;= end</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]<br>
Output: [[1,5],[6,9]]<br>
 Explanation: 插入 [2,5] 後，與 [1,3] 重疊，合併為 [1,5]。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,9]<br>
Output: [[1,2],[3,10],[12,16]]<br>
Explanation:<br>
 插入 [4,9] 後，會與 [3,5],[6,7],[8,10] 三個區間重疊，合併為 [3,10]。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 10^5</code></li>
<li><code>intervals</code>  依照  <code>intervals[i][0]</code> （起點）嚴格遞增排序，且彼此不重疊。</li>
<li><code>newInterval.length == 2</code></li>
<li><code>0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>
<p>因為原本的  <code>intervals</code>  已經依起點排序，且彼此不重疊，我們只需將  <code>newInterval</code>  插入適當位置，並與相鄰的重疊區間做合併。整體流程可分為三個階段：</p>
<ol>
<li>
<p><strong>將所有在  <code>newInterval</code>  之前且不會重疊的區間先加入結果</strong></p>
<ul>
<li>換言之，遍歷原列表，對於每個區間  <code>intervals[i]</code> ，如果其結束時間  <code>intervals[i][1] &lt; newInterval[0]</code> （比  <code>newInterval</code>  的起點還要早結束），則代表這些區間完全在  <code>newInterval</code>  之前且不重疊，直接推入結果  <code>result</code> 。</li>
</ul>
</li>
<li>
<p><strong>處理與  <code>newInterval</code>  可能重疊的區間，進行合併</strong></p>
<ul>
<li>當遇到某個區間  <code>intervals[i]</code>  的起點  <code>intervals[i][0] &lt;= newInterval[1]</code>  時，代表它與  <code>newInterval</code>  有重疊，需更新：
<ul>
<li><code>newInterval[0] = min(newInterval[0], intervals[i][0])</code></li>
<li><code>newInterval[1] = max(newInterval[1], intervals[i][1])</code></li>
</ul>
</li>
<li>此時不立即將  <code>intervals[i]</code>  推入  <code>result</code> ，而是持續向後合併所有重疊區間。只要  <code>intervals[i][0] &lt;= newInterval[1]</code> ，就持續更新  <code>newInterval</code> 。</li>
</ul>
</li>
<li>
<p><strong>將合併完成的  <code>newInterval</code>  推入結果</strong></p>
<ul>
<li>當遇到第一個不與  <code>newInterval</code>  重疊的區間時（或原列表已遍歷完），將合併後的  <code>newInterval</code>  推入  <code>result</code> ，並切換到下一個階段。</li>
</ul>
</li>
<li>
<p><strong>將所有在  <code>newInterval</code>  之後且不會重疊的區間加入結果</strong></p>
<ul>
<li>從目前位置繼續遍歷，每個區間的起點都比  <code>newInterval[1]</code>  大，直接推入  <code>result</code>  即可。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>以上步驟保證最終的  <code>result</code>  依然是按照起點排序，且所有重疊區間已經被合併。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 處理所有在 newInterval 之前且不重疊的區間</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 處理與 newInterval 重疊的區間，合併到 newInterval 中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = <span class="built_in">min</span>(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = <span class="built_in">max</span>(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合併完成後，把 newInterval 加入結果</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 處理所有在 newInterval 之後且不重疊的區間</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>我們僅對 intervals 列表做一次線性掃描，n 為原列表長度。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>除了用於輸出結果的 result，僅使用常數級別的額外變數（i, n 及更新 newInterval 的空間），因此額外空間為 O (1)。最終輸出空間則為 O (n + 1)，可視為 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="01-matrix"><a class="markdownIt-Anchor" href="#01-matrix">#</a> 01 Matrix</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvMDEtbWF0cml4Lw==">題目連結</span><br>
<strong>標籤</strong>: Breadth-First Search, Dynamic Programming, Queue, Matrix<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由 0 和 1 組成的 m x n 二維矩陣  <code>mat</code> ，請返回一個同樣大小的矩陣  <code>res</code> ，其中  <code>res[i][j]</code>  是原矩陣中位置  <code>(i, j)</code>  到最近的 0 的距離。距離由上下左右四個方向的一步算作 1。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:<br>
mat = [<br>
[0,0,0],<br>
[0,1,0],<br>
[0,0,0]<br>
]</p>
</blockquote>
<blockquote>
<p>Output:<br>
[<br>
[0,0,0],<br>
[0,1,0],<br>
[0,0,0]<br>
]</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:<br>
mat = [<br>
[0,0,0],<br>
[0,1,0],<br>
[1,1,1]<br>
]</p>
</blockquote>
<blockquote>
<p>Output:<br>
[<br>
[0,0,0],<br>
[0,1,0],<br>
[1,2,1]<br>
]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == mat.length</code></li>
<li><code>n == mat[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10^4</code></li>
<li><code>1 &lt;= m * n &lt;= 10^5</code></li>
<li><code>mat[i][j]</code>  為  <code>0</code>  或  <code>1</code></li>
<li>保證至少有一個  <code>0</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>由於每個格子的值要計算到最近的 0 的最短步數，若對每個 1 單獨做 BFS，複雜度將高達 O ((mn)・(mn))，在大矩陣中無法接受。</p>
<p>我們可以反向思考，將所有值為 0 的位置作為 BFS 的多源起點，同時從每個 0 開始向外擴散，逐步標記各 1 到「其最近 0」的距離。</p>
<p>演算法步驟如下：</p>
<ol>
<li><strong>初始化距離矩陣  <code>dist</code> </strong>
<ul>
<li>建立與  <code>mat</code>  同維度的距離矩陣  <code>dist</code> ，初始化為一個很大的整數（如  <code>INT_MAX</code>  或  <code>m+n</code> ）。</li>
</ul>
</li>
<li><strong>多源 BFS</strong>
<ul>
<li>建立一個佇列  <code>queue&lt;pair&lt;int,int&gt;&gt; q</code> 。</li>
<li>遍歷  <code>mat</code>  中所有格子，若  <code>mat[i][j] == 0</code> ，則將  <code>(i, j)</code>  推入佇列  <code>q</code> ，並將  <code>dist[i][j] = 0</code> 。</li>
<li>四個方向的偏移陣列  <code>dirs = &#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125;</code>  用於遍歷相鄰格子。</li>
</ul>
</li>
<li><strong>執行 BFS 擴散</strong>
<ul>
<li>當  <code>q</code>  不為空時，不斷取出當前格  <code>(r, c)</code> ：
<ol>
<li>對於四個方向  <code>d</code> ，計算鄰格  <code>(nr, nc) = (r + d.first, c + d.second)</code> 。</li>
<li>檢查  <code>(nr, nc)</code>  是否在矩陣內，且若  <code>dist[nr][nc] &gt; dist[r][c] + 1</code> ，代表從當前 0 或已知較近 0 過來能取得更短距離：
<ul>
<li>更新  <code>dist[nr][nc] = dist[r][c] + 1</code> ，</li>
<li>並將  <code>(nr, nc)</code>  推入佇列  <code>q</code> 。</li>
</ul>
</li>
</ol>
</li>
<li>由於所有 0 先入隊，第一輪拓展時距離將被標記為 1，再下一輪擴散將標記距離 2，以此類推。最終  <code>dist[i][j]</code>  即為該格到最近 0 的距離。</li>
</ul>
</li>
</ol>
<p>這種方法相當於從所有 0「同時」開始做 BFS，保證第一次到達某個 1 的距離即為最短距離。整體時間複雜度為 O (mn)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化 dist 矩陣，預設為一個足夠大的值</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INF = m + n; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INF));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 將所有 0 的位置入隊，並將 dist 設為 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四個方向偏移：下、上、右、左</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 多源 BFS，從所有 0 同時擴散</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> nr = r + d.first;</span><br><span class="line">                <span class="type">int</span> nc = c + d.second;</span><br><span class="line">                <span class="comment">// 若鄰格在範圍內，且可用更短距離更新</span></span><br><span class="line">                <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[nr][nc] &gt; dist[r][c] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[nr][nc] = dist[r][c] + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(nr, nc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (mn)</p>
<ul>
<li>每個格子最多被加入佇列一次，且從佇列中彈出後最多檢查 4 個鄰格，總共為 O (mn)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (mn)</p>
<ul>
<li>使用一個與輸入矩陣等大的距離矩陣 dist，以及最壞情況下可達 O (mn) 大小的佇列。</li>
</ul>
</li>
</ul>
<h3 id="k-closest-points-to-origin"><a class="markdownIt-Anchor" href="#k-closest-points-to-origin">#</a> K Closest Points to Origin</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvay1jbG9zZXN0LXBvaW50cy10by1vcmlnaW4v">題目連結</span><br>
<strong>標籤</strong>: Array, Math, Divide and Conquer, Sorting, Heap (Priority Queue)<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個「點」的列表  <code>points</code> ，其中  <code>points[i] = [xi, yi]</code>  表示第 i 個點在 2D 平面上的座標。請返回距離原點 (0,0) 最近的 k 個點。</p>
<p>所有點到原點的距離由歐幾里得距離計算： <code>sqrt(xi^2 + yi^2)</code> 。你可以按任何順序返回答案。答案傳回的 k 個點必須精確為「距離最小的 k 個」，不需要排序。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: points = [[1,3],[-2,2]], k = 1<br>
Output: [[-2,2]]<br>
Explanation:<br>
 點 (-2,2) 到原點距離為 sqrt (4+4) = sqrt (8) ≈ 2.828；<br>
而點 (1,3) 到原點距離為 sqrt (1+9) = sqrt (10) ≈ 3.162。<br>
因此最近的 1 個點為 [-2,2]。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: points = [[3,3],[5,-1],[-2,4]], k = 2<br>
Output: [[3,3],[-2,4]]<br>
Explanation:<br>
 距離分別為：<br>
(3,3) → sqrt(9+9)=sqrt(18) ≈ 4.243<br>
(5,-1) → sqrt(25+1)=sqrt(26) ≈ 5.099<br>
(-2,4) → sqrt(4+16)=sqrt(20) ≈ 4.472<br>
 最近的兩個點為 (3,3) 與 (-2,4)，順序可以互換。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= k &lt;= points.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= xi, yi &lt;= 10^4</code></li>
<li>答案保證是唯一的（除了順序）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題要求返回距離原點最近的 k 個點，可使用以下常見方法：</p>
<ol>
<li>
<p><strong>Max-Heap (Priority Queue) 維護大小為 k 的集合</strong></p>
<ul>
<li>我們可以維護一個「最大堆」，堆中保存當前距離最小的 k 個點，並以距離作為比較依據。</li>
<li>遍歷所有  <code>points</code> ：
<ol>
<li>對第 i 個點  <code>(x, y)</code> ，計算其「距離平方」 <code>d = x*x + y*y</code> （不需開根號，比較平方即可）。</li>
<li>如果堆的大小小於 k，就直接將  <code>(d, i)</code>  推入最大堆；</li>
<li>否則，比較當前點距離  <code>d</code>  與堆頂元素的距離（即目前 k 個最遠點的距離），若  <code>d</code>  比堆頂小，代表這個點更接近原點，應該將堆頂彈出、並把  <code>(d, i)</code>  推入，否則跳過。</li>
</ol>
</li>
<li>最終，堆中就保留了 k 個「距離最小」的點；取出它們的索引即可。</li>
<li><strong>時間複雜度</strong>：O (n log k)，其中 n 為點的數量；每次對堆操作為 log k，總共 n 次插入／比較。</li>
<li><strong>空間複雜度</strong>：O (k)，最大堆中最多保存 k 個點。</li>
</ul>
</li>
<li>
<p><strong>快速選擇法 (Quickselect)</strong></p>
<ul>
<li>類似快速排序的「分區」操作，利用  <code>nth_element</code>  或手動實現 partition，一次可以將第 k 小 (距離) 的點放到正確位置，左側都是更小距離的點。</li>
<li><code>nth_element(points.begin(), points.begin()+k, points.end(), cmp)</code>  之後，前 k 個元素即為距離最小的 k 個點，但不保證排序。</li>
<li><strong>時間複雜度</strong>：平均 O (n)，最壞 O (n^2)（但使用標準庫的  <code>nth_element</code>  大多能保證線性平均）。</li>
<li><strong>空間複雜度</strong>：O (1)（就地在原陣列操作）。</li>
</ul>
</li>
</ol>
<p>此處我們以 <strong>最大堆</strong> 方法示範，因為邏輯清晰易理解。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定義一個「最大堆」，元素對以 pair&lt;distanceSquared, index&gt;</span></span><br><span class="line">        <span class="comment">// distanceSquared 用作比較（距離平方越大排越前面）</span></span><br><span class="line">        <span class="keyword">using</span> PII = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> PII&amp; a, <span class="type">const</span> PII&amp; b) &#123;</span><br><span class="line">            <span class="comment">// 距離平方大的排在堆頂（最大堆）</span></span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;PII, vector&lt;PII&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">maxHeap</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍歷所有點，維護一個大小最多為 k 的最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> distSq = x * x + y * y;  <span class="comment">// 距離平方</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)maxHeap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                <span class="comment">// 先把前 k 個點放入堆</span></span><br><span class="line">                maxHeap.<span class="built_in">emplace</span>(distSq, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distSq &lt; maxHeap.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                <span class="comment">// 若當前點更接近原點，彈出堆頂後推入</span></span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">                maxHeap.<span class="built_in">emplace</span>(distSq, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否則，當前點距離比堆中最遠的 k 個點還大，跳過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 現在堆中有 k 個「距離最小」的點，把它們取出</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> idx = maxHeap.<span class="built_in">top</span>().second;</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(points[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回順序可不固定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n log k)</p>
<ul>
<li>n = points.size ()，每次插入／彈出堆的操作為 O (log k)，共進行 n 次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (k)</p>
<ul>
<li>最大堆中最多保存 k 個元素，此外只使用常數級輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="longest-substring-without-repeating-characters"><a class="markdownIt-Anchor" href="#longest-substring-without-repeating-characters">#</a> Longest Substring Without Repeating Characters</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">題目連結</span><br>
<strong>標籤</strong>: Hash Table, Two Pointers, String, Sliding Window<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個字串  <code>s</code> ，請找出不含重複字符的最長子字串的長度。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>s = &quot;abcabcbb&quot;</code> <br>
Output:  <code>3</code> <br>
Explanation: 最長不含重複字符的子字串是  <code>&quot;abc&quot;</code> ，長度為 3。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>s = &quot;bbbbb&quot;</code> <br>
Output:  <code>1</code> <br>
Explanation: 最長不含重複字符的子字串是  <code>&quot;b&quot;</code> ，長度為 1。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>s = &quot;pwwkew&quot;</code> <br>
Output:  <code>3</code> <br>
Explanation: 最長不含重複字符的子字串是  <code>&quot;wke&quot;</code> （注意是子字串，必須是連續的），長度為 3。<br>
請注意，你的答案必須是子字串的長度， <code>&quot;pwke&quot;</code>  不是連續的子字串。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code></li>
<li><code>s</code>  由英文字母、數字、符號和空格組成。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以利用「滑動視窗」（Sliding Window）＋「哈希表（字元映射）」技巧，在 O (n) 時間內找出最長不含重複字符的子字串長度。</p>
<ol>
<li>
<p><strong>定義左右指標</strong></p>
<ul>
<li>使用兩個指標  <code>left</code> 、 <code>right</code>  表示視窗範圍，初始都指向 0。視窗代表目前考慮的子字串  <code>s[left..right-1]</code> 。</li>
<li>我們會讓  <code>right</code>  向右逐步擴展，同時保證視窗內沒有重複字符；只要發現重複，就移動  <code>left</code>  直到視窗內不含該重複字元為止。</li>
</ul>
</li>
<li>
<p><strong>哈希表記錄最近出現位置</strong></p>
<ul>
<li>建立一個大小至少為 128（覆蓋 ASCII 範圍）的整數陣列  <code>lastIndex[128]</code> ，初始值皆設為 -1。當我們遍歷到  <code>s[right]</code> ，若之前  <code>lastIndex[s[right]]</code>  ≠ -1，代表在  <code>s[right]</code>  字符上次出現的位置。</li>
<li>每次右指標  <code>right</code>  移動到新字元時，檢查該字元上次出現的位置  <code>prev = lastIndex[s[right]]</code> ：
<ol>
<li>如果  <code>prev &gt;= left</code> ，代表該字符之前在當前視窗範圍內出現過，因此必須將  <code>left</code>  更新到  <code>prev + 1</code> ，才能移除重複。</li>
<li>將  <code>lastIndex[s[right]] = right</code>  作為該字符的新紀錄。</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>更新答案</strong></p>
<ul>
<li>在每次擴展  <code>right</code>  之前或之後（都可，只要維持視窗內無重複即可），計算當前視窗長度  <code>right - left + 1</code> ，並與  <code>maxLen</code>  比較取最大值。</li>
</ul>
</li>
<li>
<p><strong>遍歷終止條件</strong></p>
<ul>
<li>讓  <code>right</code>  從 0 一路移動到  <code>n-1</code> ，整個過程 O (n)；更新  <code>left</code>  最多也 O (n) 次，因此總複雜度 O (n)。</li>
</ul>
</li>
</ol>
<p>下面以範例  <code>s = &quot;abba&quot;</code>  來示範：</p>
<ul>
<li>
<p>初始化： <code>left = 0, maxLen = 0, lastIndex 全部為 -1</code></p>
</li>
<li>
<p><code>right = 0</code> ， <code>s[0] = 'a'</code> ：</p>
<ul>
<li><code>prev = lastIndex['a'] = -1</code> ，不需移動  <code>left</code> 。</li>
<li>更新  <code>lastIndex['a'] = 0</code> 。</li>
<li>當前視窗長度  <code>0 - 0 + 1 = 1</code> ， <code>maxLen = 1</code> 。</li>
</ul>
</li>
<li>
<p><code>right = 1</code> ， <code>s[1] = 'b'</code> ：</p>
<ul>
<li><code>prev = lastIndex['b'] = -1</code> ，不需移動  <code>left</code> 。</li>
<li>更新  <code>lastIndex['b'] = 1</code> 。</li>
<li>當前視窗長度  <code>1 - 0 + 1 = 2</code> ， <code>maxLen = 2</code> 。</li>
</ul>
</li>
<li>
<p><code>right = 2</code> ， <code>s[2] = 'b'</code> ：</p>
<ul>
<li><code>prev = lastIndex['b'] = 1</code> ，此時  <code>1 &gt;= left(0)</code> ，表示重複出現在視窗內。</li>
<li>更新  <code>left = prev + 1 = 2</code> ，移除先前的  <code>'b'</code> 。</li>
<li>更新  <code>lastIndex['b'] = 2</code> 。</li>
<li>當前視窗長度  <code>2 - 2 + 1 = 1</code> ， <code>maxLen = max(2,1) = 2</code> 。</li>
</ul>
</li>
<li>
<p><code>right = 3</code> ， <code>s[3] = 'a'</code> ：</p>
<ul>
<li><code>prev = lastIndex['a'] = 0</code> ，因為  <code>0 &lt; left(2)</code> ，表示上次的  <code>'a'</code>  已不在當前視窗內，故不移動  <code>left</code> 。</li>
<li>更新  <code>lastIndex['a'] = 3</code> 。</li>
<li>當前視窗長度  <code>3 - 2 + 1 = 2</code> ， <code>maxLen = max(2,2) = 2</code> 。</li>
</ul>
</li>
</ul>
<p>最終  <code>maxLen = 2</code> ，對應的最長子字串例如  <code>&quot;ab&quot;</code>  或  <code>&quot;ba&quot;</code> 。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// lastIndex 用於記錄每個 ASCII 字元上次出現的位置，初始化為 -1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastIndex</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;  <span class="comment">// 滑動視窗左邊界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="type">int</span> prev = lastIndex[c];</span><br><span class="line">            <span class="comment">// 如果該字元上次出現在視窗內，則移動左邊界</span></span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= left) &#123;</span><br><span class="line">                left = prev + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新該字元最近出現的位置</span></span><br><span class="line">            lastIndex[c] = right;</span><br><span class="line">            <span class="comment">// 計算當前視窗長度並更新最大值</span></span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>right 指標從 0 到 n-1 各走一次；left 最多向右移動 n 次，整體加起來為線性時間。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>我們只使用固定大小為 128 的陣列儲存 ASCII 字元的最近位置，不隨字串長度 n 增長。</li>
</ul>
</li>
</ul>
<h3 id="3sum"><a class="markdownIt-Anchor" href="#3sum">#</a> 3Sum</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bS8=">題目連結</span><br>
<strong>標籤</strong>: Array, Two Pointers, Sorting<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列  <code>nums</code> ，請找出所有不重複且總和為 0 的三元組  <code>[nums[i], nums[j], nums[k]]</code> ，並將這些三元組以二維陣列形式回傳。</p>
<p>注意：答案中不能包含重複的三元組。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: nums = [-1,0,1,2,-1,-4]<br>
Output: [[-1,-1,2],[-1,0,1]]<br>
Explanation:<br>
 三元組 [-1,-1,2] 和 [-1,0,1] 的元素和均為 0，且不重複。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input: nums = [0, 1, 1]<br>
Output: []</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: nums = [0, 0, 0]<br>
Output: [[0, 0, 0]]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>
<p><strong>排序 (Sorting)</strong></p>
<ul>
<li>先將陣列  <code>nums</code>  依升冪排序，方便後續使用雙指針掃描並去重。</li>
</ul>
</li>
<li>
<p><strong>固定第一個數字，對剩餘部分做雙指針搜尋</strong></p>
<ul>
<li>令三元組的第一個元素索引為  <code>i</code> ，遍歷  <code>i</code>  從  <code>0</code>  到  <code>n-3</code> （因為至少要三個元素）。</li>
<li>為了避免重複，在遍歷  <code>i</code>  時，如果  <code>i &gt; 0</code>  且  <code>nums[i] == nums[i-1]</code> ，直接跳過。</li>
<li>接著在排序好的陣列中，對  <code>i</code>  之後的子陣列使用左右指標  <code>left = i+1</code> 、 <code>right = n-1</code> ，在  <code>left &lt; right</code>  的情況下：
<ol>
<li>計算三數總和  <code>sum = nums[i] + nums[left] + nums[right]</code> 。</li>
<li>如果  <code>sum == 0</code> ，則找到一組符合條件的三元組，將其加入結果，並同時移動  <code>left++</code> 、 <code>right--</code> ，但要跳過重複元素（ <code>while (left &lt; right &amp;&amp; nums[left] == nums[left-1]) left++;</code> 、 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right+1]) right--;</code> ），以避免重複三元組。</li>
<li>如果  <code>sum &lt; 0</code> ，代表總和太小，需要增大  <code>left</code>  對應的值，故  <code>left++</code> 。</li>
<li>如果  <code>sum &gt; 0</code> ，代表總和太大，需要減小  <code>right</code>  對應的值，故  <code>right--</code> 。</li>
</ol>
</li>
<li>重複上述雙指針搜尋流程直到  <code>left &gt;= right</code> 。</li>
</ul>
</li>
<li>
<p><strong>去重技巧</strong></p>
<ul>
<li>在固定  <code>i</code>  時：若  <code>i &gt; 0</code>  且  <code>nums[i] == nums[i-1]</code> ，直接跳過，避免第一個數字重複。</li>
<li>找到  <code>sum == 0</code>  後，移動  <code>left</code> 、 <code>right</code>  時，跳過相鄰且相同的值。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 遍歷 i 作為三元組的第一個元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 避免第一個元素重複</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 雙指針搜尋其餘兩個元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">long</span> sum = (<span class="type">long</span>)nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 找到一組符合條件的三元組</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 跳過重複的 left 元素</span></span><br><span class="line">                    <span class="type">int</span> leftVal = nums[left];</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == leftVal) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 跳過重複的 right 元素</span></span><br><span class="line">                    <span class="type">int</span> rightVal = nums[right];</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == rightVal) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 總和太小，left 往右移動</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// sum &gt; 0</span></span><br><span class="line">                    <span class="comment">// 總和太大，right 往左移動</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n²)</p>
<ul>
<li>排序 O (n log n)；主迴圈遍歷 i 為 O (n)，每次在子陣列執行雙指針搜尋為 O (n)，合計為 O (n²)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (log n)（排序所需）</p>
<ul>
<li>若忽略返回結果所佔空間，只使用排程排序遞迴空間為 O (log n)。若計算輸出占用，則最壞情況 O (n²)（取決於可形成幾組三元組）。</li>
</ul>
</li>
</ul>
<h3 id="binary-tree-level-order-traversal"><a class="markdownIt-Anchor" href="#binary-tree-level-order-traversal">#</a> Binary Tree Level Order Traversal</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">題目連結</span><br>
<strong>標籤</strong>: Tree, Breadth-First Search, Queue<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點  <code>root</code> ，請返回其「層序遍歷」（level order traversal）的節點值 —— 即從左到右，逐層訪問所有節點。輸出結果應為一個二維陣列，其中第  <code>i</code>  個子陣列包含樹的第  <code>i</code>  層所有節點的值。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input: root = [3,9,20,null,null,15,7]<br>
Output: [[3],[9,20],[15,7]]<br>
Explanation:<br>
 層序遍歷結果為 [[3], [9,20], [15,7]]。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   / \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
Input: root = [1]<br>
Output: [[1]]</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input: root = []<br>
Output: []</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點總數在範圍  <code>[0, 2000]</code> 。</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題最常用的做法是「廣度優先搜尋」（Breadth-First Search, BFS），利用佇列（queue）按層次逐層訪問。</li>
<li>具體流程：
<ol>
<li>如果  <code>root</code>  為  <code>nullptr</code> ，直接回傳空陣列  <code>[]</code> 。</li>
<li>建立一個佇列  <code>queue&lt;TreeNode*&gt; q</code> ，先將  <code>root</code>  推入。</li>
<li>當佇列不為空時，先記錄當前層的節點數  <code>levelSize = q.size()</code> ，這個值代表本次要從佇列中取出的節點數量（相當於本層的節點數）。</li>
<li>建立一個臨時容器  <code>vector&lt;int&gt; levelVals</code> ，用來儲存本層所有節點的值。</li>
<li>用一個迴圈跑  <code>levelSize</code>  次，每次從佇列中取出一個節點  <code>node = q.front()</code> 、 <code>q.pop()</code> ，並把  <code>node-&gt;val</code>  加入  <code>levelVals</code> 。若  <code>node-&gt;left</code>  非空，則  <code>q.push(node-&gt;left)</code> ；若  <code>node-&gt;right</code>  非空，則  <code>q.push(node-&gt;right)</code> 。</li>
<li>當  <code>levelSize</code>  次迴圈結束，代表本層所有節點都處理完，將  <code>levelVals</code>  推入結果二維陣列  <code>result</code> 。</li>
<li>重複步驟 3～6，直到佇列為空。</li>
</ol>
</li>
<li>這樣可以保證每次只將同一層的節點值收集一次，並依序推入結果。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;  <span class="comment">// 空樹返回空陣列</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();  <span class="comment">// 當前層的節點數</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; levelVals;</span><br><span class="line">            levelVals.<span class="built_in">reserve</span>(levelSize);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                levelVals.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.<span class="built_in">push_back</span>(levelVals);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>n 為樹中節點總數。每個節點會被加入佇列並彈出一次，並進行常數次操作（讀值、推入子節點），整體為 O (n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>佇列最壞情況下可能儲存一整層所有節點，例如接近 n/2 個（若樹為完全二元樹）。此外，結果的二維陣列也會儲存所有節點值，需 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="clone-graph"><a class="markdownIt-Anchor" href="#clone-graph">#</a> Clone Graph</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xvbmUtZ3JhcGgv">題目連結</span><br>
<strong>標籤</strong>: Hash Table, Depth-First Search, Breadth-First Search, Graph<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個無向連通圖的節點  <code>node</code> ，請返回此圖的深拷貝（Clone）。</p>
<p>圖中每個節點包含一個整數  <code>val</code> （節點編號），以及一個鄰居列表  <code>vector&lt;Node*&gt; neighbors</code> ，代表與該節點相連的所有節點。節點編號範圍為 1 到 N（N ≤ 100）。</p>
<p>需構造一個與原圖結構、節點值完全相同的新圖，且新舊圖之間的節點指標互不相同。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
adjList = [[2,4],[1,3],[2,4],[1,3]]<br>
 返回：[[2,4],[1,3],[2,4],[1,3]]<br>
 圖結構：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 -- 2</span><br><span class="line">|    |</span><br><span class="line">4 -- 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Example 2:<br>
adjList = [[]]<br>
 圖只有一個節點，且沒有鄰居，返回：[[]]</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
adjList = []<br>
 空圖，返回：nullptr</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<p>節點數量不超過 100。<br>
節點值 val 範圍為 1 &lt;= val &lt;= 100，且圖為無向連通圖。<br>
同一節點的鄰居列表中不含重複節點。<br>
圖中無自環或重邊。</p>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>複製一個圖的常見方法是透過 深度優先搜尋（DFS） 或 廣度優先搜尋（BFS），並使用一個 哈希映射 來保存「原節點指標 → 新節點指標」的映射，避免重複複製同一個節點。<br>
　下面以 DFS 方式示範：</p>
<ol>
<li><strong>建立映射表</strong></li>
</ol>
<ul>
<li>使用 unordered_map&lt;Node*, Node*&gt; visited;
<ul>
<li>Key：原圖的節點指標</li>
<li>Value：對應已創建的複製節點指標</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>遞迴 DFS 函式  <code>clone(Node* node)</code> </strong></li>
</ol>
<ul>
<li>如果  <code>node == nullptr</code> ，直接返回  <code>nullptr</code> 。</li>
<li>如果  <code>visited.count(node)</code>  已包含此  <code>node</code> ，代表該節點已被複製過，直接返回  <code>visited[node]</code> 。</li>
<li>否則：
<ul>
<li>創建一個新節點 Node* copy = new Node (node-&gt;val);，先只複製節點值，不處理鄰居列表。</li>
<li>在 visited [node] = copy; 中記錄這個映射關係，避免後續重複複製。</li>
<li>遍歷 node-&gt;neighbors 中的每個鄰居 nei：呼叫 clone (nei)，並將返回的新節點指標加入 copy-&gt;neighbors。</li>
<li>返回 copy。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>主函式  <code>cloneGraph(Node* node)</code></li>
</ol>
<ul>
<li>如果輸入 node == nullptr，直接返回 nullptr。</li>
<li>否則呼叫並返回 clone (node)，即可獲得整個圖的克隆。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; neighbors;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">neighbors</span>(<span class="built_in">vector</span>&lt;Node*&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">neighbors</span>(<span class="built_in">vector</span>&lt;Node*&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val, vector&lt;Node*&gt; _neighbors) : <span class="built_in">val</span>(_val), <span class="built_in">neighbors</span>(_neighbors) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">clone</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">clone</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        &#125;</span><br><span class="line">        Node* copy = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = copy;</span><br><span class="line">        <span class="keyword">for</span> (Node* nei : node-&gt;neighbors) &#123;</span><br><span class="line">            copy-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">clone</span>(nei));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (N + M)</p>
<ul>
<li>N 為節點數量，M 為邊的數量。每個節點只會被 clone 訪問一次，並處理它所有的鄰邊。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (N)</p>
<ul>
<li>使用 visited 哈希映射存儲 N 個節點，遞迴棧最壞情況也為 O (N)。</li>
</ul>
</li>
</ul>
<h3 id="evaluate-reverse-polish-notation"><a class="markdownIt-Anchor" href="#evaluate-reverse-polish-notation">#</a> Evaluate Reverse Polish Notation</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZXZhbHVhdGUtcmV2ZXJzZS1wb2xpc2gtbm90YXRpb24v">題目連結</span><br>
<strong>標籤</strong>: Stack, Array<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.</p>
<p>有效的運算符為  <code>+</code> ,  <code>-</code> ,  <code>*</code> ,  <code>/</code> 。每個運算符都應該作用於最近的兩個操作數之上。除法運算符  <code>/</code>  表示整數除法，結果會向零取整。</p>
<p>你可以假設給定的 RPN 表達式總是有效的，也就是說運算過程中不會出現除以零的情況，並且最終得到的結果只會有一個值。</p>
<p>舉例來說，給定 RPN 表達式索引為  <code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code> ，其對應的計算步驟為：</p>
<ol>
<li>遇到  <code>&quot;2&quot;</code>  與  <code>&quot;1&quot;</code> ，先把兩個數字當作操作數推入堆疊。</li>
<li>遇到  <code>&quot;+&quot;</code> ，從堆疊彈出  <code>1</code>  和  <code>2</code> ，計算  <code>2 + 1 = 3</code> ，再把結果  <code>3</code>  推回堆疊。</li>
<li>接著讀到  <code>&quot;3&quot;</code> ，把  <code>3</code>  推入堆疊。</li>
<li>最後讀到  <code>&quot;*&quot;</code> ，從堆疊彈出剛剛的  <code>3</code> （結果）和新推入的  <code>3</code> ，計算  <code>3 * 3 = 9</code> ，再把結果  <code>9</code>  推回。</li>
<li>到達結尾，堆疊中只剩下一個值  <code>9</code> ，即為最終答案。</li>
</ol>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code> <br>
Output:  <code>9</code> <br>
Explanation:  <code>((2 + 1) * 3) = 9</code></p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</code> <br>
Output:  <code>6</code> <br>
Explanation:  <code>(4 + (13 / 5)) = 6</code></p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</code> <br>
Output:  <code>22</code> <br>
Explanation:</p>
<ol>
<li>當前堆疊狀態： <code>[10, 6, 9, 3]</code></li>
<li>遇到  <code>&quot;+&quot;</code> ：彈出  <code>3, 9</code>  →  <code>9 + 3 = 12</code>  → 推入  <code>12</code>  →  <code>[10, 6, 12]</code></li>
<li>遇到  <code>&quot;-11&quot;</code> ：推入  <code>-11</code>  →  <code>[10, 6, 12, -11]</code></li>
<li>遇到  <code>&quot;*&quot;</code> ：彈出  <code>-11, 12</code>  →  <code>12 * -11 = -132</code>  → 推入  <code>-132</code>  →  <code>[10, 6, -132]</code></li>
<li>遇到  <code>&quot;/&quot;</code> ：彈出  <code>-132, 6</code>  →  <code>6 / -132 = 0</code> （整數除法向零取整）→ 推入  <code>0</code>  →  <code>[10, 0]</code></li>
<li>遇到  <code>&quot;*&quot;</code> ：彈出  <code>0, 10</code>  →  <code>10 * 0 = 0</code>  → 推入  <code>0</code>  →  <code>[0]</code></li>
<li>遇到  <code>&quot;17&quot;</code> ：推入  <code>17</code>  →  <code>[0, 17]</code></li>
<li>遇到  <code>&quot;+&quot;</code> ：彈出  <code>17, 0</code>  →  <code>0 + 17 = 17</code>  → 推入  <code>17</code>  →  <code>[17]</code></li>
<li>遇到  <code>&quot;5&quot;</code> ：推入  <code>5</code>  →  <code>[17, 5]</code></li>
<li>遇到  <code>&quot;+&quot;</code> ：彈出  <code>5, 17</code>  →  <code>17 + 5 = 22</code>  → 推入  <code>22</code>  →  <code>[22]</code></li>
<li>最終答案  <code>22</code> 。</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 10^4</code></li>
<li>每個  <code>tokens[i]</code>  要麼是一個整數（可能帶負號），要麼是運算符  <code>&quot;+&quot;</code> ,  <code>&quot;-&quot;</code> ,  <code>&quot;*&quot;</code> ,  <code>&quot;/&quot;</code></li>
<li>在 RPN 運算過程中，不會出現除以零的情況</li>
<li>最終結果一定是一個整數，且範圍在 32 位元整數之內</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用棧（Stack）來模擬 RPN 計算：
<ol>
<li>遍歷  <code>tokens</code>  陣列，若當前元素是數字字串，就將其轉換成  <code>int</code>  後推入棧中。</li>
<li>若當前元素是運算符（ <code>&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;</code> ），則從棧中先後彈出兩個操作數（右操作數先彈出，左操作數後彈出）。</li>
<li>根據運算符對這兩個操作數執行相應運算，並把計算結果再推回棧中。</li>
<li>反覆上述步驟，直到遍歷結束，棧中只剩一個元素，即為最終答案。</li>
</ol>
</li>
<li>注意：除法運算時要做整數除法，向零取整。C++ 中使用  <code>/</code>  即可滿足該條件。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>   <span class="comment">// for std::stoi</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tok : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tok == <span class="string">&quot;+&quot;</span> || tok == <span class="string">&quot;-&quot;</span> || tok == <span class="string">&quot;*&quot;</span> || tok == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 先彈出右操作數，再彈出左操作數</span></span><br><span class="line">                <span class="type">int</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (tok == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                    res = a + b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                    res = a - b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                    res = a * b;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// tok == &quot;/&quot;</span></span><br><span class="line">                    <span class="comment">// C++ / 即為向零取整</span></span><br><span class="line">                    res = a / b;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                st.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 整數字串，轉成 int 並推入棧中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tok));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最終棧中只剩一個結果</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>需要對 tokens 進行一次線性遍歷。對於每個元素，要麼做一次 push（O (1)），要麼做一次 pop、運算、再 push（都為 O (1) 操作）。因此整體為 O (n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>最壞情況下（所有元素都是數字），棧中最多會存 n 個數字，所以需要 O (n) 的額外空間。</li>
</ul>
</li>
</ul>
<h2 id="week-4-88"><a class="markdownIt-Anchor" href="#week-4-88">#</a> Week 4 (8/8)</h2>
<h3 id="course-schedule"><a class="markdownIt-Anchor" href="#course-schedule">#</a> Course Schedule</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY291cnNlLXNjaGVkdWxlLw==">題目連結</span><br>
<strong>標籤</strong>: Graph, Topological Sort, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>你需要修  <code>numCourses</code>  門課程，編號從  <code>0</code>  到  <code>numCourses - 1</code> 。有一個列表  <code>prerequisites</code> ，其中的每一對  <code>[a, b]</code>  表示要修課程  <code>a</code>  必須先修過課程  <code>b</code> 。</p>
<p>請判斷是否存在一種選課順序，使你能修完所有課程。如果可以，返回  <code>true</code> ；否則，返回  <code>false</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>numCourses = 2, prerequisites = [[1,0]]</code> <br>
Output:  <code>true</code> <br>
Explanation: 學生先修課程  <code>0</code> ，接著修課程  <code>1</code> 。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>numCourses = 2, prerequisites = [[1,0],[0,1]]</code> <br>
Output:  <code>false</code> <br>
Explanation: 存在循環依賴，無法完成所有課程。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= numCourses &lt;= 10^5</code></li>
<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>
<li><code>prerequisites[i].length == 2</code></li>
<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>
<li>所有  <code>prerequisites[i]</code>  互不相同</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題實質是在判斷有向圖中是否存在拓撲排序（即是否能夠將有向圖排成無環序列）。如果圖中沒有環，則存在拓撲排序，代表可以依照該順序修完所有課程。</p>
<p>常見的做法有兩種：</p>
<ol>
<li>
<p><strong>入度 (Kahn’s Algorithm) + BFS</strong></p>
<ul>
<li>構建鄰接表與入度數組：對於每個先修關係  <code>[a, b]</code> ，在鄰接表中記錄邊  <code>b → a</code> ，並將  <code>a</code>  的入度  <code>in[a]++</code> 。</li>
<li>將所有入度為  <code>0</code>  的節點（即沒有先修課的課程）都加入隊列。</li>
<li>不斷從隊列中彈出節點  <code>u</code> ，將  <code>u</code>  的鄰接節點  <code>v</code>  的入度減  <code>1</code> ，若此時  <code>in[v]</code>  變為  <code>0</code> ，則將  <code>v</code>  推入隊列。</li>
<li>同時計算已處理的節點個數  <code>count</code> 。遍歷完隊列後，如果  <code>count == numCourses</code> ，表示所有課程都能被加入拓撲序列，返回  <code>true</code> ；否則存在環，返回  <code>false</code> 。</li>
</ul>
</li>
<li>
<p><strong>DFS 判斷有向圖是否存在環</strong></p>
<ul>
<li>使用深度優先搜尋 (DFS)，同時維護一個狀態數組  <code>state[i]</code> ， <code>0</code>  表示未訪問， <code>1</code>  表示訪問中（在遞歸棧上）， <code>2</code>  表示已完成訪問。</li>
<li>對於每個尚未訪問的節點  <code>u</code>  執行 DFS：
<ol>
<li>將  <code>state[u] = 1</code> ，遍歷所有鄰接節點  <code>v</code> ，若  <code>state[v] == 0</code> ，則遞歸 DFS (v)；若  <code>state[v] == 1</code> ，表示發現環，直接返回  <code>true</code> 。</li>
<li>完成對  <code>u</code>  的所有鄰接節點訪問後，將  <code>state[u] = 2</code> 。</li>
</ol>
</li>
<li>若整個過程中都沒有發現「回到訪問中節點」的情況，則圖中無環，返回  <code>true</code> 。否則，返回  <code>false</code> 。</li>
</ul>
</li>
</ol>
<p>下面以 <strong>Kahn’s Algorithm (BFS)</strong> 方法實現。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 建立鄰接表與入度數組</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            <span class="type">int</span> course = pre[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> prereq = pre[<span class="number">1</span>];</span><br><span class="line">            adj[prereq].<span class="built_in">push_back</span>(course);</span><br><span class="line">            inDegree[course]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 將所有入度為 0 的節點加入佇列</span></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. BFS 拓撲排序</span></span><br><span class="line">        <span class="type">int</span> visitedCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visitedCount++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 將 u 的所有鄰接節點入度減 1，若變為 0，則加入佇列</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">                inDegree[v]--;</span><br><span class="line">                <span class="keyword">if</span> (inDegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 如果處理過的節點數等於 numCourses，表示所有課程都能完成</span></span><br><span class="line">        <span class="keyword">return</span> visitedCount == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (N + E)</p>
<ul>
<li>
<p>N 為課程數（numCourses），E 為先修關係數（prerequisites.size ()）。</p>
</li>
<li>
<p>建立圖與計算入度需要 O (E)；BFS 遍歷所有節點和邊也需要 O (N + E)。</p>
</li>
</ul>
</li>
<li>
<p>空間複雜度：O (N + E)</p>
<ul>
<li>需要存儲鄰接表（共 E 條邊）和入度數組（大小為 N），以及 BFS 佇列在最壞情況下可裝 N 個節點。</li>
</ul>
</li>
</ul>
<h3 id="implement-trie-prefix-tree"><a class="markdownIt-Anchor" href="#implement-trie-prefix-tree">#</a> Implement Trie (Prefix Tree)</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXRyaWUtcHJlZml4LXRyZWUv">題目連結</span><br>
<strong>標籤</strong>: Design, Trie<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作一個 Trie（又稱 Prefix Tree），包含以下操作：</p>
<ol>
<li><code>Trie()</code> ：初始化 Trie 物件。</li>
<li><code>void insert(String word)</code> ：將字串  <code>word</code>  插入 Trie。</li>
<li><code>boolean search(String word)</code> ：如果字串  <code>word</code>  存在於 Trie 中（作為完整的字串），則返回  <code>true</code> ；否則返回  <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> ：如果 Trie 中存在以字串  <code>prefix</code>  為開頭的任何單詞，則返回  <code>true</code> ；否則返回  <code>false</code> 。</li>
</ol>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要你從標準輸入讀取任何資料，也不需要你輸出格式化結果到標準輸出，僅需實作上述四個函式接口。</p>
<p>下面給出一個模擬呼叫過程的範例，展示「操作序列」對應的回傳結果：</p>
<p>input：<br>
[“Trie”,“insert”,“search”,“search”,“startsWith”,“insert”,“search”]<br>
[[],[“apple”],[“apple”],[“app”],[“app”],[“app”],[“app”]]</p>
<p>output：<br>
[null,null,true,false,true,null,true]</p>
<p><strong>說明</strong>：</p>
<ol>
<li><code>Trie trie = new Trie();</code>   → 回傳  <code>null</code>  （初始化）</li>
<li><code>trie.insert(&quot;apple&quot;);</code>    → 回傳  <code>null</code>  （插入不回傳結果）</li>
<li><code>trie.search(&quot;apple&quot;);</code>    → 回傳  <code>true</code>  （字串 “apple” 存在）</li>
<li><code>trie.search(&quot;app&quot;);</code>      → 回傳  <code>false</code> （字串 “app” 不是完整儲存的單詞）</li>
<li><code>trie.startsWith(&quot;app&quot;);</code> → 回傳  <code>true</code>  （有單詞以 “app” 為前綴）</li>
<li><code>trie.insert(&quot;app&quot;);</code>      → 回傳  <code>null</code>  （插入 “app”）</li>
<li><code>trie.search(&quot;app&quot;);</code>      → 回傳  <code>true</code>  （“app” 現在已經被插入）</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>所有字串僅包含小寫英文字母  <code>a</code>  到  <code>z</code> 。</li>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code> 。</li>
<li>最多執行  <code>insert</code> ,  <code>search</code> ,  <code>startsWith</code>  操作共  <code>10^4</code>  次。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用 Trie 結構：以節點（Node）為單位，每個節點持有 26 個子指標（對應 a–z）與一個布林標記  <code>isEnd</code>  表示該節點是否為某字串的結尾。</li>
<li>插入（ <code>insert</code> ）時，從根節點出發，沿著  <code>word</code>  中每個字符依次檢查子指標是否為  <code>nullptr</code> 。若為空便建立新節點；最後將當前節點的  <code>isEnd</code>  設為  <code>true</code> 。</li>
<li>搜尋完整字串（ <code>search</code> ）時，沿  <code>word</code>  所有字符往下遍歷。如果某一步子指標為  <code>nullptr</code> ，直接返回  <code>false</code> ；遍歷完成後，檢查當前節點的  <code>isEnd</code> 。若為  <code>true</code> ，代表整個  <code>word</code>  存在於 Trie 中，返回  <code>true</code> ，否則返回  <code>false</code> 。</li>
<li>搜尋前綴（ <code>startsWith</code> ）時，類似  <code>search</code> ，但到遍歷結束即可返回  <code>true</code> ，不需檢查  <code>isEnd</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定義 Trie 節點</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="type">bool</span> isEnd;                         <span class="comment">// 標記是否為字串結尾</span></span><br><span class="line">        array&lt;TrieNode*, 26&gt; children;      <span class="comment">// 26 個子指標對應 a–z</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            children.<span class="built_in">fill</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    TrieNode* root;  <span class="comment">// 根節點</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 初始化 Trie 物件 */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 將字串 word 插入 Trie */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[idx] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;  <span class="comment">// 標記字串結尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 搜尋完整字串 word 是否存在於 Trie */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(<span class="type">const</span> string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 過程中若無對應節點，代表字串不存在</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;     <span class="comment">// 需確保該節點是完整單詞的結尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 判斷是否存在以 prefix 為開頭的任何字串 */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(<span class="type">const</span> string&amp; prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> idx = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[idx] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// 若某步驟找不到節點，代表無此前綴</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;            <span class="comment">// 遍歷完前綴就代表存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="comment">// 清除所分配的記憶體</span></span><br><span class="line">        <span class="built_in">clearTrie</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/** 遞迴釋放節點 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clearTrie</span><span class="params">(TrieNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[i]) &#123;</span><br><span class="line">                <span class="built_in">clearTrie</span>(node-&gt;children[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度</p>
<ul>
<li>insert (word): O (m)，其中 m 為要插入字串的長度。</li>
<li>search (word): O (m)，其中 m 為要搜尋字串的長度。</li>
<li>startsWith (prefix): O (m)，其中 m 為前綴字串的長度。</li>
</ul>
</li>
<li>
<p>空間複雜度</p>
<ul>
<li>最壞情況下，Trie 中節點數量等於所有插入字串長度的總和。若插入 k 個字串，總長度為 S，則空間複雜度為 O (S)。</li>
</ul>
</li>
</ul>
<h3 id="coin-change"><a class="markdownIt-Anchor" href="#coin-change">#</a> Coin Change</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29pbi1jaGFuZ2Uv">題目連結</span><br>
<strong>標籤</strong>: Dynamic Programming, BFS（也可用 BFS 解法）<br>
<strong>語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一組不同面額的硬幣  <code>coins</code>  與一個總金額  <code>amount</code> ，請找出可以湊出該金額的最少硬幣數量。<br>
如果無法湊出該金額，則返回  <code>-1</code> 。<br>
你可以假設每種面額的硬幣數量無限多個。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>coins = [1, 2, 5], amount = 11</code> <br>
Output:  <code>3</code> <br>
Explanation: 11 = 5 + 5 + 1</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>coins = [2], amount = 3</code> <br>
Output:  <code>-1</code> <br>
Explanation: 無法湊出 3</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
Input:  <code>coins = [1], amount = 0</code> <br>
Output:  <code>0</code> <br>
Explanation: 不需要任何硬幣即可湊出 0</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= coins.length &lt;= 12</code></li>
<li><code>1 &lt;= coins[i] &lt;= 2^31 - 1</code></li>
<li><code>0 &lt;= amount &lt;= 10^4</code></li>
<li>面額資料均為正整數，且最多只有 12 種硬幣</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題關鍵在於動態規劃（DP）。我們想求出「湊出金額  <code>j</code>  所需的最少硬幣數量」，設  <code>dp[j]</code>  為湊出金額  <code>j</code>  所需最少硬幣數。</p>
<ul>
<li>
<p>初始條件：</p>
<ul>
<li><code>dp[0] = 0</code>  （湊出 0，需要 0 個硬幣）。</li>
<li>對於  <code>j &gt; 0</code> ，先將  <code>dp[j]</code>  初始化為一個很大的數（例如  <code>amount + 1</code> ，代表無法湊出）。</li>
</ul>
</li>
<li>
<p>狀態轉移：</p>
<ul>
<li>對於每個面額  <code>coin</code> ，如果當前目標金額為  <code>j</code> ，且  <code>j - coin &gt;= 0</code> ，則可以由  <code>dp[j - coin]</code>  轉移得到：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    dp[j] = min(dp[j], dp[j - coin] + 1)</span><br><span class="line">    ```  </span><br><span class="line">  - 以上含義為：若我們已知湊出 `j - coin` 需要的最少硬幣數為 `dp[j - coin]`，那麼再加上一個面額為 `coin` 的硬幣，總共就能湊出 `j`，所需硬幣數為 `dp[j - coin] + 1`。對於所有面額都嘗試一次，就能得到最少硬幣數。  </span><br><span class="line"> </span><br><span class="line">- 最終答案：如果 `dp[amount]` 還保持初始的「無窮」值（大於 `amount`），說明無法湊出，回傳 `-1`；否則回傳 `dp[amount]`。  </span><br><span class="line"> </span><br><span class="line">由於 `amount` 最大為 10^4，`coins.length` 最多 12，雙重迴圈 O(amount × coins.length) 約為 10^5，到底可以接受。  </span><br><span class="line"></span><br><span class="line">**程式碼**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">   int coinChange(const vector&lt;int&gt;&amp; coins, int amount) &#123;</span><br><span class="line">       // 如果金額為 0，直接返回 0</span><br><span class="line">       if (amount == 0) return 0;</span><br><span class="line">       </span><br><span class="line">       // 初始化 dp 陣列，大小為 amount + 1，初始都設為 amount+1（代表無法湊出）</span><br><span class="line">       vector&lt;int&gt; dp(amount + 1, amount + 1);</span><br><span class="line">       dp[0] = 0;  // 湊出 0 元需要 0 枚硬幣</span><br><span class="line">       </span><br><span class="line">       // 對於每個金額 j，嘗試所有硬幣面額做轉移</span><br><span class="line">       for (int j = 1; j &lt;= amount; j++) &#123;</span><br><span class="line">           for (int coin : coins) &#123;</span><br><span class="line">               if (j - coin &gt;= 0) &#123;</span><br><span class="line">                   dp[j] = min(dp[j], dp[j - coin] + 1);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       // 若最終 dp[amount] 還是初始的「amount+1」，表示無法湊出</span><br><span class="line">       return dp[amount] &gt; amount ? -1 : dp[amount];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (amount × n)，其中 amount 為目標金額大小，n = coins.length 為硬幣種類數。</p>
<ul>
<li>外層迴圈從 1 到 amount，內層迴圈遍歷每種硬幣，總共約 amount × n 次操作。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (amount)，需要額外一個大小為 amount + 1 的 dp 陣列。</p>
</li>
</ul>
<h3 id="product-of-array-except-self"><a class="markdownIt-Anchor" href="#product-of-array-except-self">#</a> Product of Array Except Self</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcHJvZHVjdC1vZi1hcnJheS1leGNlcHQtc2VsZi8=">題目連結</span><br>
<strong>標籤</strong>: Array, Prefix Sum (或 前綴 / 後綴乘積)<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列  <code>nums</code> ，長度為  <code>n</code> ，請返回一個陣列  <code>answer</code> ，其中  <code>answer[i]</code>  等於  <code>nums</code>  中除了自身  <code>nums[i]</code>  之外所有元素的乘積。</p>
<p>請注意，要求在不使用除法且在 O (n) 時間內完成此操作。保證運算結果符合 32 位有號整數範圍。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
Input:  <code>nums = [1,2,3,4]</code> <br>
Output:  <code>[24,12,8,6]</code> <br>
Explanation：</p>
<ul>
<li>對於 i = 0，answer [0] = 2 * 3 * 4 = 24</li>
<li>對於 i = 1，answer [1] = 1 * 3 * 4 = 12</li>
<li>對於 i = 2，answer [2] = 1 * 2 * 4 = 8</li>
<li>對於 i = 3，answer [3] = 1 * 2 * 3 = 6</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:<br>
Input:  <code>nums = [-1,1,0,-3,3]</code> <br>
Output:  <code>[0,0,9,0,0]</code> <br>
Explanation：</p>
<ul>
<li>有一個元素為 0，因此只要計算除該 0 之外其他數字的乘積：(-1)<em>1</em>(-3)*3 = 9</li>
<li>其他位置因為包含自身為 0 或者遇到陣列中有 0，也會使對應位置結果為 0。</li>
</ul>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>n == nums.length</code></li>
<li><code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>
<li>保證任意前綴與後綴的乘積結果均符合 32 位有號整數範圍（即  <code>-2^31</code>  到  <code>2^31 - 1</code> ）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題要求在 O (n) 時間內計算每個位置 i 的「除自身之外所有元素乘積」，且不能使用除法。常見技巧是利用「前綴乘積」與「後綴乘積」。</p>
<p>步驟如下：</p>
<ol>
<li>建立長度為 n 的結果陣列  <code>answer</code> ，用來暫存最終答案。</li>
<li>首先從左到右計算「前綴乘積」（Prefix Product）：
<ul>
<li>定義  <code>left_prod[i]</code>  為陣列  <code>nums</code>  中索引小於 i 的所有元素乘積。例如  <code>left_prod[0] = 1</code> （因為左側沒有元素）， <code>left_prod[1] = nums[0]</code> ， <code>left_prod[2] = nums[0]*nums[1]</code> ，以此類推。</li>
<li>可以直接把  <code>left_prod</code>  存到  <code>answer</code>  中，令  <code>answer[i] = left_prod[i]</code> 。</li>
</ul>
</li>
<li>接著從右到左計算「後綴乘積」（Right Product），並且同時把它乘到  <code>answer[i]</code> ：
<ul>
<li>定義  <code>right_prod</code>  初始為 1（右邊沒有元素）。</li>
<li>從 i = n-1 開始往左：先把  <code>answer[i]</code>  與當前  <code>right_prod</code>  相乘，得到「左側乘積 × 右側乘積」，即為忽略  <code>nums[i]</code>  的所有元素乘積。</li>
<li>然後更新  <code>right_prod *= nums[i]</code> ，準備處理下一個 i-1。</li>
</ul>
</li>
<li>最後  <code>answer</code>  陣列即為答案。這樣只需要兩次線性遍歷，均為 O (n)，且額外空間只用到  <code>answer</code>  及一個  <code>right_prod</code>  變數（如果把前綴乘積直接累到  <code>answer</code> ，就不需要額外  <code>left_prod</code>  陣列）。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 計算前綴乘積，暫存到 answer</span></span><br><span class="line">        <span class="comment">//    answer[i] = nums[0] * nums[1] * ... * nums[i-1]</span></span><br><span class="line">        <span class="type">int</span> prefix = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            answer[i] = prefix;</span><br><span class="line">            prefix *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 計算後綴乘積，並與 answer[i] 相乘</span></span><br><span class="line">        <span class="comment">//    right_prod 初始為 1，代表 i = n 時，右側沒有元素</span></span><br><span class="line">        <span class="type">int</span> right_prod = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            answer[i] *= right_prod;</span><br><span class="line">            right_prod *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>只需要兩次長度為 n 的線性掃描：一次從左往右累計前綴乘積，一次從右往左累計後綴乘積並乘到結果陣列。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)（不含輸出陣列）</p>
<ul>
<li>除了輸出陣列 answer 之外，只使用常數個額外變數 prefix、right_prod，不需要額外的長度為 n 的輔助陣列。</li>
</ul>
</li>
</ul>
<h3 id="min-stack"><a class="markdownIt-Anchor" href="#min-stack">#</a> Min Stack</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluLXN0YWNrLw==">題目連結</span><br>
<strong>標籤</strong>: Stack, Design<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Easy<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>設計一個支援以下操作的堆疊 (stack) 結構：</p>
<ol>
<li><code>push(x)</code>  — 將元素  <code>x</code>  推入堆疊。</li>
<li><code>pop()</code>   — 删除堆疊頂端的元素。</li>
<li><code>top()</code>   — 獲取堆疊頂端的元素。</li>
<li><code>getMin()</code>  — 獲取堆疊中的最小元素。</li>
</ol>
<p>所有操作的時間複雜度都必須為 O (1)。</p>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要你從標準輸入讀取資料，也不需要你將結果輸出到標準輸出，只需實作下面四個接口。</p>
<p>input：<br>
[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]<br>
[[],[-2],[0],[-3],[],[],[],[]]</p>
<p>output：<br>
[null,null,null,null,-3,null,0,-2]</p>
</blockquote>
<p><strong>說明</strong>：</p>
<blockquote>
<ol>
<li><code>MinStack minStack = new MinStack();</code>  → 回傳  <code>null</code>  （建構函式不回傳值）</li>
<li><code>minStack.push(-2);</code>          → 回傳  <code>null</code></li>
<li><code>minStack.push(0);</code>           → 回傳  <code>null</code></li>
<li><code>minStack.push(-3);</code>          → 回傳  <code>null</code></li>
<li><code>minStack.getMin();</code>          → 回傳  <code>-3</code>  （堆疊中的最小值）</li>
<li><code>minStack.pop();</code>             → 回傳  <code>null</code>  （刪除頂端元素  <code>-3</code> ）</li>
<li><code>minStack.top();</code>             → 回傳  <code>0</code>   （頂端元素為  <code>0</code> ）</li>
<li><code>minStack.getMin();</code>          → 回傳  <code>-2</code>  （剩下元素中最小值為  <code>-2</code> ）</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>push</code> ,  <code>pop</code> ,  <code>top</code> ,  <code>getMin</code>  總共會被調用不超過  <code>3 × 10^4</code>  次。</li>
<li>在調用  <code>pop</code> ,  <code>top</code> ,  <code>getMin</code>  之前，保證堆疊中至少有一個元素。</li>
<li>元素值範圍在  <code>[-2^31, 2^31 - 1]</code>  之間。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>要在 O (1) 時間內同時維護堆疊和查詢最小值，我們可以採用「雙堆疊」的技巧：</p>
<ol>
<li><code>dataStack</code> ：正常存放所有推入的數值，用於  <code>push</code> 、 <code>pop</code> 、 <code>top</code>  操作。</li>
<li><code>minStack</code> ：只存放當前堆疊對應位置的「最小值」。對於每一次  <code>push(x)</code> ，我們先比較  <code>x</code>  與  <code>minStack.top()</code> ，若  <code>minStack</code>  為空則直接把  <code>x</code>  推入；若不空，則推入  <code>min(x, minStack.top())</code> 。這樣  <code>minStack.top()</code>  始終代表當前堆疊裏所有元素的最小值。</li>
</ol>
<ul>
<li><code>push(x)</code>
<ol>
<li>在  <code>dataStack</code>  推入  <code>x</code> 。</li>
<li>若  <code>minStack</code>  為空，則  <code>minStack.push(x)</code> ；否則  <code>minStack.push(min(x, minStack.top()))</code> 。</li>
</ol>
</li>
<li><code>pop()</code>
<ol>
<li>在  <code>dataStack</code>  執行  <code>pop()</code> 。</li>
<li>同時在  <code>minStack</code>  執行  <code>pop()</code> 。</li>
</ol>
</li>
<li><code>top()</code>
<ul>
<li>直接返回  <code>dataStack.top()</code> 。</li>
</ul>
</li>
<li><code>getMin()</code>
<ul>
<li>直接返回  <code>minStack.top()</code> 。</li>
</ul>
</li>
</ul>
<p>由於每個操作只涉及常數次堆疊操作，時間複雜度均為 O (1)。空間上比單純的堆疊多了一個同大小的  <code>minStack</code> ，因此是 O (n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; dataStack;  <span class="comment">// 存放所有數值</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStack;   <span class="comment">// 存放對應位置的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 初始化堆疊 */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        <span class="comment">// 建構時不需要額外處理</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 將元素 x 推入堆疊 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        dataStack.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (minStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            minStack.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 保留當前堆疊中的最小值</span></span><br><span class="line">            <span class="type">int</span> currentMin = minStack.<span class="built_in">top</span>();</span><br><span class="line">            minStack.<span class="built_in">push</span>(<span class="built_in">min</span>(x, currentMin));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 删除堆疊頂端的元素 */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dataStack.<span class="built_in">pop</span>();</span><br><span class="line">        minStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 獲取堆疊頂端的元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 獲取堆疊中的最小元素 */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (1)</p>
<ul>
<li>push, pop, top, getMin 均只做常數次堆疊操作。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>需要兩個大小為 n 的堆疊：一個 dataStack 存放原始數值，另一個 minStack 存放對應位置的最小值。</li>
</ul>
</li>
</ul>
<h3 id="validate-binary-search-tree"><a class="markdownIt-Anchor" href="#validate-binary-search-tree">#</a> Validate Binary Search Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWRhdGUtYmluYXJ5LXNlYXJjaC10cmVlLw==">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search (DFS), Recursion<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點  <code>root</code> ，判斷其是否為一棵有效的二元搜尋樹（BST）。</p>
<p>有效的 BST 定義如下：</p>
<ol>
<li>節點的左子樹所有節點的值都必須 <strong>小於</strong> 該節點的值。</li>
<li>節點的右子樹所有節點的值都必須 <strong>大於</strong> 該節點的值。</li>
<li>左右子樹自身也都必須是有效的 BST。</li>
</ol>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要你從標準輸入讀取資料，也不需要你將結果輸出到標準輸出，只需實作  <code>isValidBST</code>  介面。</p>
<p>Example 1:<br>
input：root = [2,1,3]<br>
output：true</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>Example 2:<br>
input：root = [5,1,4,null,null,3,6]<br>
output：false<br>
Explanation：<br>
節點 4 的左子節點 3 小於 5 但該位置應該 &gt; 5，違反 BST 定義，所以返回 false。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數量  <code>n</code>  的範圍為  <code>[1, 10^4]</code> 。</li>
<li>每個節點的值屬於 64 位整數範圍，但為方便轉換，可假設節點值在 32 位有號整數範圍內。</li>
<li>節點值可能有重複。若有重複值則不視為有效 BST （必須嚴格小於或大於）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>要判斷一棵二元樹是否是有效的 BST，關鍵在於 <strong>每個節點的值都要在一個合法的上下界範圍內</strong>，而這個上下界會隨著遞歸往下修改：</p>
<ol>
<li>從根節點開始，根節點的合法值範圍是  <code>(-∞, +∞)</code> 。</li>
<li>當遞歸進入某個節點  <code>node</code> ，我們知道它的值必須在  <code>(lower, upper)</code>  範圍內。如果  <code>node-&gt;val</code>  不在此區間就可以直接返回  <code>false</code> 。</li>
<li>對於  <code>node-&gt;left</code> ，它的合法範圍變成  <code>(lower, node-&gt;val)</code> 。</li>
<li>對於  <code>node-&gt;right</code> ，它的合法範圍變成  <code>(node-&gt;val, upper)</code> 。</li>
<li>以此方式對整棵樹做 DFS，若所有節點都符合對應的上下界，即可返回  <code>true</code> ，否則一旦發現不合法，就立刻返回  <code>false</code> 。</li>
</ol>
<p>這種方法只需一次深度優先遍歷，時間複雜度為 O (n)。空間方面，遞歸棧高度最壞為樹高 O (n)，若是平衡樹則為 O (log n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">min</span>(), std::numeric_limits&lt;<span class="type">long</span> <span class="type">long</span>&gt;::<span class="built_in">max</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 檢查以 node 為根的子樹，所有節點值是否都在 (lower, upper) 範圍內</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* node, <span class="type">long</span> <span class="type">long</span> lower, <span class="type">long</span> <span class="type">long</span> upper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空樹是有效 BST</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當前節點值必須嚴格在 (lower, upper) 之間</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt;= lower || node-&gt;val &gt;= upper) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子樹所有節點必須小於 node-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(node-&gt;left, lower, node-&gt;val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子樹所有節點必須大於 node-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">dfs</span>(node-&gt;right, node-&gt;val, upper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>對每個節點僅訪問一次，並做常數時間的上下界比較與遞歸呼叫。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)（最壞情況）</p>
<ul>
<li>遞歸棧深度最壞會到達樹的節點總數 n；若二元樹高度較平衡則約為 O (log n)。</li>
</ul>
</li>
</ul>
<h3 id="number-of-islands"><a class="markdownIt-Anchor" href="#number-of-islands">#</a> Number of Islands</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbnVtYmVyLW9mLWlzbGFuZHMv">題目連結</span><br>
<strong>標籤</strong>: DFS, BFS, Union Find（此處以 DFS 為主）<br>
<strong>語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由  <code>'1'</code> （陸地）和  <code>'0'</code> （水域）組成的二維網格  <code>grid</code> ，請計算網格中「島嶼」的數量。</p>
<p>一座「島嶼」被定義為連續相鄰的陸地塊集合，其中相鄰只考慮上下左右四個方向（水平方向或垂直方向）。你可以假設網格的四邊都被水域包圍。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
input：<br>
grid = [<br>
[‘1’,‘1’,‘0’,‘0’,‘0’],<br>
[‘1’,‘1’,‘0’,‘0’,‘0’],<br>
[‘0’,‘0’,‘1’,‘0’,‘0’],<br>
[‘0’,‘0’,‘0’,‘1’,‘1’]<br>
]<br>
output：3<br>
Explanation：<br>
第一個島嶼由左上角的 4 個 ‘1’ 組成；第二個島嶼由中間的單個 ‘1’ 組成；第三個島嶼由右下角的 2 個 ‘1’ 組成。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
input：<br>
grid = [<br>
[‘1’,‘1’,‘1’,‘1’,‘0’],<br>
[‘1’,‘1’,‘0’,‘1’,‘0’],<br>
[‘1’,‘1’,‘0’,‘0’,‘0’],<br>
[‘0’,‘0’,‘0’,‘0’,‘0’]<br>
]<br>
output：1<br>
Explanation：<br>
整個左上區域連成一片，僅有一座島嶼。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == grid.size()</code> ， <code>n == grid[i].size()</code> 。</li>
<li><code>1 &lt;= m, n &lt;= 300</code> 。</li>
<li><code>grid[i][j]</code>  的值僅為  <code>'0'</code>  或  <code>'1'</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題要計算連續相鄰的  <code>'1'</code>  群組個數，可以把每一個  <code>'1'</code>  視為尚未探索的陸地，遇到就啟動一次深度優先搜尋（DFS）或廣度優先搜尋（BFS），把整座島嶼上的所有相鄰  <code>'1'</code>  都標記為已訪問（或改成  <code>'0'</code> ）。如此每次 DFS/BFS 完成後，就代表找到了一座完整的島嶼，累計計數加一。</p>
<p>具體步驟：</p>
<ol>
<li>遍歷二維網格的每個格子  <code>(i, j)</code> ，若  <code>grid[i][j] == '1'</code> ，表示發現一座新的島嶼。</li>
<li>計數器  <code>count++</code> ，接著呼叫  <code>dfs(i, j)</code> （或  <code>bfs(i, j)</code> ），將與  <code>(i,j)</code>  相連的所有  <code>'1'</code>  全部「淹沒」（例如把它們設為  <code>'0'</code> ），避免重複計算。</li>
<li><code>dfs(i, j)</code>  函式內部：
<ul>
<li>若  <code>i, j</code>  越界或  <code>grid[i][j] != '1'</code> ，直接返回。</li>
<li>將  <code>grid[i][j]</code>  設為  <code>'0'</code> ，然後對上下左右四個方向遞迴呼叫  <code>dfs</code> 。</li>
</ul>
</li>
<li>遍歷完整個網格後， <code>count</code>  即為島嶼的數量，回傳該值。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 發現一座新的島嶼</span></span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 深度優先搜尋，將與 (i, j) 相連的所有 &#x27;1&#x27; 全部改成 &#x27;0&#x27;</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 邊界檢查 或 已經不是陸地，則返回</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || grid[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 將當前格子「淹沒」為 &#x27;0&#x27;</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向四個方向遞迴</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j, m, n); <span class="comment">// 上</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j, m, n); <span class="comment">// 下</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>, m, n); <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>, m, n); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m × n)</p>
<ul>
<li>每個格子至多會被 dfs 訪問一次（變成 ‘0’ 之後就不再重複進入），並且每次訪問會檢查最多四個鄰居。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (m × n)（最壞情況遞迴棧空間）</p>
<ul>
<li>若整個網格幾乎全是 ‘1’，則第一座島嶼的遞迴深度可能達到 m×n；若島嶼分散則深度較淺，但最壞依然是 O (m × n)。</li>
</ul>
</li>
</ul>
<h3 id="rotting-oranges"><a class="markdownIt-Anchor" href="#rotting-oranges">#</a> Rotting Oranges</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcm90dGluZy1vcmFuZ2VzLw==">題目連結</span><br>
<strong>標籤</strong>: BFS, Matrix<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由三種值組成的二維網格  <code>grid</code> ：</p>
<ul>
<li><code>0</code>  代表空格子；</li>
<li><code>1</code>  代表新鮮橘子；</li>
<li><code>2</code>  代表腐爛橘子；</li>
</ul>
<p>每分鐘，任何與腐爛橘子相鄰（上下左右四個方向）的新鮮橘子都會立即被腐爛。返回將所有新鮮橘子腐爛所需的最少分鐘數。如果無法讓所有橘子都腐爛，則返回  <code>-1</code> 。</p>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要從標準輸入讀取，也不需要輸出格式化結果，只需實作  <code>orangesRotting</code>  函式。</p>
<p>以下是常見的呼叫示範：</p>
<p>Example 1:</p>
<p>input：<br>
grid = [<br>
[2,1,1],<br>
[1,1,0],<br>
[0,1,1]<br>
]<br>
output：4<br>
Explanation：</p>
<ul>
<li>初始時只有  <code>(0,0)</code>  是腐爛：<br>
[2,1,1]<br>
[1,1,0]<br>
[0,1,1]</li>
<li>第 1 分鐘後，(0,1) 與 (1,0) 變腐爛：<br>
[2,2,1]<br>
[2,1,0]<br>
[0,1,1]</li>
<li>第 2 分鐘後，(0,2)、(1,1)、(2,1) 變腐爛：<br>
[2,2,2]<br>
[2,2,0]<br>
[0,2,1]</li>
<li>第 3 分鐘後，(2,2) 變腐爛：<br>
[2,2,2]<br>
[2,2,0]<br>
[0,2,2]</li>
<li>第 4 分鐘後，所有新鮮橘子都已腐爛。</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:<br>
input：<br>
grid = [<br>
[2,1,1],<br>
[0,1,1],<br>
[1,0,1]<br>
]<br>
output：-1<br>
Explanation：<br>
最右下角的  <code>(2,2)</code>  位置新鮮橘子永遠無法被腐爛，因為它與其餘腐爛源不連通。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
input：<br>
grid = [<br>
[0,2]<br>
]<br>
output：0<br>
Explanation：<br>
沒有新鮮橘子，故不需要花費任何時間，結果為  <code>0</code> 。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == grid.size()</code> ， <code>n == grid[i].size()</code> 。</li>
<li><code>1 &lt;= m, n &lt;= 10^2</code> 。</li>
<li><code>grid[i][j]</code>  的值僅為  <code>0</code> 、 <code>1</code>  或  <code>2</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>使用 BFS（廣度優先搜尋）模擬腐爛過程：</p>
<ol>
<li>首先遍歷整個  <code>grid</code> ，將所有初始腐爛橘子（值為  <code>2</code> ）的位置加入一個隊列  <code>queue&lt;pair&lt;int,int&gt;&gt;</code> ，同時計算新鮮橘子的總數  <code>freshCount</code> 。</li>
<li>如果初始時  <code>freshCount == 0</code> ，代表沒有新鮮橘子，直接返回  <code>0</code> 。</li>
<li>以多源 BFS 開始：每輪代表「過一分鐘」，先記錄當前隊列長度  <code>sz = queue.size()</code> ，然後處理  <code>sz</code>  個腐爛橘子：
<ul>
<li>對於每個腐爛的位置  <code>(r,c)</code> ，檢查其上下左右四個方向相鄰的格子  <code>(nr,nc)</code> 。</li>
<li>如果  <code>(nr,nc)</code>  在範圍內且  <code>grid[nr][nc] == 1</code> （新鮮橘子），則將其設為腐爛  <code>grid[nr][nc] = 2</code> ， <code>freshCount--</code> ，並把  <code>(nr,nc)</code>  推入隊列，以便下一分鐘繼續擴散。</li>
</ul>
</li>
<li>當一輪 BFS 處理完畢後，如果隊列不為空，代表仍有新腐爛橘子可繼續傳染，時間  <code>minutes++</code> 。</li>
<li>重複上述步驟直到隊列為空：
<ul>
<li>如果此時  <code>freshCount == 0</code> ，代表所有橘子都腐爛，返回  <code>minutes</code> ；</li>
<li>否則仍有新鮮橘子無法被染到，返回  <code>-1</code> 。</li>
</ul>
</li>
</ol>
<p>由於每個格子最多只會入隊一次，並檢查四個方向，因此時間複雜度為 O (m × n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> freshCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 將所有初始腐爛橘子加入隊列，並計算新鮮橘子數量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果沒有新鮮橘子，直接返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (freshCount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> minutes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 方向向量：上、下、左、右</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dr = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dc = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 多源 BFS，每分鐘腐爛一次</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> anyRottenThisRound = <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; sz; k++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [r, c] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 檢查四個方向</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++) &#123;</span><br><span class="line">                    <span class="type">int</span> nr = r + dr[d];</span><br><span class="line">                    <span class="type">int</span> nc = c + dc[d];</span><br><span class="line">                    <span class="comment">// 若在範圍內且是新鮮橘子，則變為腐爛</span></span><br><span class="line">                    <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; n &amp;&amp; grid[nr][nc] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nr][nc] = <span class="number">2</span>;</span><br><span class="line">                        freshCount--;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(nr, nc);</span><br><span class="line">                        anyRottenThisRound = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果這一輪有新橘子被腐爛，則分鐘數加一</span></span><br><span class="line">            <span class="keyword">if</span> (anyRottenThisRound) &#123;</span><br><span class="line">                minutes++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判斷是否所有橘子都已腐爛</span></span><br><span class="line">        <span class="keyword">return</span> (freshCount == <span class="number">0</span>) ? minutes : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m × n)</p>
<ul>
<li>每個格子至多只會入隊一次，並且每次出隊會檢查四個方向，整體為 O (mn)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (m × n)</p>
<ul>
<li>最壞情況下，所有格子都是腐爛橘子，同時入隊，隊列大小可達 m×n；另外原地修改 grid，不使用額外矩陣。</li>
</ul>
</li>
</ul>
<h2 id="week-5-88"><a class="markdownIt-Anchor" href="#week-5-88">#</a> Week 5 (8/8)</h2>
<h3 id="search-in-rotated-sorted-array"><a class="markdownIt-Anchor" href="#search-in-rotated-sorted-array">#</a> Search in Rotated Sorted Array</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2VhcmNoLWluLXJvdGF0ZWQtc29ydGVkLWFycmF5Lw==">題目連結</span><br>
<strong>標籤</strong>: Array, Binary Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個已經 <strong>按升序排序</strong> 且 <strong>旋轉</strong> 過的整數陣列  <code>nums</code> （旋轉前陣列中所有元素互不相同），以及一個目標值  <code>target</code> ，請在陣列中搜尋目標值，若存在則返回其索引，否則返回  <code>-1</code> 。</p>
<p>旋轉的方式是將陣列中某個位置前後的元素交換到兩端，例如原陣列  <code>[0,1,2,4,5,6,7]</code>  經過旋轉後可能變為  <code>[4,5,6,7,0,1,2]</code> 。</p>
</blockquote>
<blockquote>
<p>需要寫一個時間複雜度在 O log (n) 的解法。</p>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要從標準輸入讀取資料，也不需要輸出格式化結果，只需實作  <code>search</code>  函式。</p>
<p>Example 1:</p>
<p>input：nums = [4,5,6,7,0,1,2], target = 0<br>
output：4<br>
Explanation：陣列中 nums [4] == 0。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：nums = [4,5,6,7,0,1,2], target = 3<br>
output：-1<br>
Explanation：陣列中沒有值為 3 的元素。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：nums = [1], target = 0<br>
output：-1</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code></li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
<li>陣列中所有元素 <strong>互不相同</strong></li>
<li>旋轉前陣列為升序排序</li>
<li><code>-10^4 &lt;= target &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>由於陣列被旋轉過，但仍可分為「有序段 + 有序段」，可以在 O (log n) 時間內搜索。常見方法是改良版二分搜尋：</p>
<ol>
<li>設  <code>left=0</code> ,  <code>right=n-1</code> ，進入迴圈  <code>while (left &lt;= right)</code> ：</li>
<li>計算中點  <code>mid = (left + right) / 2</code> 。</li>
<li>若  <code>nums[mid] == target</code> ，直接返回  <code>mid</code> 。</li>
<li>判斷哪一半是有序的：
<ul>
<li>如果  <code>nums[left] &lt;= nums[mid]</code> ，表示左半段  <code>[left..mid]</code>  為<strong>升序</strong>。
<ul>
<li>若  <code>target</code>  在這個區間內（ <code>nums[left] &lt;= target &lt; nums[mid]</code> ），則  <code>right = mid - 1</code> ；否則  <code>left = mid + 1</code> 。</li>
</ul>
</li>
<li>否則右半段  <code>[mid..right]</code>  為<strong>升序</strong>。
<ul>
<li>若  <code>target</code>  在這個區間內（ <code>nums[mid] &lt; target &lt;= nums[right]</code> ），則  <code>left = mid + 1</code> ；否則  <code>right = mid - 1</code> 。</li>
</ul>
</li>
</ul>
</li>
<li>迴圈結束仍未找到，即返回  <code>-1</code> 。</li>
</ol>
<p>每次都能排除一半範圍，時間複雜度 O (log n)，額外空間 O (1)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判斷左半段是否有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// target 在左半段範圍內</span></span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否則右半段必然有序</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// target 在右半段範圍內</span></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (log n)</p>
<ul>
<li>每次迴圈都能將搜尋範圍減半。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數個指標變數。</li>
</ul>
</li>
</ul>
<h3 id="combination-sum"><a class="markdownIt-Anchor" href="#combination-sum">#</a> Combination Sum</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29tYmluYXRpb24tc3VtLw==">題目連結</span><br>
<strong>標籤</strong>: Backtracking, Array, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一組 <strong>互不相同</strong> 的正整數  <code>candidates</code>  和一個目標整數  <code>target</code> ，請找出  <code>candidates</code>  中所有可以使數字和為  <code>target</code>  的<strong>組合</strong>。</p>
<p>同一個數字可以在組合中被選擇 <strong>無限次</strong>。</p>
<p>解集不能包含重複的組合。你可以按任意順序返回這些組合。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：candidates = [2,3,6,7], target = 7<br>
output：[[7],[2,2,3]]<br>
Explanation：</p>
<ul>
<li>7 = 7</li>
<li>2 + 2 + 3 = 7</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：candidates = [2,3,5], target = 8<br>
output：[[2,2,2,2],[2,3,3],[3,5]]</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：candidates = [2], target = 1<br>
output：[]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li><code>candidates</code>  中所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 500</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可用回溯（Backtracking）或深度優先搜尋（DFS）枚舉所有組合：</p>
<ol>
<li>先對  <code>candidates</code>  排序（可選），以便後續剪枝。</li>
<li>定義遞歸函式  <code>dfs(start, sum)</code> ：
<ul>
<li><code>start</code>  表示當前可選擇的起始索引，避免重複組合；</li>
<li><code>sum</code>  表示當前累計的總和。</li>
</ul>
</li>
<li>當  <code>sum == target</code>  時，將當前路徑  <code>path</code>  加入結果集；</li>
<li>當  <code>sum &gt; target</code>  時，剪枝返回；</li>
<li>否則從  <code>i = start</code>  開始遍歷每個候選數  <code>candidates[i]</code> ：
<ul>
<li>將  <code>candidates[i]</code>  加入  <code>path</code> ，呼叫  <code>dfs(i, sum + candidates[i])</code> （同一索引可重複使用）；</li>
<li>回溯時將剛才加入的元素從  <code>path</code>  中移除。</li>
</ul>
</li>
<li>完成遍歷後即得所有可能組合。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());  <span class="comment">// 可選：排序以便剪枝</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; cand, <span class="type">int</span> target, <span class="type">int</span> start,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// 剪枝</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; cand.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = cand[i];</span><br><span class="line">            <span class="comment">// sum + x &gt; target 時可以提前退出（因為已排序）</span></span><br><span class="line">            <span class="keyword">if</span> (sum + x &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="built_in">dfs</span>(cand, target, i, sum + x, path, res);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();  <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：與所有可行組合數目相關，最壞情況約為 O (k × N^(target/min (candidates)))（k 為解的平均長度），但實際受限於 target 和 candidates 數值範圍。</p>
</li>
<li>
<p>空間複雜度：O (target /min (candidates)) 深度的遞歸棧空間，以及結果集所需的額外空間。</p>
</li>
</ul>
<h3 id="permutations"><a class="markdownIt-Anchor" href="#permutations">#</a> Permutations</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGVybXV0YXRpb25zLw==">題目連結</span><br>
<strong>標籤</strong>: Backtracking, Array, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個 <strong>無重複</strong> 整數陣列  <code>nums</code> ，請返回該陣列所有可能的全排列。可以按任意順序返回答案。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>輸入：nums = [1,2,3]<br>
 輸出：<br>
[<br>
[1,2,3],<br>
[1,3,2],<br>
[2,1,3],<br>
[2,3,1],<br>
[3,1,2],<br>
[3,2,1]<br>
]</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>輸入：nums = [0,1]<br>
 輸出：<br>
[<br>
[0,1],<br>
[1,0]<br>
]</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>輸入：nums = [1]<br>
 輸出：<br>
[[1]]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 6</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
<li><code>nums</code>  中的所有元素 <strong>互不相同</strong></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題典型的回溯（Backtracking）問題。思路為：</p>
<ol>
<li>用一個布林陣列  <code>used</code>  記錄  <code>nums</code>  中每個元素是否已經被選過；</li>
<li>用一個臨時向量  <code>path</code>  保存當前排列；</li>
<li>遞迴函式  <code>dfs()</code> ：
<ul>
<li>若  <code>path.size() == nums.size()</code> ，表示已選滿所有元素，將  <code>path</code>  加入結果集；</li>
<li>否則從  <code>i = 0</code>  到  <code>nums.size()-1</code>  遍歷，每遇到  <code>used[i] == false</code> ：
<ol>
<li>標記  <code>used[i] = true</code> ，將  <code>nums[i]</code>  推入  <code>path</code> ；</li>
<li>遞迴呼叫  <code>dfs()</code> ；</li>
<li>回溯時  <code>path.pop_back()</code> ，並重置  <code>used[i] = false</code> 。</li>
</ol>
</li>
</ul>
</li>
<li>最終結果即為所有全排列。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, used, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used,</span></span></span><br><span class="line"><span class="params"><span class="function">             vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 選擇 nums[i]</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, used, path, result);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n! × n)</p>
<ul>
<li>共生成 n! 種排列，每種排列的複製到結果集需 O (n) 時間。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)（遞迴棧深度 + 臨時路徑）</p>
<ul>
<li>除了輸出結果外，遞迴深度最深為 n，used、path 各需 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="merge-intervals"><a class="markdownIt-Anchor" href="#merge-intervals">#</a> Merge Intervals</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtaW50ZXJ2YWxzLw==">題目連結</span><br>
<strong>標籤</strong>: Array, Sorting<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一組由「閉區間」表示的區間列表  <code>intervals</code> ，請將所有重疊的區間合併，並返回合併後的區間列表。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>
output：[[1,6],[8,10],[15,18]]<br>
Explanation：</p>
<ul>
<li>區間 [1,3] 和 [2,6] 重疊，合併為 [1,6]；</li>
<li>其餘區間互不重疊。</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：intervals = [[1,4],[4,5]]<br>
output：[[1,5]]<br>
Explanation：<br>
由於 [1,4] 和 [4,5] 在端點 4 處接觸，也視為重疊，可合併為 [1,5]。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：intervals = []<br>
output：[]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= intervals.length &lt;= 10^4</code></li>
<li><code>intervals[i].length == 2</code></li>
<li><code>0 &lt;= start_i &lt;= end_i &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>若  <code>intervals</code>  為空，直接返回空列表。</li>
<li>先依各區間的起點  <code>start</code>  進行排序。</li>
<li>建立結果向量  <code>merged</code> ，將排序後的第一個區間壓入。</li>
<li>遍歷剩餘每個區間  <code>cur = [s,e]</code> ：
<ul>
<li>取  <code>last = merged.back()</code>  為結果中最後一個區間；</li>
<li>若  <code>cur.start &lt;= last.end</code> ，表示重疊，則更新  <code>last.end = max(last.end, cur.end)</code> ；</li>
<li>否則不重疊，將  <code>cur</code>  直接壓入  <code>merged</code> 。</li>
</ul>
</li>
<li>遍歷結束後， <code>merged</code>  即為合併完成的區間列表。</li>
</ol>
<p>排序耗時 O (n log n)，遍歷合併 O (n)，總時間複雜度 O (n log n)；額外空間 O (n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="comment">// 依起點排序</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(),</span><br><span class="line">             [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                 <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">             &#125;);</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">        merged.<span class="built_in">push_back</span>(intervals[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; last = merged.<span class="built_in">back</span>();</span><br><span class="line">            <span class="type">int</span> curStart = intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> curEnd   = intervals[i][<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (curStart &lt;= last[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 有重疊，合併區間</span></span><br><span class="line">                last[<span class="number">1</span>] = <span class="built_in">max</span>(last[<span class="number">1</span>], curEnd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 無重疊，直接新增</span></span><br><span class="line">                merged.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n log n)</p>
<ul>
<li>排序 O (n log n) + 一次線性掃描 O (n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>排序可能需要 O (log n) 的遞迴棧，結果向量最壞大小為原輸入的 n。</li>
</ul>
</li>
</ul>
<h3 id="lowest-common-ancestor-of-a-binary-tree"><a class="markdownIt-Anchor" href="#lowest-common-ancestor-of-a-binary-tree">#</a> Lowest Common Ancestor of a Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS10cmVlLw==">題目連結</span><br>
<strong>標籤</strong>: Tree, Recursion, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一棵二元樹的根節點  <code>root</code> ，以及樹中兩個不同節點  <code>p</code>  和  <code>q</code> ，請找出它們的最近公共祖先（LCA）。</p>
<p>最近公共祖先的定義為：對於節點  <code>p</code>  和  <code>q</code> ，在所有同時是它們祖先的節點中，<strong>最深</strong>（距離它們最近）的一個節點。</p>
<p>例如，節點  <code>u</code>  是節點  <code>v</code>  的祖先當且僅當存在一條從根到  <code>v</code>  的路徑包含  <code>u</code> 。根自身也可以是它自己的祖先。</p>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要從標準輸入讀取資料，也不需要輸出格式化結果，只需實作  <code>lowestCommonAncestor</code>  介面。</p>
<p>Example 1:</p>
<p>input：<br>
root = [3,5,1,6,2,0,8,null,null,7,4]<br>
p = 5, q = 1<br>
output：3<br>
Explanation：節點 5 與 1 的最近公共祖先是 3（根節點）。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
root = [3,5,1,6,2,0,8,null,null,7,4]<br>
p = 5, q = 4<br>
output：5<br>
Explanation：節點 5 與 4 的最近公共祖先是 5（5 自身是 4 的祖先）。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：<br>
root = [1,2]<br>
p = 1, q = 2<br>
output：1</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數量在  <code>[2, 10^5]</code> 。</li>
<li>節點值 <strong>互不相同</strong>。</li>
<li><code>p</code>  和  <code>q</code>  均存在於給定的二元樹中。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以用遞迴的深度優先搜尋 (DFS) 找 LCA：</p>
<ol>
<li>若當前節點  <code>root</code>  為  <code>nullptr</code> 、或等於  <code>p</code> 、或等於  <code>q</code> ，則直接返回  <code>root</code> ；</li>
<li>遞迴搜尋左子樹： <code>left = dfs(root-&gt;left, p, q)</code> ；</li>
<li>遞迴搜尋右子樹： <code>right = dfs(root-&gt;right, p, q)</code> ；</li>
<li>若  <code>left</code>  與  <code>right</code>  均非空，代表  <code>p</code> 、 <code>q</code>  分別位於當前節點的左右子樹，則當前節點即為最近公共祖先；</li>
<li>否則，若  <code>left</code>  非空（ <code>right</code>  為空），則 LCA 在左子樹，返回  <code>left</code> ；反之返回  <code>right</code> 。</li>
</ol>
<p>此方法只需一次遍歷，時間複雜度 O (n)，遞迴棧深度最壞 O (n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left  = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>每個節點最多被訪問一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)（最壞情況）</p>
<ul>
<li>遞迴棧深度最壞為樹的節點數；若樹高度平衡則為 O (log n)。</li>
</ul>
</li>
</ul>
<h3 id="time-based-key-value-store"><a class="markdownIt-Anchor" href="#time-based-key-value-store">#</a> Time Based Key-Value Store</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdGltZS1iYXNlZC1rZXktdmFsdWUtc3RvcmUv">題目連結</span><br>
<strong>標籤</strong>: Design, Hash Table, Binary Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作一個 <strong>時序鍵值儲存</strong> 結構  <code>TimeMap</code> ，支援以下操作：</p>
<ol>
<li><code>void set(string key, string value, int timestamp)</code>
<ul>
<li>將鍵  <code>key</code>  的值設定為  <code>value</code> ，時間戳為  <code>timestamp</code> 。</li>
</ul>
</li>
<li><code>string get(string key, int timestamp)</code>
<ul>
<li>返回 <strong>不大於</strong>  <code>timestamp</code>  的最新一次對  <code>key</code>  的設定值；</li>
<li>如果不存在這樣的設定，返回空字串  <code>&quot;&quot;</code> 。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目並不需要從標準輸入讀取，也不需要格式化輸出，只需實作  <code>TimeMap</code>  類別。</p>
<p>Example：<br>
input：<br>
[“TimeMap”,“set”,“get”,“get”,“set”,“get”,“get”]<br>
[[],[“foo”,“bar”,1],[“foo”,1],[“foo”,3],[“foo”,“bar2”,4],[“foo”,4],[“foo”,5]]</p>
<p>output：<br>
[null,null,“bar”,“bar”,null,“bar2”,“bar2”]</p>
</blockquote>
<blockquote>
<p>Explanation：</p>
<ol>
<li><code>TimeMap tm = new TimeMap();</code>       → 回傳  <code>null</code> （建構函式）</li>
<li><code>tm.set(&quot;foo&quot;,&quot;bar&quot;,1);</code>           → 回傳  <code>null</code></li>
<li><code>tm.get(&quot;foo&quot;,1);</code>                → 回傳  <code>&quot;bar&quot;</code>  （timestamp == 1 時為  <code>&quot;bar&quot;</code> ）</li>
<li><code>tm.get(&quot;foo&quot;,3);</code>                → 回傳  <code>&quot;bar&quot;</code>  （timestamp 3 查不到新設定，回傳最近的  <code>&quot;bar&quot;</code> ）</li>
<li><code>tm.set(&quot;foo&quot;,&quot;bar2&quot;,4);</code>         → 回傳  <code>null</code></li>
<li><code>tm.get(&quot;foo&quot;,4);</code>                → 回傳  <code>&quot;bar2&quot;</code></li>
<li><code>tm.get(&quot;foo&quot;,5);</code>                → 回傳  <code>&quot;bar2&quot;</code></li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>所有  <code>timestamp</code>  嚴格遞增：同一個  <code>key</code>  的後續  <code>set</code>  操作，其  <code>timestamp</code>  保證大於前一次。</li>
<li>調用  <code>set</code>  和  <code>get</code>  的總次數不超過  <code>10^5</code> 。</li>
<li><code>1 &lt;= timestamp &lt;= 10^7</code> 。</li>
<li>關鍵字和數值長度均在  <code>[1, 100]</code>  之間，只包含可列印 ASCII 字符。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用哈希表  <code>unordered_map&lt;string, vector&lt;pair&lt;int,string&gt;&gt;&gt;</code> ：
<ul>
<li>鍵為  <code>key</code> ，值為該鍵所有  <code>(timestamp, value)</code>  的有序列表（按  <code>timestamp</code>  升序儲存）。</li>
</ul>
</li>
<li><code>set(key, value, timestamp)</code> ：
<ul>
<li>直接將  <code>(timestamp, value)</code>  push_back 到對應  <code>vector</code> （因為 timestamp 嚴格遞增，維持有序性）。</li>
</ul>
</li>
<li><code>get(key, timestamp)</code> ：
<ul>
<li>在對應  <code>vector</code>  上進行二分搜尋（ <code>upper_bound</code> ）：找到第一個  <code>pair.first &gt; timestamp</code>  的位置，然後取其前一個位置的  <code>value</code> ；</li>
<li>如果插入點為  <code>begin()</code> ，代表所有已有 timestamp 都大於目標，回傳  <code>&quot;&quot;</code> ；否則回傳前一個元素的  <code>second</code> 。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMap</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// key -&gt; list of (timestamp, value)，按 timestamp 升序</span></span><br><span class="line">    unordered_map&lt;string, vector&lt;pair&lt;<span class="type">int</span>,string&gt;&gt;&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** 初始化 TimeMap 物件 */</span></span><br><span class="line">    <span class="built_in">TimeMap</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 儲存 key 對應的 value，時間戳為 timestamp */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> string&amp; key, <span class="type">const</span> string&amp; value, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        mp[key].<span class="built_in">emplace_back</span>(timestamp, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 獲取 key 在不大於 timestamp 時刻的最新 value，若不存在則返回 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">string <span class="title">get</span><span class="params">(<span class="type">const</span> string&amp; key, <span class="type">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mp.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span>&amp; vec = mp[key];</span><br><span class="line">        <span class="comment">// 二分搜尋第一個 timestamp &gt; target</span></span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), </span><br><span class="line">                              <span class="built_in">make_pair</span>(timestamp, <span class="built_in">string</span>()),</span><br><span class="line">                              [](<span class="type">const</span> pair&lt;<span class="type">int</span>,string&gt;&amp; a, <span class="type">const</span> pair&lt;<span class="type">int</span>,string&gt;&amp; b) &#123;</span><br><span class="line">                                  <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">                              &#125;);</span><br><span class="line">        <span class="keyword">if</span> (it == vec.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">prev</span>(it)-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：</p>
<ul>
<li>
<p>set：O (1) 均攤（vector::emplace_back）；</p>
</li>
<li>
<p>get：O (log k)（在長度為 k 的列表中二分搜尋）。</p>
</li>
</ul>
</li>
<li>
<p>空間複雜度：O (N)</p>
<ul>
<li>需要儲存所有 set 操作的鍵值對，總數為 N 次調用。</li>
</ul>
</li>
</ul>
<h3 id="accounts-merge"><a class="markdownIt-Anchor" href="#accounts-merge">#</a> Accounts Merge</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWNjb3VudHMtbWVyZ2Uv">題目連結</span><br>
<strong>標籤</strong>: Union Find (或 DFS + 哈希), String, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個帳戶列表  <code>accounts</code> ，每個帳戶是一個字串列表，其中第一個字串是帳戶持有者的姓名，之後的字串都是該持有者的電子郵件地址。</p>
<p>現在有多個帳戶，可能同一個人在不同帳戶中使用了部分相同的郵件地址，請將這些屬於同一人的帳戶合併。</p>
<p>合併規則：</p>
<ul>
<li>只要任意兩個帳戶有 <strong>至少一</strong> 個共同的郵箱地址，就認定屬於同一人；</li>
<li>合併後帳戶內所有郵件地址需去重並按字母順序排序；</li>
<li>輸出格式同輸入：列表中每個元素是一個帳戶，第一個元素是這個人姓名，後面是排序後的所有郵件地址。</li>
</ul>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：<br>
accounts = [<br>
[“<span class="exturl" data-url="bWFpbHRvOkpvaG4lMjIsJTIyam9obnNtaXRoQG1haWwuY29t">John&quot;,&quot;johnsmith@mail.com</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJqb2huX25ld3lvcmtAbWFpbC5jb20=">,&quot;john_newyork@mail.com</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkpvaG4lMjIsJTIyam9obnNtaXRoQG1haWwuY29t">John&quot;,&quot;johnsmith@mail.com</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJqb2huMDBAbWFpbC5jb20=">,&quot;john00@mail.com</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOk1hcnklMjIsJTIybWFyeUBtYWlsLmNvbQ==">Mary&quot;,&quot;mary@mail.com</span>”],<br>
[“<span class="exturl" data-url="bWFpbHRvOkpvaG4lMjIsJTIyam9obm55YnJhdm9AbWFpbC5jb20=">John&quot;,&quot;johnnybravo@mail.com</span>”]<br>
]<br>
output：<br>
[<br>
[“<span class="exturl" data-url="bWFpbHRvOkpvaG4lMjIsJTIyam9objAwQG1haWwuY29t">John&quot;,&quot;john00@mail.com</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJqb2huX25ld3lvcmtAbWFpbC5jb20=">,&quot;john_newyork@mail.com</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJqb2huc21pdGhAbWFpbC5jb20=">,&quot;johnsmith@mail.com</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOk1hcnklMjIsJTIybWFyeUBtYWlsLmNvbQ==">Mary&quot;,&quot;mary@mail.com</span>”],<br>
[“<span class="exturl" data-url="bWFpbHRvOkpvaG4lMjIsJTIyam9obm55YnJhdm9AbWFpbC5jb20=">John&quot;,&quot;johnnybravo@mail.com</span>”]<br>
]</p>
<p>Explanation：</p>
<ul>
<li>第一、二 個帳戶都包含  <code>johnsmith@mail.com</code> ，合併後郵箱為三個去重且排序後的地址；</li>
<li>第三個和第四個帳戶沒有與其他重疊，保持原樣。</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
accounts = [<br>
[“<span class="exturl" data-url="bWFpbHRvOkdhYmUlMjIsJTIyR2FiZTBAbS5jbw==">Gabe&quot;,&quot;Gabe0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJHYWJlM0BtLmNv">,&quot;Gabe3@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJHYWJlMUBtLmNv">,&quot;Gabe1@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOktldmluJTIyLCUyMktldmluM0BtLmNv">Kevin&quot;,&quot;Kevin3@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJLZXZpbjVAbS5jbw==">,&quot;Kevin5@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJLZXZpbjBAbS5jbw==">,&quot;Kevin0@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkV0aGFuJTIyLCUyMkV0aGFuNUBtLmNv">Ethan&quot;,&quot;Ethan5@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJFdGhhbjRAbS5jbw==">,&quot;Ethan4@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJFdGhhbjBAbS5jbw==">,&quot;Ethan0@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkhhbnpvJTIyLCUyMkhhbnpvM0BtLmNv">Hanzo&quot;,&quot;Hanzo3@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJIYW56bzFAbS5jbw==">,&quot;Hanzo1@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJIYW56bzBAbS5jbw==">,&quot;Hanzo0@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkZlcm4lMjIsJTIyRmVybjVAbS5jbw==">Fern&quot;,&quot;Fern5@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJGZXJuMUBtLmNv">,&quot;Fern1@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJGZXJuMEBtLmNv">,&quot;Fern0@m.co</span>&quot;]<br>
]<br>
output：<br>
[<br>
[“<span class="exturl" data-url="bWFpbHRvOkV0aGFuJTIyLCUyMkV0aGFuMEBtLmNv">Ethan&quot;,&quot;Ethan0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJFdGhhbjRAbS5jbw==">,&quot;Ethan4@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJFdGhhbjVAbS5jbw==">,&quot;Ethan5@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkdhYmUlMjIsJTIyR2FiZTBAbS5jbw==">Gabe&quot;,&quot;Gabe0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJHYWJlMUBtLmNv">,&quot;Gabe1@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJHYWJlM0BtLmNv">,&quot;Gabe3@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkhhbnpvJTIyLCUyMkhhbnpvMEBtLmNv">Hanzo&quot;,&quot;Hanzo0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJIYW56bzFAbS5jbw==">,&quot;Hanzo1@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJIYW56bzNAbS5jbw==">,&quot;Hanzo3@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOktldmluJTIyLCUyMktldmluMEBtLmNv">Kevin&quot;,&quot;Kevin0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJLZXZpbjNAbS5jbw==">,&quot;Kevin3@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJLZXZpbjVAbS5jbw==">,&quot;Kevin5@m.co</span>&quot;],<br>
[“<span class="exturl" data-url="bWFpbHRvOkZlcm4lMjIsJTIyRmVybjBAbS5jbw==">Fern&quot;,&quot;Fern0@m.co</span>”<span class="exturl" data-url="bWFpbHRvOiwlMjJGZXJuMUBtLmNv">,&quot;Fern1@m.co</span>&quot;<span class="exturl" data-url="bWFpbHRvOiwlMjJGZXJuNUBtLmNv">,&quot;Fern5@m.co</span>&quot;]<br>
]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>
<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>
<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>
<li><code>accounts[i][0]</code> （姓名）只包含英文字母。</li>
<li><code>accounts[i][j]</code> （郵件地址）是合法的 ASCII 字符串。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>可以使用 <strong>並查集 (Union-Find)</strong> 來合併擁有共同郵箱的帳戶：</p>
<ol>
<li>為每個郵箱分配一個唯一 ID，並初始化並查集結構；</li>
<li>遍歷每個帳戶內的郵箱列表，將這個帳戶中出現的所有郵箱 ID 依次 union 起來，保證同一帳戶內的所有郵箱在同一集合；</li>
<li>再次遍歷所有郵箱，對每個郵箱查找其根 ID，將郵箱聚集到  <code>root_id -&gt; list&lt;email&gt;</code>  的哈希表中；</li>
<li>最後對每個集合中的郵箱列表去重、排序，並在最前面插入對應的用戶姓名（可從最初映射  <code>email -&gt; name</code>  中獲取）；</li>
<li>收集所有合併後的帳戶列表即可。</li>
</ol>
<p>時間複雜度：O (N α(N) + M log M)，其中 N 為所有郵箱總數，α 為阿克曼函數，M 為每個集合中排序成本之和。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnionFind</span>(<span class="type">int</span> n): <span class="built_in">parent</span>(n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x) parent[x] = <span class="built_in">find</span>(parent[x]);</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rx = <span class="built_in">find</span>(x), ry = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (rx != ry) parent[ry] = rx;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">accountsMerge</span>(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        unordered_map&lt;string,<span class="type">int</span>&gt; email_to_id;</span><br><span class="line">        unordered_map&lt;string,string&gt; email_to_name;</span><br><span class="line">        <span class="type">int</span> id = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 給每個 email 分配 ID，記錄 email-&gt;name</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; acc : accounts) &#123;</span><br><span class="line">            <span class="type">const</span> string&amp; name = acc[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; acc.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="type">const</span> string&amp; email = acc[i];</span><br><span class="line">                <span class="keyword">if</span> (!email_to_id.<span class="built_in">count</span>(email)) &#123;</span><br><span class="line">                    email_to_id[email] = id++;</span><br><span class="line">                    email_to_name[email] = name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 初始化並查集</span></span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(id)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 在每個帳戶中 union 該帳戶的所有 email</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; acc : accounts) &#123;</span><br><span class="line">            <span class="type">int</span> first_id = email_to_id[acc[<span class="number">1</span>]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; acc.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                uf.<span class="built_in">unite</span>(first_id, email_to_id[acc[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 按 root 收集每個 email</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;string&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [email, eid] : email_to_id) &#123;</span><br><span class="line">            <span class="type">int</span> root = uf.<span class="built_in">find</span>(eid);</span><br><span class="line">            groups[root].<span class="built_in">push_back</span>(email);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5. 構造結果：姓名 + 排序後的 email 列表</span></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [root, emails] : groups) &#123;</span><br><span class="line">            <span class="built_in">sort</span>(emails.<span class="built_in">begin</span>(), emails.<span class="built_in">end</span>());</span><br><span class="line">            vector&lt;string&gt; account;</span><br><span class="line">            account.<span class="built_in">push_back</span>(email_to_name[emails[<span class="number">0</span>]]);</span><br><span class="line">            account.<span class="built_in">insert</span>(account.<span class="built_in">end</span>(), emails.<span class="built_in">begin</span>(), emails.<span class="built_in">end</span>());</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">move</span>(account));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (N α(N) + M log M)</p>
<ul>
<li>N 為所有郵箱數量：分配 ID、並查集操作共 O (N α(N))；對每個集合排序共計 O (M log M)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (N)</p>
<ul>
<li>需要存儲映射與並查集父陣列等結構。</li>
</ul>
</li>
</ul>
<h3 id="sort-colors"><a class="markdownIt-Anchor" href="#sort-colors">#</a> Sort Colors</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc29ydC1jb2xvcnMv">題目連結</span><br>
<strong>標籤</strong>: Array, Two Pointers<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個包含紅色、白色和藍色三種顏色的  <code>nums</code>  陣列，請原地對陣列進行排序，使相同顏色的元素相鄰，並且按紅、白、藍的順序排列。</p>
<p>我們使用整數  <code>0</code> 、 <code>1</code>  和  <code>2</code>  分別表示紅色、白色和藍色。必須在不使用庫函式排序的情況下，一趟掃描完成排序。</p>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目不需要從標準輸入讀取，也不需要將結果輸出到標準輸出，只需實作  <code>sortColors</code>  函式。<br>
Example 1</p>
<p>input：nums = [2,0,2,1,1,0]<br>
 執行後 nums 變為 [0,0,1,1,2,2]</p>
</blockquote>
<blockquote>
<p>Example 2</p>
<p>input：nums = [2,0,1]<br>
 執行後 nums 變為 [0,1,2]</p>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題常用「Dutch National Flag」三指標法，一趟掃描完成：</p>
<ul>
<li><code>p0</code>  指向下個要放  <code>0</code> （紅色） 的位置；</li>
<li><code>p2</code>  指向下個要放  <code>2</code> （藍色） 的位置；</li>
<li><code>i</code>  為當前掃描指標。</li>
</ul>
<p>演算法：</p>
<ol>
<li>初始化  <code>p0 = 0</code> ,  <code>p2 = n-1</code> ,  <code>i = 0</code> ；</li>
<li>當  <code>i &lt;= p2</code>  時：
<ul>
<li>若  <code>nums[i] == 0</code> ：交換  <code>nums[i]</code>  和  <code>nums[p0]</code> ， <code>p0++</code> ,  <code>i++</code> ；</li>
<li>否則若  <code>nums[i] == 2</code> ：交換  <code>nums[i]</code>  和  <code>nums[p2]</code> ， <code>p2--</code> ，<strong>不</strong>  <code>i++</code> （新的  <code>nums[i]</code>  需重新檢查）；</li>
<li>否則 ( <code>nums[i] == 1</code> )： <code>i++</code> ；</li>
</ul>
</li>
<li>結束後，所有  <code>0</code>  都被移到左側，所有  <code>2</code>  都被移到右側，剩下的都是  <code>1</code> （白色）。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> p0 = <span class="number">0</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[p0]);</span><br><span class="line">                p0++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[p2]);</span><br><span class="line">                p2--;</span><br><span class="line">                <span class="comment">// 注意：此處不 i++，因為交換後的 nums[i] 需重新判斷</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[i] == 1</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>單次線性掃描，i 最多移動 n 次，p2 最多移動 n 次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>原地交換，僅使用常數額外變數。</li>
</ul>
</li>
</ul>
<h2 id="week-6-99"><a class="markdownIt-Anchor" href="#week-6-99">#</a> Week 6 (9/9)</h2>
<h3 id="word-break"><a class="markdownIt-Anchor" href="#word-break">#</a> Word Break</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd29yZC1icmVhay8=">題目連結</span><br>
<strong>標籤</strong>: Dynamic Programming, String, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個非空字串  <code>s</code>  和一個包含非空單詞的字典  <code>wordDict</code> ，判斷  <code>s</code>  是否可以被空格拆分成一個或多個在字典中出現的單詞序列。</p>
<p>注意：</p>
<ul>
<li>字典中同一單詞可能會重複出現，但拆分時只能使用字典中出現過的單詞；</li>
<li>拆分時  <code>s</code>  必須完整分割，不能留下任何字符。</li>
</ul>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：s = “leetcode”, wordDict = [“leet”,“code”]<br>
output：true<br>
Explanation：可以拆分為 “leet code”。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：s = “applepenapple”, wordDict = [“apple”,“pen”]<br>
output：true<br>
Explanation：可以拆分為 “apple pen apple”。注意你可以重複使用字典中的單詞。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：s = “catsandog”, wordDict = [“cats”,“dog”,“sand”,“and”,“cat”]<br>
output：false</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 300</code></li>
<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>
<li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li>
<li><code>s</code>  和  <code>wordDict[i]</code>  皆由小寫英文字母組成。</li>
<li>字典中單詞無重複。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可使用動態規劃（DP）判斷是否可拆分：</p>
<ol>
<li>定義布林陣列  <code>dp</code> ，長度為  <code>n+1</code> （ <code>n = s.length()</code> ）， <code>dp[i]</code>  表示  <code>s[0..i-1]</code>  是否可以被拆分成字典單詞序列。</li>
<li>初始條件： <code>dp[0] = true</code> （空字串可以視作拆分成功）。</li>
<li>狀態轉移：對於每個  <code>i</code> （從  <code>1</code>  到  <code>n</code> ），嘗試所有可能的切分位置  <code>j</code> （ <code>0 &lt;= j &lt; i</code> ），若  <code>dp[j] == true</code>  且  <code>s[j..i-1]</code>  在字典中（可用  <code>unordered_set</code>  快速查詢），則  <code>dp[i] = true</code> ，並可立即  <code>break</code> 。</li>
<li>最終答案為  <code>dp[n]</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;  <span class="comment">// 空字串可拆分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; dict.<span class="built_in">count</span>(s.<span class="built_in">substr</span>(j, i - j))) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n²・k)</p>
<ul>
<li>兩層迴圈共 n (n+1)/2 次子串檢查，每次子串查詢哈希表成本約 O (k)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n + Σ|wordDict [i]|)</p>
<ul>
<li>dp 陣列佔 O (n)，哈希表儲存字典佔 O (字典中所有單詞長度總和)。</li>
</ul>
</li>
</ul>
<h3 id="partition-equal-subset-sum"><a class="markdownIt-Anchor" href="#partition-equal-subset-sum">#</a> Partition Equal Subset Sum</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcGFydGl0aW9uLWVxdWFsLXN1YnNldC1zdW0v">題目連結</span><br>
<strong>標籤</strong>: Dynamic Programming, Knapsack<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個只包含正整數的非空陣列  <code>nums</code> ，判斷是否可以將這個陣列分成兩個子集，使得兩個子集的元素和相等。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：nums = [1,5,11,5]<br>
output：true<br>
Explanation：可以分成 [1,5,5] 和 [11]，兩者和皆為 11。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：nums = [1,2,3,5]<br>
output：false<br>
Explanation：無法將陣列分成兩個和相等的子集。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：nums = [2,2,3,5]<br>
output：false</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
<li>陣列總和不超過 2×10⁴</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題實質為「從陣列中選取一部分元素，使其總和等於總和的一半」—— 典型 0/1 背包問題：</p>
<ol>
<li>首先計算陣列總和  <code>sum</code> ；若  <code>sum</code>  為奇數，則無法平分，直接返回  <code>false</code> 。</li>
<li>設目標和  <code>target = sum / 2</code> ；問題轉化為「能否從  <code>nums</code>  中選取若干元素恰好湊出  <code>target</code> 」。</li>
<li>定義布林陣列  <code>dp</code> ，長度為  <code>target+1</code> ， <code>dp[j]</code>  表示「是否存在某子集，其總和恰為  <code>j</code> 」。</li>
<li>初始條件： <code>dp[0] = true</code> （選取空集，和為 0）。</li>
<li>對於陣列中每個數字  <code>num</code> ，從  <code>j = target</code>  迴圈到  <code>num</code> ：<br>
注意要 <strong>逆序</strong> 遍歷以避免重複使用同一元素。</li>
<li>最終返回  <code>dp[target]</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) sum += x;</span><br><span class="line">        <span class="comment">// 若總和為奇數，無法平分</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp[j] = 是否能湊出和為 j</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 0/1 背包逆序遍歷</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = target; j &gt;= num; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - num]) &#123;</span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="string-to-integer-atoi"><a class="markdownIt-Anchor" href="#string-to-integer-atoi">#</a> String to Integer (atoi)</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3RyaW5nLXRvLWludGVnZXItYXRvaS8=">題目連結</span><br>
<strong>標籤</strong>: String, Simulation, Implementation<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作  <code>myAtoi(string s)</code> ，將字串  <code>s</code>  轉換成 32 位有號整數（範圍 [-2³¹, 2³¹−1]）。<br>
轉換規則如下：</p>
<ol>
<li>忽略前導空格直到遇到第一個非空格字元。</li>
<li>若遇到符號字元  <code>'+'</code>  或  <code>'-'</code> ，則記錄其正負號，否則預設為正號。</li>
<li>讀取接下來的數字字元，直到遇到非數字字元或字串結束為止。</li>
<li>將上述讀取到的數字字串轉為整數（忽略前導零），並加上符號。</li>
<li>若轉換後超出 32 位整數範圍，需截斷到相應邊界值：負溢出返回  <code>INT_MIN</code> ，正溢出返回  <code>INT_MAX</code> 。</li>
<li>若第一個非空字元即非數字且非符號，則直接返回  <code>0</code> 。</li>
</ol>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>輸入：s = “42”<br>
 輸出：42</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>輸入：s = &quot;-42&quot;<br>
 輸出：-42<br>
 解釋：忽略前三個空格後，讀到 ‘-’，再讀取數字 “42”。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>輸入：s = “4193 with words”<br>
 輸出：4193<br>
 解釋：讀取數字到空格前，遇到非數字字元終止。</p>
</blockquote>
<blockquote>
<p>Example 4:</p>
<p>輸入：s = “words and 987”<br>
 輸出：0<br>
 解釋：第一個非空字元為字母，無法轉換數字。</p>
</blockquote>
<blockquote>
<p>Example 5:</p>
<p>輸入：s = “-91283472332”<br>
 輸出：-2147483648<br>
 解釋：轉換後小於 INT_MIN，截斷為 -2^31。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code>  可能包含空格、符號字元、數字字元及其他可列印 ASCII 字符。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>按題目步驟模擬即可：</p>
<ol>
<li>使用索引  <code>i</code>  跳過前導空格（ <code>while (i &lt; n &amp;&amp; s[i] == ' ') i++;</code> ）。</li>
<li>判斷符號：若  <code>s[i] == '+'</code>  或  <code>'-'</code> ，記錄  <code>sign = ±1</code> ，並  <code>i++</code> ；否則  <code>sign = 1</code> 。</li>
<li>逐位讀取數字：
<ul>
<li>初始化  <code>long result = 0</code> 。</li>
<li>當  <code>i &lt; n &amp;&amp; isdigit(s[i])</code> ：
<ol>
<li>計算  <code>digit = s[i] - '0'</code> 。</li>
<li>在加到  <code>result</code>  前檢查溢出：
<ul>
<li>若  <code>result &gt; INT_MAX/10 || (result == INT_MAX/10 &amp;&amp; digit &gt; INT_MAX%10)</code> ，則根據  <code>sign</code>  返回  <code>INT_MAX</code>  或  <code>INT_MIN</code> 。</li>
</ul>
</li>
<li>更新  <code>result = result * 10 + digit</code> ， <code>i++</code> 。</li>
</ol>
</li>
</ul>
</li>
<li>返回  <code>(int)(sign * result)</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 1. 跳過前導空格</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>) i++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 處理符號</span></span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">-1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 逐位讀取數字並累計</span></span><br><span class="line">        <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            <span class="type">int</span> digit = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 檢查溢出</span></span><br><span class="line">            <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> ||</span><br><span class="line">               (result == INT_MAX / <span class="number">10</span> &amp;&amp; digit &gt; INT_MAX % <span class="number">10</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> sign == <span class="number">1</span> ? INT_MAX : INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            result = result * <span class="number">10</span> + digit;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(sign * result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>單次線性掃描字串長度 n。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>使用固定數量的輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="spiral-matrix"><a class="markdownIt-Anchor" href="#spiral-matrix">#</a> Spiral Matrix</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc3BpcmFsLW1hdHJpeC8=">題目連結</span><br>
<strong>標籤</strong>: Array, Simulation<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個  <code>m x n</code>  的矩陣  <code>matrix</code> ，請以螺旋（順時針）順序返回矩陣中的所有元素。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：<br>
matrix = [<br>
[ 1, 2, 3 ],<br>
[ 4, 5, 6 ],<br>
[ 7, 8, 9 ]<br>
]<br>
 輸出：[1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
matrix = [<br>
[1,  2,  3,  4],<br>
[5,  6,  7,  8],<br>
[9, 10, 11, 12]<br>
]<br>
output：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：matrix = [[1]]<br>
outupt：[1]</p>
</blockquote>
<blockquote>
<p>Example 4:</p>
<p>input：matrix = [[1],[2],[3]]<br>
output：[1,2,3]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == matrix.size()</code> ， <code>n == matrix[i].size()</code> 。</li>
<li><code>1 &lt;= m, n &lt;= 10</code> 。</li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>我們可以維護四個邊界  <code>top</code> ,  <code>bottom</code> ,  <code>left</code> ,  <code>right</code> ，初始分別為  <code>0, m-1, 0, n-1</code> ，然後不斷按「→ ↓ ← ↑」四個方向依次遍歷：</p>
<ol>
<li>從  <code>(top, left)</code>  到  <code>(top, right)</code> ，將該行元素加入結果，然後  <code>top++</code> 。</li>
<li>從  <code>(top, right)</code>  到  <code>(bottom, right)</code> ，將該列元素加入結果，然後  <code>right--</code> 。</li>
<li>若  <code>top &lt;= bottom</code> ，從  <code>(bottom, right)</code>  到  <code>(bottom, left)</code> （倒序），加入結果，然後  <code>bottom--</code> 。</li>
<li>若  <code>left &lt;= right</code> ，從  <code>(bottom, left)</code>  到  <code>(top, left)</code> （倒序），加入結果，然後  <code>left++</code> 。<br>
重複上述步驟直到  <code>top &gt; bottom</code>  或  <code>left &gt; right</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> top = <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 向右</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; j++) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(matrix[top][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 向下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= bottom; i++) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 向左</span></span><br><span class="line">            <span class="keyword">if</span> (top &lt;= bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; j--) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(matrix[bottom][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 向上</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = bottom; i &gt;= top; i--) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m × n)</p>
<ul>
<li>每個元素恰好被加入一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)（不含輸出陣列）</p>
<ul>
<li>除了輸出結果外，只使用常數級輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="binary-tree-right-side-view"><a class="markdownIt-Anchor" href="#binary-tree-right-side-view">#</a> Binary Tree Right Side View</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtcmlnaHQtc2lkZS12aWV3Lw==">題目連結</span><br>
<strong>標籤</strong>: Tree, BFS, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一棵二元樹的根節點  <code>root</code> ，請返回從樹的右側能看到的所有節點值（從頂層到底層）。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input：</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">   \   \</span><br><span class="line">    5   4</span><br></pre></td></tr></table></figure>
<p>root = [1,2,3,null,5,null,4]<br>
output：[1,3,4]<br>
Explanation：<br>
從右側看，第一層能看到 1，第二層能看到 3，第三層能看到 4。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iniput：</span><br><span class="line">    1</span><br><span class="line">   /</span><br><span class="line">  2</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>root = [1,2]<br>
output：[1,2]<br>
Explanation：<br>
第二層只有節點 2。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
input：root = []<br>
output：[]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數目範圍  <code>[0, 100]</code> 。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>可用 <strong>廣度優先搜尋 (BFS)</strong> 或 <strong>深度優先搜尋 (DFS)</strong>：</p>
<ol>
<li>
<p><strong>BFS 層序遍歷</strong>：</p>
<ul>
<li>每層遍歷時記錄當前層最後一個節點的值，即為該層從右側看到的節點。</li>
<li>使用隊列逐層掃描：對每層節點依次出隊，當到達該層最後一個出隊時，將其值加入答案。</li>
</ul>
</li>
<li>
<p><strong>DFS 右優先</strong>：</p>
<ul>
<li>先遞迴右子樹，再遞迴左子樹，同時記錄當前深度；</li>
<li>當首次到達某一深度時，該節點即為該層最右側節點，將其值加入答案。</li>
</ul>
</li>
</ol>
</blockquote>
<p>下面以 <strong>BFS</strong> 方法實現。</p>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 如果是該層最後一個節點，記錄它的值</span></span><br><span class="line">                <span class="keyword">if</span> (i == sz - <span class="number">1</span>) &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left)  q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>每個節點僅入隊 / 出隊一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>隊列最壞情況存儲整棵樹的一層節點，最多 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="longest-palindromic-substring"><a class="markdownIt-Anchor" href="#longest-palindromic-substring">#</a> Longest Palindromic Substring</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21pYy1zdWJzdHJpbmcv">題目連結</span><br>
<strong>標籤</strong>: String, Dynamic Programming, Two Pointers<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個字串  <code>s</code> ，找出其中最長的回文子串。你可以假設字串最長為 1000。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
input：s = “babad”<br>
output：“bab” 或 “aba”（兩者皆可）</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
input：s = “cbbd”<br>
output：“bb”</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
input：s = “a”<br>
output：“a”</p>
</blockquote>
<blockquote>
<p>Example 4:<br>
input：s = “ac”<br>
output：“a” 或 “c”</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code>  只包含英文字母、數字、標點符號及空格</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>常見解法有三種：</p>
<ol>
<li><strong>中心擴展 (Expand Around Center)</strong>：對每個位置  <code>i</code> ，以  <code>i</code>  為中心擴展奇數長回文；以  <code>i</code>  和  <code>i+1</code>  為中心擴展偶數長回文，記錄最長。</li>
<li><strong>動態規劃 (DP)</strong>：定義  <code>dp[i][j]</code>  表示  <code>s[i..j]</code>  是否為回文，轉移： <code>dp[i][j] = (s[i]==s[j] &amp;&amp; (j-i&lt;2 || dp[i+1][j-1]))</code> 。遍歷所有  <code>i&lt;j</code>  區間，更新最長。</li>
<li><strong>Manacher’s Algorithm</strong>（線性時間，但實作較複雜）。</li>
</ol>
<p>這裡以 <strong>中心擴展</strong> 方法實現：時間複雜度 O (n²)，程式簡潔。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> expand = [&amp;](<span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">                left--; right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此時 [left+1, right-1] 為回文</span></span><br><span class="line">            <span class="type">int</span> len = right - left - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; maxLen) &#123;</span><br><span class="line">                maxLen = len;</span><br><span class="line">                start = left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇數長回文中心在 i</span></span><br><span class="line">            <span class="built_in">expand</span>(i, i);</span><br><span class="line">            <span class="comment">// 偶數長回文中心在 i, i+1</span></span><br><span class="line">            <span class="built_in">expand</span>(i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n²)</p>
<ul>
<li>每個 i 執行兩次中心擴展，最壞每次擴展 O (n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用固定輔助變數，未開額外陣列。</li>
</ul>
</li>
</ul>
<h3 id="unique-paths"><a class="markdownIt-Anchor" href="#unique-paths">#</a> Unique Paths</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdW5pcXVlLXBhdGhzLw==">題目連結</span><br>
<strong>標籤</strong>: Dynamic Programming, Combinatorics, Grid<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>一個機器人位於一個  <code>m x n</code>  的網格左上角（起始點在  <code>(0,0)</code> ）。機器人每次只能向下或者向右移動一步。機器人試圖到達網格的右下角  <code>(m-1,n-1)</code> 。</p>
<p>請問總共有多少條不同的路徑可以到達終點？</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
input：m = 3, n = 7<br>
output：28<br>
Explanation：總共有 28 條不同路徑。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
input：m = 3, n = 2<br>
output：3<br>
Explanation：路徑為 Right-&gt;Down-&gt;Down, Down-&gt;Right-&gt;Down, Down-&gt;Down-&gt;Right。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>
input：m = 7, n = 3<br>
output：28</p>
</blockquote>
<blockquote>
<p>Example 4:<br>
input：m = 3, n = 3<br>
output：6</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>答案保證小於等於  <code>2 * 10^9</code> （符合 32 位有號整數範圍）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可視為計算機器人需要走  <code>(m-1)</code>  次 Down 與  <code>(n-1)</code>  次 Right，共  <code>m+n-2</code>  步，從中選擇其中任意  <code>m-1</code>  步向下（或選擇  <code>n-1</code>  步向右）的組合數，即</p>
</blockquote>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo fence="true">(</mo><mfrac linethickness="0px"><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\binom{m+n-2}{m-1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">(</span></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214400000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.6770000000000005em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">)</span></span></span></span></span></span></span></p>
<blockquote>
<p>也可用動態規劃：令  <code>dp[i][j]</code>  表示到達格子  <code>(i,j)</code>  的不同路徑數，則轉移方程：<br>
 <code>dp[i][j]</code>  =  <code>dp[i-1][j]</code>  +  <code>dp[i][j-1]</code></p>
<p>邊界：第一行和第一列均只有一路徑， <code>dp[0][j] = dp[i][0] = 1</code> 。</p>
<p>若只需 O (n) 空間，可用一維滾動陣列  <code>dp[j]</code> ：</p>
<ul>
<li>初始化  <code>dp[j] = 1</code> （代表第一行）；</li>
<li>遍歷每一行  <code>i</code> ，對每列  <code>j</code>  從  <code>1</code>  到  <code>n-1</code>  更新：<br>
dp[j] = dp[j] + dp[j-1];<br>
 其中  <code>dp[j]</code>  原值是上一行同列  <code>dp[i-1][j]</code> ， <code>dp[j-1]</code>  為當前行前一列  <code>dp[i][j-1]</code> 。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 一維 dp，長度為 n</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 從第二行開始，每行更新 dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最後一列 dp[n-1] 為結果</span></span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m × n)</p>
<ul>
<li>需要遍歷 m 行、n 列更新一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>使用長度為 n 的一維 dp 陣列。</li>
</ul>
</li>
</ul>
<h3 id="construct-binary-tree-from-preorder-and-inorder-traversal"><a class="markdownIt-Anchor" href="#construct-binary-tree-from-preorder-and-inorder-traversal">#</a> Construct Binary Tree from Preorder and Inorder Traversal</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29uc3RydWN0LWJpbmFyeS10cmVlLWZyb20tcHJlb3JkZXItYW5kLWlub3JkZXItdHJhdmVyc2FsLw==">題目連結</span><br>
<strong>標籤</strong>: Tree, Recursion, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定兩個整數陣列  <code>preorder</code>  和  <code>inorder</code> ，其中  <code>preorder</code>  是二元樹的先序遍歷結果， <code>inorder</code>  是同一棵樹的中序遍歷結果。請你重建這棵二元樹並返回其根節點。</p>
<p>你可以假設樹中無重複值。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
input：<br>
preorder = [3,9,20,15,7]<br>
inorder  = [9,3,15,20,7]</p>
<p>返回的二元樹為：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   / \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<p>input：<br>
preorder = [-1]<br>
inorder  = [-1]<br>
output：<br>
返回只有一個節點值 -1 的樹。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= preorder.length == inorder.length &lt;= 3000</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code>  和  <code>inorder</code>  中的值 <strong>互不相同</strong>。</li>
<li>保證  <code>inorder</code>  是樹的中序遍歷結果， <code>preorder</code>  是同一棵樹的先序遍歷結果。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>先序遍歷的第一個值一定是樹的根節點，然後在中序遍歷中找到這個根節點的位置，就能知道左子樹和右子樹的節點範圍。遞迴地對每個子區間重複同樣過程即可重建整棵樹。</p>
<ol>
<li>建立一個哈希表  <code>idx</code> ，將中序遍歷值映射到其索引，以便 O (1) 查找根在中序中的位置。</li>
<li>定義遞迴函式  <code>build(preL, preR, inL, inR)</code> ：
<ul>
<li>
<p>如果  <code>preL &gt; preR</code> ，回傳  <code>nullptr</code> （空樹）。</p>
</li>
<li>
<p>根節點值  <code>rootVal = preorder[preL]</code> ，在  <code>inorder</code>  中查到位置  <code>i = idx[rootVal]</code> 。</p>
</li>
<li>
<p>左子樹節點個數  <code>leftSize = i - inL</code> 。</p>
</li>
<li>
<p>創建節點  <code>TreeNode* root = new TreeNode(rootVal)</code> 。</p>
</li>
<li>
<p>遞迴構建：<br>
root-&gt;left  = build(preL+1, preL+leftSize, inL,     i-1);<br>
root-&gt;right = build(preL+leftSize+1, preR,   i+1, inR);</p>
</li>
<li>
<p>回傳  <code>root</code> 。</p>
</li>
</ul>
</li>
<li>初次呼叫  <code>build(0, n-1, 0, n-1)</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 建立中序值到索引的映射</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            idx[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">build</span>(preorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; idx;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; pre, <span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> inL, <span class="type">int</span> inR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> rootVal = pre[preL];</span><br><span class="line">        <span class="type">int</span> i = idx[rootVal];</span><br><span class="line">        <span class="type">int</span> leftSize = i - inL;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 構建左子樹</span></span><br><span class="line">        root-&gt;left = <span class="built_in">build</span>(pre, preL + <span class="number">1</span>, preL + leftSize,inL, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 構建右子樹</span></span><br><span class="line">        root-&gt;right = <span class="built_in">build</span>(pre, preL + leftSize + <span class="number">1</span>, preR,i + <span class="number">1</span>, inR);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>建表 O (n)，遞迴每個節點做一次常數操作。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>哈希表佔 O (n)，遞迴棧深度最壞 O (n)。</li>
</ul>
</li>
</ul>
<h2 id="week-7-77"><a class="markdownIt-Anchor" href="#week-7-77">#</a> Week 7 (7/7)</h2>
<h3 id="container-with-most-water"><a class="markdownIt-Anchor" href="#container-with-most-water">#</a> Container With Most Water</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbmVyLXdpdGgtbW9zdC13YXRlci8=">題目連結</span><br>
<strong>標籤</strong>: Two Pointers, Array<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個長度為  <code>n</code>  的非負整數陣列  <code>height</code> ，其中  <code>height[i]</code>  表示在座標  <code>(i, height[i])</code>  處有一條垂直線。從這些線中選擇兩條線與 x 軸共同構成容器，容器能裝多少水取決於兩條線之間的距離和較低那條線的高度。</p>
<p>求容器能裝水的最大面積。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>
input：height = [1,8,6,2,5,4,8,3,7]<br>
output：49<br>
Explanation：選擇下標 1 處和 8 處的兩條線，高度 min (8,7)=7，寬度 8−1=7，面積 7×7=49。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>
input：height = [1,1]<br>
output：1<br>
Explanation：唯一選擇兩條高度均為 1，寬度為 1，面積 1×1=1。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 10^5</code></li>
<li><code>0 &lt;= height[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>採用 <strong>雙指針</strong>（two pointers）技巧：</p>
<ol>
<li>左指針  <code>l</code>  設在開頭 ( <code>0</code> )，右指針  <code>r</code>  設在末尾 ( <code>n-1</code> )；</li>
<li>每次計算當前容器面積：</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>area</mtext><mo>=</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo stretchy="false">)</mo><mo>×</mo><mi>min</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>height</mtext><mo stretchy="false">[</mo><mi>l</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>height</mtext><mo stretchy="false">[</mo><mi>r</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{area} = (r - l) \times \min(\text{height}[l], \text{height}[r])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord text"><span class="mord">area</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord text"><span class="mord">height</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">height</span></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
</blockquote>
<blockquote>
<p>並更新全局最大值。<br>
3. 為了嘗試找到更高的界限，需要移動指針：</p>
<ul>
<li>若  <code>height[l] &lt; height[r]</code> ，說明左邊較低，移動左指針  <code>l++</code> ，因為移動右指針不會增大最小高度；</li>
<li>否則移動右指針  <code>r--</code> 。</li>
</ul>
<ol start="4">
<li>重複上述步驟直到  <code>l &gt;= r</code> 。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> h = <span class="built_in">min</span>(height[l], height[r]);</span><br><span class="line">            <span class="type">int</span> w = r - l;</span><br><span class="line">            max_area = <span class="built_in">max</span>(max_area, h * w);</span><br><span class="line">            <span class="comment">// 移動較低的一側指針</span></span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt; height[r]) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>指針各自最多移動 n 次，一次線性掃描完成。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>僅使用常數個輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="letter-combinations-of-a-phone-number"><a class="markdownIt-Anchor" href="#letter-combinations-of-a-phone-number">#</a> Letter Combinations of a Phone Number</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGV0dGVyLWNvbWJpbmF0aW9ucy1vZi1hLXBob25lLW51bWJlci8=">題目連結</span><br>
<strong>標籤</strong>: String, Backtracking, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個只包含數字  <code>2–9</code>  的字串  <code>digits</code> ，返回所有它能表示的字母組合。</p>
<p>對應按鍵上的字母映射如下（與電話鍵盤相同）：<br>
2: “abc”<br>
3: “def”<br>
4: “ghi”<br>
5: “jkl”<br>
6: “mno”<br>
7: “pqrs”<br>
8: “tuv”<br>
9: “wxyz”</p>
<p>由於  <code>1</code>  不對應任何字母， <code>digits</code>  中只會出現  <code>2–9</code> 。請按任意順序返回所有可能的字母組合。如果  <code>digits</code>  為空，返回空陣列  <code>[]</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：digits = “23”<br>
output：[“ad”,“ae”,“af”,“bd”,“be”,“bf”,“cd”,“ce”,“cf”]</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：digits = “”<br>
output：[]</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：digits = “2”<br>
output：[“a”,“b”,“c”]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code>  為  <code>'2'</code>  至  <code>'9'</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題典型的回溯（Backtracking）問題：</p>
<ol>
<li>建立一個映射  <code>vector&lt;string&gt; map&#123;&quot;&quot;,&quot;&quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;&#125;</code> ；</li>
<li>若輸入  <code>digits</code>  為空，直接返回空結果；</li>
<li>定義遞迴函式  <code>dfs(pos, path)</code> ：
<ul>
<li><code>pos</code>  表示當前處理到  <code>digits[pos]</code> ；</li>
<li><code>path</code>  保存已選擇的字母組合；</li>
<li>當  <code>pos == digits.length()</code>  時，將  <code>path</code>  加入結果集；</li>
<li>否則取出當前數字對應的字串  <code>letters = map[ digits[pos]-'0' ]</code> ，對其中每個字母  <code>c</code> ：
<ol>
<li>將  <code>c</code>  加入  <code>path</code> ；</li>
<li><code>dfs(pos+1, path)</code> ；</li>
<li>回溯時移除最後加入的  <code>c</code> 。</li>
</ol>
</li>
</ul>
</li>
<li>最終遍歷完所有分支即可得到全部組合。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(<span class="type">const</span> string&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> vector&lt;string&gt; mp = &#123;</span><br><span class="line">            <span class="string">&quot;&quot;</span>,    <span class="string">&quot;&quot;</span>,    <span class="string">&quot;abc&quot;</span>,  <span class="string">&quot;def&quot;</span>, </span><br><span class="line">            <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>,  <span class="string">&quot;pqrs&quot;</span>, </span><br><span class="line">            <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string path;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, path, result, mp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; digits, <span class="type">int</span> pos, </span></span></span><br><span class="line"><span class="params"><span class="function">             string&amp; path, vector&lt;string&gt;&amp; result,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">const</span> vector&lt;string&gt;&amp; mp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d = digits[pos] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">const</span> string&amp; letters = mp[d];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : letters) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="built_in">dfs</span>(digits, pos + <span class="number">1</span>, path, result, mp);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (4^n・n)</p>
<ul>
<li>每個位置最多 4 個字母（對應數字 7 或 9），共 n 位，總分支數約 4^n，每次加入結果需要複製長度為 n 的字串。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)（除結果外）</p>
<ul>
<li>遞迴深度為 n，path 長度為 n。</li>
</ul>
</li>
</ul>
<h3 id="word-search"><a class="markdownIt-Anchor" href="#word-search">#</a> Word Search</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd29yZC1zZWFyY2gv">題目連結</span><br>
<strong>標籤</strong>: Array, Backtracking, DFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由字母組成的二維字符網格  <code>board</code>  和一個字串  <code>word</code> ，請判斷  <code>word</code>  是否存在於網格中。</p>
<p>單詞必須按照字母順序，從相鄰（上下左右四個方向）格子內構成，且同一格子內的字母在一次搜尋中 <strong>只能使用一次</strong>。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：<br>
board = [<br>
[‘A’,‘B’,‘C’,‘E’],<br>
[‘S’,‘F’,‘C’,‘S’],<br>
[‘A’,‘D’,‘E’,‘E’]<br>
]<br>
word = “ABCCED”<br>
output：true<br>
Explanation：A→B→C→C→E→D 成功構成單詞。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
board = [<br>
[‘A’,‘B’,‘C’,‘E’],<br>
[‘S’,‘F’,‘C’,‘S’],<br>
[‘A’,‘D’,‘E’,‘E’]<br>
]<br>
word = “SEE”<br>
output：true<br>
Explanation：S→E→E 成功構成單詞。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：<br>
board = [<br>
[‘A’,‘B’,‘C’,‘E’],<br>
[‘S’,‘F’,‘C’,‘S’],<br>
[‘A’,‘D’,‘E’,‘E’]<br>
]<br>
word = “ABCB”<br>
output：false<br>
Explanation：無法重複使用同一格 B。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == board.size()</code> ， <code>n == board[i].size()</code> 。</li>
<li><code>1 &lt;= m, n &lt;= 6</code></li>
<li><code>1 &lt;= word.length &lt;= 15</code></li>
<li><code>board[i][j]</code>  和  <code>word</code>  均為大寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>使用 <strong>回溯（Backtracking）+ 深度優先搜尋（DFS）</strong>：</p>
<ol>
<li>遍歷網格的每個起點  <code>(i,j)</code> ，若  <code>board[i][j] == word[0]</code> ，從此啟動 DFS；</li>
<li>在 DFS 中維護當前匹配的  <code>index</code> （對應  <code>word[index]</code> ），以及標記當前格子是否已訪問；</li>
<li>若  <code>index == word.length()</code>  時，表示已完整匹配，返回  <code>true</code> ；</li>
<li>否則從當前格子出發，對四個方向  <code>(dx,dy)</code> ：
<ul>
<li>新座標  <code>(nx,ny)</code>  在範圍內、未訪問，且  <code>board[nx][ny] == word[index]</code> ，則標記訪問、遞迴  <code>dfs(nx,ny,index+1)</code> ；</li>
<li>若子遞迴返回  <code>true</code> ，則一路返回  <code>true</code> ；否則回溯，將格子標記未訪問；</li>
</ul>
</li>
<li>若所有方向均無法匹配，返回  <code>false</code> 。</li>
</ol>
<p>外層對所有  <code>(i,j)</code>  嘗試起點，若任一  <code>dfs</code>  成功，則最終返回  <code>true</code> ；否則返回  <code>false</code> 。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> string&amp; word)</span> </span>&#123;</span><br><span class="line">        m = board.<span class="built_in">size</span>();</span><br><span class="line">        n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        visited.<span class="built_in">assign</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; visited;</span><br><span class="line">    <span class="comment">// 四個方向：上、下、左、右</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">const</span> string&amp; word,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == word.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 越界或字母不符或已訪問</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n ||</span><br><span class="line">            visited[x][y] || board[x][y] != word[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == word.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> dir = <span class="number">0</span>; dir &lt; <span class="number">4</span>; dir++) &#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dx[dir], ny = y + dy[dir];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dfs</span>(board, word, nx, ny, index + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[x][y] = <span class="literal">false</span>;  <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (m・n・4^L)</p>
<ul>
<li>m×n 個起點，每次 DFS 最壞沿長度 L（word.length ()）探索 4 種方向。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (m・n + L)</p>
<ul>
<li>visited 陣列 O (m・n)，遞迴棧深度最壞 O (L)。</li>
</ul>
</li>
</ul>
<h3 id="find-all-anagrams-in-a-string"><a class="markdownIt-Anchor" href="#find-all-anagrams-in-a-string">#</a> Find All Anagrams in a String</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmluZC1hbGwtYW5hZ3JhbXMtaW4tYS1zdHJpbmcv">題目連結</span><br>
<strong>標籤</strong>: String, Sliding Window, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定兩個字串  <code>s</code>  和  <code>p</code> ，找出  <code>s</code>  中所有  <code>p</code>  的字母異位詞（anagram）出現的起始索引。返回所有起始索引的列表，順序不限。</p>
<p>字母異位詞指字母相同但順序不同的字串。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：s = “cbaebabacd”, p = “abc”<br>
output：[0,6]<br>
Explanation：</p>
<ul>
<li>索引 0 處子串 “cba” 是 “abc” 的異位詞。</li>
<li>索引 6 處子串 “bac” 是 “abc” 的異位詞。</li>
</ul>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：s = “abab”, p = “ab”<br>
output：[0,1,2]<br>
Explanation：</p>
<ul>
<li>索引 0 處 “ab”</li>
<li>索引 1 處 “ba”</li>
<li>索引 2 處 “ab”</li>
</ul>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length, p.length &lt;= 3×10^4</code></li>
<li><code>s</code>  和  <code>p</code>  只包含小寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可用 <strong>滑動視窗</strong>（sliding window）+ <strong>頻次計數</strong>：</p>
<ol>
<li>準備兩個大小 26 的整數陣列  <code>cntP</code> 、 <code>cntS</code> ，分別記錄  <code>p</code>  和當前窗口內  <code>s</code>  的字母頻次。</li>
<li>先統計  <code>p</code>  中每個字母的頻次到  <code>cntP</code> ；窗口右界  <code>r</code>  從  <code>0</code>  遍歷到  <code>s.size()-1</code> ，將  <code>s[r]</code>  加入  <code>cntS</code> 。</li>
<li>當窗口長度大於  <code>p.size()</code>  時，窗口左界  <code>l</code>  也要右移：將  <code>s[l]</code>  從  <code>cntS</code>  減去，然後  <code>l++</code> 。</li>
<li>每次當窗口長度等於  <code>p.size()</code> ，比較  <code>cntS</code>  和  <code>cntP</code>  是否相等，若相等就將當前  <code>l</code>  加入答案。</li>
<li>最後返回所有符合條件的起始索引。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cntP</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">cntS</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, res</span>;</span><br><span class="line">        <span class="comment">// 統計 p 的頻次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p) &#123;</span><br><span class="line">            cntP[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">            <span class="comment">// 窗口右移：加入 s[r]</span></span><br><span class="line">            cntS[s[r] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="comment">// 若窗口大於 m，左移窗口並移除 s[l]</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; m) &#123;</span><br><span class="line">                cntS[s[l] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 當窗口長度正好為 m，檢查是否為異位詞</span></span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> == m &amp;&amp; cntS == cntP) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n * 26) ≈ O (n)</p>
<ul>
<li>窗口滑動共 O (n) 步，每步比較長度 26 的陣列。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用固定大小的兩個長度為 26 的頻次陣列和結果向量。</li>
</ul>
</li>
</ul>
<h3 id="minimum-height-trees"><a class="markdownIt-Anchor" href="#minimum-height-trees">#</a> Minimum Height Trees</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS1oZWlnaHQtdHJlZXMv">題目連結</span><br>
<strong>標籤</strong>: Graph, BFS, Topological Sort<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個有  <code>n</code>  個節點的樹（無向連通無環圖），節點編號從  <code>0</code>  到  <code>n-1</code> 。再給一個長度為  <code>n-1</code>  的邊列表  <code>edges</code> ，其中  <code>edges[i] = [u_i, v_i]</code>  表示在節點  <code>u_i</code>  和  <code>v_i</code>  之間有一條無向邊。</p>
<p>對於這棵樹，選擇一個節點作為根，樹的高度定義為從根到最遠葉節點的距離。請找出所有能使樹高度 <strong>最小</strong> 的節點，即返回所有 <strong>最小高度樹</strong> 的根節點列表。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：n = 4, edges = [[1,0],[1,2],[1,3]]<br>
output：[1]<br>
Explanation：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 0</span><br><span class="line">  |</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br></pre></td></tr></table></figure>
<p>將 1 作為根，高度為 1，是最小可能。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]]<br>
output：[3,4]<br>
Explanation：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0   1   2</span><br><span class="line">  \  |  /</span><br><span class="line">     3</span><br><span class="line">     |</span><br><span class="line">     4</span><br><span class="line">     |</span><br><span class="line">     5</span><br></pre></td></tr></table></figure>
<p>對根為 3 或 4，高度都為 3，均為最小。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= n &lt;= 2 * 10^4</code></li>
<li><code>edges.length == n - 1</code></li>
<li><code>0 &lt;= u_i, v_i &lt; n</code></li>
<li><code>所有邊互不相同，圖為一棵樹</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可視為「求樹的重心（centroid）」。對於樹，最小高度根必定出現在 1 或 2 個重心上。可以透過 <strong>拓撲排序類似</strong> 的方式，<strong>從葉節點開始逐層剝除</strong>，最後剩下的 1～2 個節點即為答案：</p>
<ol>
<li>構建鄰接表與度數陣列  <code>degree[i]</code> ；</li>
<li>將所有度數為 1（葉節點）的節點入隊  <code>queue&lt;int&gt; leaves</code> ；</li>
<li>當剩餘節點數  <code>remaining &gt; 2</code>  時：
<ul>
<li>令  <code>size = leaves.size()</code> ， <code>remaining -= size</code> ；</li>
<li>處理這一批葉節點：對每個  <code>u</code> ，遍歷其相鄰節點  <code>v</code> ，將  <code>degree[v]--</code> ，若  <code>degree[v] == 1</code> ，則把  <code>v</code>  推入新一輪  <code>leaves</code> ；</li>
</ul>
</li>
<li>最後隊列中剩下的節點即為所有最小高度樹的根。</li>
</ol>
<p>時間複雜度 O (n)，空間 O (n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">adj</span>(n);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">degree</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span><br><span class="line">            <span class="type">int</span> u = e[<span class="number">0</span>], v = e[<span class="number">1</span>];</span><br><span class="line">            adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            adj[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">            degree[u]++;</span><br><span class="line">            degree[v]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; leaves;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (degree[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                leaves.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> remaining = n;</span><br><span class="line">        <span class="keyword">while</span> (remaining &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sz = leaves.<span class="built_in">size</span>();</span><br><span class="line">            remaining -= sz;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">int</span> u = leaves.<span class="built_in">front</span>(); leaves.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : adj[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--degree[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                        leaves.<span class="built_in">push</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (!leaves.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(leaves.<span class="built_in">front</span>());</span><br><span class="line">            leaves.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>建構鄰接表 O (n)，每條邊、每個節點只訪問常數次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>鄰接表、度數陣列及佇列均為 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="task-scheduler"><a class="markdownIt-Anchor" href="#task-scheduler">#</a> Task Scheduler</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdGFzay1zY2hlZHVsZXIv">題目連結</span><br>
<strong>標籤</strong>: Greedy, Heap, Simulation<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 20 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由大寫字母 A–Z 組成的任務陣列  <code>tasks</code> ，每個任務代表必須執行的一個工作。CPU 執行這些任務需要按照陣列順序，但在任意兩個相同任務之間必須間隔至少  <code>n</code>  個時間單位，在這段間隔內可以執行其他任務或保持空閒（idle）。</p>
<p>返回完成所有任務所需的最少時間單位數。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：tasks = [“A”,“A”,“A”,“B”,“B”,“B”], n = 2<br>
output：8<br>
Explanation：一種可行排程為 A → B → idle → A → B → idle → A → B，共 8 個時間單位。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：tasks = [“A”,“A”,“A”,“B”,“B”,“B”], n = 0<br>
output：6<br>
Explanation：不需要冷卻時間，直接連續執行所有任務即可。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：tasks = [“A”,“A”,“A”,“A”,“A”,“A”,“B”,“C”,“D”,“E”,“F”,“G”], n = 2<br>
output：16<br>
Explanation：可行排程為<br>
 A → B → C → A → D → E → A → F → G → A → idle → idle → A → idle → idle → A<br>
 總共 16 個時間單位。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= tasks.length &lt;= 10^4</code></li>
<li><code>tasks[i]</code>  是大寫字母  <code>A</code> – <code>Z</code></li>
<li><code>0 &lt;= n &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以使用 <strong>貪心 + 最大堆</strong>：</p>
<ol>
<li>統計每個任務（字母）的出現次數，放入一個最大堆（priority_queue），每次取出當前剩餘次數最多的任務執行；</li>
<li>在一個「時間區間」內最多可以執行  <code>n+1</code>  個任務（或者任務 + idle），我們從堆中最多取出  <code>n+1</code>  個不同任務依次執行，並將它們的剩餘次數減一後暫存；</li>
<li>完成這個區間後，將暫存還剩餘次數的任務再推回堆中，累加時間為取出的任務數或  <code>n+1</code> （如果堆已空且暫存也空，則最後一輪不需要補 idle）；</li>
<li>重複直到堆空。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">leastInterval</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; tasks, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        array&lt;<span class="type">int</span>,26&gt; cnt = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tasks) cnt[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : cnt) <span class="keyword">if</span> (x &gt; <span class="number">0</span>) pq.<span class="built_in">push</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 暫存當前區間取出的任務剩餘次數</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="type">int</span> k = n + <span class="number">1</span>;  <span class="comment">// 一個區間最多執行 n+1 個</span></span><br><span class="line">            <span class="comment">// 在一個區間內取出最多 n+1 個任務</span></span><br><span class="line">            <span class="keyword">while</span> (k-- &gt; <span class="number">0</span> &amp;&amp; !pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> x = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 執行一次，剩餘次數減一</span></span><br><span class="line">                <span class="keyword">if</span> (--x &gt; <span class="number">0</span>) temp.<span class="built_in">push_back</span>(x);</span><br><span class="line">                time++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 把暫存剩餘的任務重新放回堆中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> x : temp) pq.<span class="built_in">push</span>(x);</span><br><span class="line">            <span class="comment">// 如果堆已空，最後一輪不需要補 idle</span></span><br><span class="line">            <span class="keyword">if</span> (pq.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否則補足整個區間（包含 idle）</span></span><br><span class="line">            time += k + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (T log 26) ≈ O (T)，其中 T 為 tasks.length，因為最多有 26 種任務，每次堆操作為 log26 常數。</p>
</li>
<li>
<p>空間複雜度：O (26) ≈ O (1)，使用固定大小的計數陣列和堆。</p>
</li>
</ul>
<h3 id="lru-cache"><a class="markdownIt-Anchor" href="#lru-cache">#</a> LRU Cache</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbHJ1LWNhY2hlLw==">題目連結</span><br>
<strong>標籤</strong>: Design, Hash Table, Linked List<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作一個 <strong>最近最少使用</strong>（LRU，Least Recently Used）快取結構  <code>LRUCache</code> ，支援以下兩個操作：</p>
<ol>
<li><code>get(key)</code> ：如果鍵存在於快取中，返回其對應的值，並將該鍵設為「最近使用」。否則返回  <code>-1</code> 。</li>
<li><code>put(key, value)</code> ：如果鍵已存在，更新其值並設為「最近使用」。如果鍵不存在，插入該鍵值對；若插入後快取容量超過預設的  <code>capacity</code> ，則移除最久未使用的鍵值對。</li>
</ol>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目只需實作類別接口，不需從標準輸入輸出讀取資料。</p>
<p>input：<br>
[“LRUCache”,“put”,“put”,“get”,“put”,“get”,“put”,“get”,“get”,“get”]<br>
[[2],[1,1],[2,2],[1],[3,3],[2],[4,4],[1],[3],[4]]</p>
<p>output：<br>
[null,null,null,1,null,-1,null,-1,3,4]</p>
<p>Explanation：<br>
LRUCache cache = new LRUCache(2);<br>
cache.put(1, 1); // {1=1}<br>
cache.put(2, 2); // {1=1,2=2}<br>
 cache.get (1);    // 返回 1，cache 更新為 {2=2,1=1}<br>
 cache.put (3, 3); // 插入 3，容量溢出，移除最久未使用的 key=2，cache={1=1,3=3}<br>
 cache.get (2);    // 返回 -1（未找到）<br>
cache.put (4, 4); // 插入 4，移除最久未使用的 key=1，cache={3=3,4=4}<br>
 cache.get (1);    // 返回 -1<br>
cache.get (3);    // 返回 3<br>
cache.get (4);    // 返回 4</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= capacity &lt;= 3000</code></li>
<li><code>0 &lt;= key, value &lt;= 10^4</code></li>
<li>每次  <code>get</code>  和  <code>put</code>  操作的次數總合在  <code>[1, 3×10^4]</code>  範圍內。</li>
<li>要求  <code>get</code>  和  <code>put</code>  操作的平均時間複雜度為 O (1)。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>為了在 O (1) 時間內同時完成插入、查找並維護「最近使用」順序，我們結合 <strong>哈希表</strong> 和 <strong>雙向鏈表</strong>：</p>
<ol>
<li><strong>哈希表 ( <code>unordered_map&lt;int, Node*&gt;</code> )</strong>：
<ul>
<li>Key → 指向雙向鏈表節點的指標，用於 O (1) 查找節點。</li>
</ul>
</li>
<li><strong>雙向鏈表</strong>：
<ul>
<li>節點包含  <code>(key, value)</code> 。</li>
<li>新使用或更新的節點移到表頭；最久未使用的節點位於表尾。</li>
<li>當容量超限時，刪除表尾節點並從哈希表移除其對應條目。</li>
</ul>
</li>
</ol>
<p><code>get(key)</code>  流程：</p>
<ul>
<li>如果哈希表中無該鍵，返回 -1。</li>
<li>否則取出節點，移到表頭，返回該節點的 value。</li>
</ul>
<p><code>put(key, value)</code>  流程：</p>
<ul>
<li>如果哈希表中已有該鍵，更新節點的 value，並移到表頭。</li>
<li>否則：
<ol>
<li>若當前大小已達  <code>capacity</code> ，先刪除鏈表尾節點並從哈希表刪除該鍵；</li>
<li>建立新節點  <code>(key,value)</code> ，插入表頭，並在哈希表中添加映射。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, value;</span><br><span class="line">    Node* prev;</span><br><span class="line">    Node* next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> k, <span class="type">int</span> v): <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity): <span class="built_in">cap</span>(capacity) &#123;</span><br><span class="line">        <span class="comment">// 建立虛擬頭尾節點</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(key) == mp.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        Node* node = mp[key];</span><br><span class="line">        <span class="comment">// 移動到表頭</span></span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">insertToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mp.<span class="built_in">find</span>(key) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 更新並移到表頭</span></span><br><span class="line">            Node* node = mp[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">remove</span>(node);</span><br><span class="line">            <span class="built_in">insertToHead</span>(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">size</span>() == cap) &#123;</span><br><span class="line">                <span class="comment">// 刪除最久未使用的節點（表尾前一個）</span></span><br><span class="line">                Node* del = tail-&gt;prev;</span><br><span class="line">                <span class="built_in">remove</span>(del);</span><br><span class="line">                mp.<span class="built_in">erase</span>(del-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> del;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入新節點到表頭</span></span><br><span class="line">            Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">insertToHead</span>(node);</span><br><span class="line">            mp[key] = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LRUCache</span>() &#123;</span><br><span class="line">        <span class="comment">// 清理所有節點</span></span><br><span class="line">        Node* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            Node* nxt = cur-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; mp;</span><br><span class="line">    Node* head;</span><br><span class="line">    Node* tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將節點從當前位置移除</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入節點到表頭（head 之後）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertToHead</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：</p>
<ul>
<li>get 與 put 均為 O (1)（哈希表查找 + 雙向鏈表節點操作）。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (capacity)</p>
<ul>
<li>哈希表與雙向鏈表共存儲最多 capacity 個節點。</li>
</ul>
</li>
</ul>
<h2 id="week-8-88"><a class="markdownIt-Anchor" href="#week-8-88">#</a> Week 8 (8/8)</h2>
<h3 id="kth-smallest-element-in-a-bst"><a class="markdownIt-Anchor" href="#kth-smallest-element-in-a-bst">#</a> Kth Smallest Element in a BST</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMva3RoLXNtYWxsZXN0LWVsZW1lbnQtaW4tYS1ic3Qv">題目連結</span><br>
<strong>標籤</strong>: Tree, Depth-First Search (DFS), Binary Search Tree<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Medium<br>
<strong> 解題時間</strong>: 15 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一棵二元搜尋樹（BST）的根節點  <code>root</code> ，以及一個整數  <code>k</code> ，請你找出並返回這棵樹中第  <code>k</code>  小的元素值。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：root = [3,1,4,null,2], k = 1</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">1   4</span><br><span class="line"> \</span><br><span class="line">  2  </span><br></pre></td></tr></table></figure>
<p>output：1<br>
Explanation：按升序遍歷，節點值序列為 [1,2,3,4]，第 1 小為 1。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：root = [5,3,6,2,4,null,null,1], k = 3</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">   / \</span><br><span class="line">  2   4</span><br><span class="line"> /</span><br><span class="line">1  </span><br></pre></td></tr></table></figure>
<p>output：3<br>
Explanation：升序序列 [1,2,3,4,5,6]，第 3 小為 3。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數量  <code>n</code>  的範圍為  <code>[1, 10^4]</code> 。</li>
<li><code>1 &lt;= k &lt;= n</code> 。</li>
<li>節點值互不相同。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>BST 的中序遍歷剛好能按升序訪問所有節點。</p>
<ul>
<li>方法一（遞迴）：對樹做中序遍歷，計數到第  <code>k</code>  次訪問時記錄結果並提前終止。</li>
<li>方法二（迭代 + 類似遞迴棧）：用一個顯式堆疊從根開始，先一路往左壓入節點，然後每次彈出一個節點就是當前最小，計數減一，當  <code>k==0</code>  時該節點即為答案；接著轉向該節點的右子樹重複同樣過程。</li>
</ul>
</blockquote>
<p>下面以 <strong>迭代版中序遍歷</strong> 實現（常用，無需額外遞迴棧）：</p>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        std::stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* node = root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代中序：先把最左路徑壓入堆疊</span></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(node);</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重複「訪問+右子樹」</span></span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            node = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">// 第 k 小</span></span><br><span class="line">            <span class="keyword">if</span> (--k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有右子樹，將右子樹的最左路徑壓入</span></span><br><span class="line">            TreeNode* right = node-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (right) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(right);</span><br><span class="line">                right = right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 理論上不會到這裡，因為 1 &lt;= k &lt;= n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (h + k)，其中 h 是樹的高度。</p>
<ul>
<li>最壞情況下，需要沿左子樹走到最深（h 步），再訪問 k 個節點，每步為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (h)，用於堆疊儲存當前節點路徑。</p>
</li>
</ul>
<h3 id="minimum-window-substring"><a class="markdownIt-Anchor" href="#minimum-window-substring">#</a> Minimum Window Substring</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWluaW11bS13aW5kb3ctc3Vic3RyaW5nLw==">題目連結</span><br>
<strong>標籤</strong>: String, Sliding Window, Hash Table<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個字串  <code>s</code>  和一個字串  <code>t</code> ，請在  <code>s</code>  中找出包含  <code>t</code>  中所有字符的最小子串（子串中字符出現次數至少等於在  <code>t</code>  中的次數）。如果不存在這樣的子串，返回空字串  <code>&quot;&quot;</code> 。</p>
<p>例如， <code>s = &quot;ADOBECODEBANC&quot;</code> ， <code>t = &quot;ABC&quot;</code> ，最小覆蓋子串為  <code>&quot;BANC&quot;</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：s = “ADOBECODEBANC”, t = “ABC”<br>
output：“BANC”</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：s = “a”, t = “a”<br>
output：“a”</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：s = “a”, t = “aa”<br>
output：&quot;&quot;<br>
Explanation：t 中有兩個 ‘a’，但 s 中只有一個。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 10^5</code></li>
<li><code>s</code>  和  <code>t</code>  由英文字母、數字和其他可列印 ASCII 字符組成。</li>
<li>可能有多個最小子串，返回任何一個即可。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>使用 <strong>滑動視窗</strong>（two-pointer + 哈希表）技巧：</p>
<ol>
<li>用一個長度 128 或 256 的整數陣列  <code>need</code>  記錄  <code>t</code>  中每個字符所需的頻次，另一個陣列  <code>window</code>  記錄當前滑動視窗內字符頻次。</li>
<li>右指標  <code>r</code>  遍歷  <code>s</code> ，將  <code>s[r]</code>  加入  <code>window</code> ，若該字符在  <code>need</code>  中有需求且  <code>window[c] &lt;= need[c]</code> ，則計數  <code>formed++</code> 。</li>
<li>當  <code>formed == required</code> （已滿足 t 中所有字符需求）時，嘗試縮小左指標  <code>l</code> ：
<ul>
<li>更新當前最小子串長度與起始位置；</li>
<li>將  <code>s[l]</code>  從  <code>window</code>  減去，若它在  <code>need</code>  中且  <code>window[c] &lt; need[c]</code> ，則  <code>formed--</code> ，停止收縮。</li>
<li><code>l++</code> ，繼續下一輪收縮。</li>
</ul>
</li>
<li>重複上述過程直到  <code>r</code>  遍歷結束。最終根據記錄的最小長度返回子串。</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">need</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span>, <span class="title">window</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) need[c]++;</span><br><span class="line">        <span class="type">int</span> required = t.<span class="built_in">size</span>(), formed = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, minLen = INT_MAX, minStart = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[r];</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span> &amp;&amp; window[c] &lt;= need[c]) &#123;</span><br><span class="line">                formed++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 當滑動視窗已覆蓋所有需要字符，嘗試收縮左邊界</span></span><br><span class="line">            <span class="keyword">while</span> (formed == required) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = r - l + <span class="number">1</span>;</span><br><span class="line">                    minStart = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> d = s[l];</span><br><span class="line">                window[d]--;</span><br><span class="line">                <span class="keyword">if</span> (need[d] &gt; <span class="number">0</span> &amp;&amp; window[d] &lt; need[d]) &#123;</span><br><span class="line">                    formed--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minLen == INT_MAX </span><br><span class="line">            ? <span class="string">&quot;&quot;</span> </span><br><span class="line">            : s.<span class="built_in">substr</span>(minStart, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (|s| + |t|)</p>
<ul>
<li>右指標和左指標各掃描 s 一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>使用固定大小的頻次陣列與常數輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="serialize-and-deserialize-binary-tree"><a class="markdownIt-Anchor" href="#serialize-and-deserialize-binary-tree">#</a> Serialize and Deserialize Binary Tree</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvc2VyaWFsaXplLWFuZC1kZXNlcmlhbGl6ZS1iaW5hcnktdHJlZS8=">題目連結</span><br>
<strong>標籤</strong>: Tree, Design, DFS, BFS<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 30 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>設計一種方法，將二元樹序列化為字串，再能夠從該字串反序列化（恢復）出原來的二元樹。</p>
<p>你需要實現兩個函式：</p>
<ol>
<li><code>string serialize(TreeNode* root)</code> ：將樹編碼為一個字串。</li>
<li><code>TreeNode* deserialize(const string&amp; data)</code> ：將字串解碼為原來的樹結構。</li>
</ol>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example:</p>
<p>input：root = [1,2,3,null,null,4,5]<br>
 output：與輸入相同的樹結構<br>
 Explanation：<br>
序列化可以得到 “1,2,null,null,3,4,null,null,5,null,null,”（先序帶 null 標記）<br>
反序列化後恢復成原來結構。</p>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>常見方法是對樹做 <strong>先序遍歷</strong>，遇到空節點用特殊標記（如  <code>#</code>  或  <code>null</code> ）寫入字串，同時用分隔符（如  <code>,</code> ）分開節點值。</p>
<ul>
<li>
<p><strong>序列化 ( <code>serialize</code> )</strong>：</p>
<ol>
<li>遞迴函式  <code>dfs(node, out)</code> ：
<ul>
<li>若  <code>node</code>  為  <code>nullptr</code> ，輸出  <code>&quot;#, &quot;</code> ；</li>
<li>否則輸出  <code>to_string(node-&gt;val) + &quot;,&quot;</code> ，然後  <code>dfs(node-&gt;left)</code> 、 <code>dfs(node-&gt;right)</code> 。</li>
</ul>
</li>
<li>返回最終拼接的字串。</li>
</ol>
</li>
<li>
<p><strong>反序列化 ( <code>deserialize</code> )</strong>：</p>
<ol>
<li>將輸入字串按  <code>,</code>  分隔成一個隊列或索引序列。</li>
<li>遞迴函式  <code>build()</code> ：
<ul>
<li>取出下一個 token，若為  <code>#</code>  或  <code>null</code> ，返回  <code>nullptr</code> ；</li>
<li>否則轉為整數值，創建節點  <code>TreeNode* node</code> ，然後  <code>node-&gt;left = build()</code> 、 <code>node-&gt;right = build()</code> ，最後返回  <code>node</code> 。</li>
</ul>
</li>
</ol>
</li>
</ul>
</blockquote>
<p>這種方案的優點是簡單直觀，序列化長度 O (n)，反序列化時間 O (n)。</p>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 將樹序列化為字串</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string out;</span><br><span class="line">        <span class="built_in">dfs_serialize</span>(root, out);</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 將字串反序列化為樹</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="type">const</span> string&amp; data)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; tokens = <span class="built_in">split</span>(data, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs_deserialize</span>(tokens);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 先序遍歷序列化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs_serialize</span><span class="params">(TreeNode* node, string&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            out += <span class="string">&quot;#,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        out += <span class="built_in">to_string</span>(node-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="built_in">dfs_serialize</span>(node-&gt;left, out);</span><br><span class="line">        <span class="built_in">dfs_serialize</span>(node-&gt;right, out);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 從 token 隊列中構建樹</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs_deserialize</span><span class="params">(queue&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tokens.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        string t = tokens.<span class="built_in">front</span>(); tokens.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&quot;#&quot;</span> || t == <span class="string">&quot;null&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(t));</span><br><span class="line">        node-&gt;left  = <span class="built_in">dfs_deserialize</span>(tokens);</span><br><span class="line">        node-&gt;right = <span class="built_in">dfs_deserialize</span>(tokens);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 將序列化字串按分隔符切分為隊列</span></span><br><span class="line">    <span class="function">queue&lt;string&gt; <span class="title">split</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">char</span> delim)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        string token;</span><br><span class="line">        <span class="function">istringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, token, delim)) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>序列化時 DFS 訪問每個節點一次；反序列化時從 token 隊列重建，每個 token 處理一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>序列化結果字串長度 O (n)，反序列化時 token 隊列和遞迴棧均最壞 O (n)。</li>
</ul>
</li>
</ul>
<h3 id="trapping-rain-water"><a class="markdownIt-Anchor" href="#trapping-rain-water">#</a> Trapping Rain Water</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHJhcHBpbmctcmFpbi13YXRlci8=">題目連結</span><br>
<strong>標籤</strong>: Array, Two Pointers, Stack, Dynamic Programming<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個非負整數陣列  <code>height</code> ，代表柱子的高度圖，寬度皆為 1。計算在下雨後，這些柱子之間能夠接多少雨水。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>
output：6<br>
Explanation：如上圖所示，共能接 6 單位的雨水。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：height = [4,2,0,3,2,5]<br>
output：9<br>
Explanation：能接 9 單位的雨水。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>n == height.size()</code></li>
<li><code>1 &lt;= n &lt;= 2×10^5</code></li>
<li><code>0 &lt;= height[i] &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>常見三種方法：</p>
<ol>
<li>
<p><strong>雙指針</strong>（Two Pointers）</p>
<ul>
<li>初始化  <code>l=0, r=n-1</code> ，並維護左右最高  <code>leftMax</code> 、 <code>rightMax</code> ；</li>
<li>每次比較  <code>height[l]</code>  與  <code>height[r]</code> ，移動指向較低一側的指針並累積  <code>(maxSoFar - height[current])</code> 。</li>
<li>時間 O (n)，空間 O (1)。</li>
</ul>
</li>
<li>
<p><strong>動態規劃</strong>（DP）</p>
<ul>
<li>預先計算  <code>leftMax[i]</code>  和  <code>rightMax[i]</code> ，表示位置  <code>i</code>  左右兩邊最高柱子；</li>
<li>雨水量為  <code>sum( min(leftMax[i], rightMax[i]) - height[i] )</code> 。</li>
<li>時間 O (n)，空間 O (n)。</li>
</ul>
</li>
<li>
<p><strong>單調棧</strong>（Monotonic Stack）</p>
<ul>
<li>用棧存下標，維護從棧底到棧頂的柱高遞減；</li>
<li>當遇到更高柱子時，不斷從棧頂彈出並計算與新柱子形成的容積。</li>
<li>時間 O (n)，空間 O (n)。</li>
</ul>
</li>
</ol>
</blockquote>
<p>以下以 <strong>雙指針</strong> 方法實現：</p>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> water = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[l] &lt;= height[r]) &#123;</span><br><span class="line">                <span class="comment">// 左側較低，水量由左邊決定</span></span><br><span class="line">                <span class="keyword">if</span> (height[l] &gt;= leftMax) &#123;</span><br><span class="line">                    leftMax = height[l];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += leftMax - height[l];</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右側較低，水量由右邊決定</span></span><br><span class="line">                <span class="keyword">if</span> (height[r] &gt;= rightMax) &#123;</span><br><span class="line">                    rightMax = height[r];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    water += rightMax - height[r];</span><br><span class="line">                &#125;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> water;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>雙指針一次線性掃描。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (1)</p>
<ul>
<li>只使用常數額外空間存放指針和最大值。</li>
</ul>
</li>
</ul>
<h3 id="find-median-from-data-stream"><a class="markdownIt-Anchor" href="#find-median-from-data-stream">#</a> Find Median from Data Stream</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmluZC1tZWRpYW4tZnJvbS1kYXRhLXN0cmVhbS8=">題目連結</span><br>
<strong>標籤</strong>: Design, Heap, Data Stream<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作一個資料結構，支援兩個操作：</p>
<ol>
<li><code>void addNum(int num)</code> ：從資料流中新增一個數字  <code>num</code> 。</li>
<li><code>double findMedian()</code> ：回傳目前所有數字的中位數。</li>
</ol>
<ul>
<li>如果資料總數為奇數，中位數為中間那個數；</li>
<li>如果為偶數，中位數為中間兩數的平均值。</li>
</ul>
</blockquote>
<p><strong>輸入／輸出 範例</strong></p>
<blockquote>
<p>注意：題目只需實作類別介面，不需從標準輸入／輸出讀取資料。</p>
<p>input：<br>
[“MedianFinder”,“addNum”,“addNum”,“findMedian”,“addNum”,“findMedian”]<br>
[[],[1],[2],[],[3],[]]<br>
output：<br>
[null,null,null,1.00000,null,2.00000]</p>
<p><strong>說明</strong>：</p>
<ol>
<li><code>MedianFinder mf = new MedianFinder();</code>  →  <code>null</code></li>
<li><code>mf.addNum(1);</code>                 →  <code>null</code></li>
<li><code>mf.addNum(2);</code>                 →  <code>null</code></li>
<li><code>mf.findMedian();</code>              →  <code>1.0</code>   （中位數為  <code>(1+2)/2</code> ）</li>
<li><code>mf.addNum(3);</code>                 →  <code>null</code></li>
<li><code>mf.findMedian();</code>              →  <code>2.0</code>   （中位數為  <code>2</code> ）</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>調用  <code>addNum</code>  和  <code>findMedian</code>  的次數總和不超過  <code>10^5</code> 。</li>
<li>數字範圍在 32 位有號整數。</li>
<li>期望  <code>addNum</code>  與  <code>findMedian</code>  均為 O (log n)（或更好）時間複雜度。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>我們維護兩個堆：</p>
<ul>
<li><strong>最大堆</strong>  <code>maxHeap</code>  存較小一半的數字；</li>
<li><strong>最小堆</strong>  <code>minHeap</code>  存較大一半的數字。</li>
</ul>
<p>保持兩堆大小差不超過 1，並且  <code>maxHeap.top() &lt;= minHeap.top()</code> 。</p>
<ul>
<li>
<p>新增數字時：</p>
<ol>
<li>若  <code>maxHeap</code>  為空或  <code>num &lt;= maxHeap.top()</code> ，推到  <code>maxHeap</code> ，否則推到  <code>minHeap</code> 。</li>
<li>調整兩堆大小：若某堆元素比另一堆多 2 個，將堆頂移到另一堆。</li>
</ol>
</li>
<li>
<p>求中位數時：</p>
<ul>
<li>如果兩堆大小相同，則中位數為  <code>(maxHeap.top() + minHeap.top()) / 2.0</code> ；</li>
<li>否則，中位數為元素多的那一堆的堆頂。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先推入適當的堆</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">empty</span>() || num &lt;= maxHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 調整大小，保持兩堆大小差 &lt;= 1</span></span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() &gt; minHeap.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">            minHeap.<span class="built_in">push</span>(maxHeap.<span class="built_in">top</span>());</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minHeap.<span class="built_in">size</span>() &gt; maxHeap.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(minHeap.<span class="built_in">top</span>());</span><br><span class="line">            minHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() == minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxHeap.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">return</span> (maxHeap.<span class="built_in">top</span>() + minHeap.<span class="built_in">top</span>()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.<span class="built_in">size</span>() &gt; minHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> minHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; maxHeap;                <span class="comment">// 最大堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt;&gt; minHeap;  <span class="comment">// 最小堆</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：</p>
<ul>
<li>
<p><code>addNum</code> ：O (log n)（堆插入與 rebalance）；</p>
</li>
<li>
<p><code>findMedian</code> ：O(1)。</p>
</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>需儲存所有已加入的數字。</li>
</ul>
</li>
</ul>
<h3 id="word-ladder"><a class="markdownIt-Anchor" href="#word-ladder">#</a> Word Ladder</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvd29yZC1sYWRkZXIv">題目連結</span><br>
<strong>標籤</strong>: Breadth-First Search (BFS), Graph, String<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定兩個字串  <code>beginWord</code>  和  <code>endWord</code> ，以及一個字典列表  <code>wordList</code> ，請找出從  <code>beginWord</code>  變換到  <code>endWord</code>  的最短序列長度。</p>
<p>每次變換只能改變一個字母，且變換後的字串必須在字典中出現。</p>
<p>如果不存在這樣的變換序列，返回  <code>0</code> 。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：<br>
beginWord = “hit”,<br>
endWord   = “cog”,<br>
wordList  = [“hot”,“dot”,“dog”,“lot”,“log”,“cog”]<br>
output：5<br>
Explanation：一種最短變換序列為<br>
 “hit” → “hot” → “dot” → “dog” → “cog”<br>
 序列長度為 5。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
beginWord = “hit”,<br>
endWord   = “cog”,<br>
wordList  = [“hot”,“dot”,“dog”,“lot”,“log”]<br>
output：0<br>
Explanation：字典中不包含 “cog”，無法完成變換。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= beginWord.length == endWord.length &lt;= 10</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li>所有字串均只包含小寫英文字母。</li>
<li><code>beginWord != endWord</code> 。</li>
<li>字典中無重複單詞。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>將每個字串視為圖中的一個節點，若兩個字串相差一個字母，則在它們之間連一條無向邊。問題即為在這個無權圖上求從  <code>beginWord</code>  到  <code>endWord</code>  的最短路徑長度，適合用 <strong>廣度優先搜尋 (BFS)</strong>：</p>
<ol>
<li>將  <code>beginWord</code>  放入隊列，並用  <code>visited</code>  哈希表標記已訪問；</li>
<li>每一層 BFS 對當前字串取出，嘗試對每一個位置  <code>i</code> ，將該位置字母從  <code>'a'</code>  到  <code>'z'</code>  試所有可能新字串  <code>next</code> ；</li>
<li>如果  <code>next</code>  在字典中且未訪問，則標記訪問並入隊；</li>
<li>每進一層，步數加一，一旦遇到  <code>endWord</code> ，即可返回當前層數；</li>
<li>BFS 結束後仍未找到，返回  <code>0</code> 。</li>
</ol>
<p>為了快速判定一個新字串是否在字典中，預先將  <code>wordList</code>  插入  <code>unordered_set&lt;string&gt;</code> 。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ladderLength</span><span class="params">(<span class="type">const</span> string&amp; beginWord,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> string&amp; endWord,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">dict</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!dict.<span class="built_in">count</span>(endWord)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(beginWord);</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        visited.<span class="built_in">insert</span>(beginWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> steps = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span> (sz--) &#123;</span><br><span class="line">                string cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (cur == endWord) <span class="keyword">return</span> steps;</span><br><span class="line">                <span class="comment">// 對每個位置嘗試改變</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cur.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                    <span class="type">char</span> orig = cur[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        cur[i] = c;</span><br><span class="line">                        <span class="keyword">if</span> (dict.<span class="built_in">count</span>(cur) &amp;&amp; !visited.<span class="built_in">count</span>(cur)) &#123;</span><br><span class="line">                            visited.<span class="built_in">insert</span>(cur);</span><br><span class="line">                            q.<span class="built_in">push</span>(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cur[i] = orig;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (N・L・26)</p>
<ul>
<li>N 為字典大小，L 為單詞長度；BFS 最壞遍歷每個單詞一次，每次生成 L×26 個鄰居，判定與訪問均為 O (1)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (N・L)</p>
<ul>
<li>存儲字典與訪問狀態需要 O (N・L) 空間。</li>
</ul>
</li>
</ul>
<h3 id="basic-calculator"><a class="markdownIt-Anchor" href="#basic-calculator">#</a> Basic Calculator</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmFzaWMtY2FsY3VsYXRvci8=">題目連結</span><br>
<strong>標籤</strong>: String, Stack, Simulation<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>實作一個計算器，能夠計算包含以下內容的字串表達式  <code>s</code> ：</p>
<ol>
<li>非負整數</li>
<li>加法  <code>+</code> 、減法  <code>-</code></li>
<li>左右括號  <code>(</code> ,  <code>)</code></li>
<li>空白格子（忽略）</li>
</ol>
<p>你可以假設輸入表達式已經合法，計算結果會在 32 位有號整數範圍內，且不使用內建的  <code>eval</code>  或者類似函式。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">輸入：s = &quot;1 + 1&quot;</span><br><span class="line">輸出：2</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">Example 2:  </span><br><span class="line">```text</span><br><span class="line">輸入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">輸出：3</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">Example 3:  </span><br><span class="line">```text</span><br><span class="line">輸入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">輸出：23</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">Example 4:  </span><br><span class="line">```text</span><br><span class="line">輸入：s = &quot;- (3 + (2 - 1))&quot;</span><br><span class="line">輸出：-4</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**限制**</span><br><span class="line"></span><br><span class="line">- `1 &lt;= s.length &lt;= 3×10^5`  </span><br><span class="line">- `s` 由數字、`&#x27;+&#x27;`、`&#x27;-&#x27;`、`&#x27;(&#x27;`、`&#x27;)&#x27;` 和空格組成。  </span><br><span class="line">- 輸入表達式保證合法，最終結果在 32 位整數範圍內。</span><br><span class="line"></span><br><span class="line">**思路**</span><br><span class="line"></span><br><span class="line">使用**棧**來處理括號和當前符號狀態：  </span><br><span class="line">1. 遍歷字串，遇到數字就累積成當前操作數 `num`；  </span><br><span class="line">2. 遇到 `+` 或 `-` 或到達字串尾，將前一個操作數（帶符號）累加到結果 `res` 中，更新符號 `sign = +1 或 -1`，重置 `num = 0`；  </span><br><span class="line">3. 遇到 `(`，將當前結果 `res` 和符號 `sign` 推入棧中，重置 `res = 0, sign = +1`；  </span><br><span class="line">4. 遇到 `)`，先把當前 `num` 加入 `res`，然後從棧中彈出上一層的 `sign_prev`，再從棧中彈出 `res_prev`，計算 `res = res_prev + sign_prev * res`，重置 `num = 0`；  </span><br><span class="line">5. 最後遍歷結束後，將最後一個 `num` 加到 `res`。</span><br><span class="line"></span><br><span class="line">**程式碼**</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">   int calculate(const string&amp; s) &#123;</span><br><span class="line">       long res = 0, num = 0;</span><br><span class="line">       int sign = 1;  // +1 或 -1</span><br><span class="line">       stack&lt;long&gt; stk; // 存放 res 和 sign</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; s.size(); i++) &#123;</span><br><span class="line">           char c = s[i];</span><br><span class="line">           if (isdigit(c)) &#123;</span><br><span class="line">               num = num * 10 + (c - &#x27;0&#x27;);</span><br><span class="line">           &#125; else if (c == &#x27;+&#x27; || c == &#x27;-&#x27;) &#123;</span><br><span class="line">               res += sign * num;</span><br><span class="line">               num = 0;</span><br><span class="line">               sign = (c == &#x27;+&#x27;) ? 1 : -1;</span><br><span class="line">           &#125; else if (c == &#x27;(&#x27;) &#123;</span><br><span class="line">               // 推入當前結果和符號，進入新一層</span><br><span class="line">               stk.push(res);</span><br><span class="line">               stk.push(sign);</span><br><span class="line">               res = 0;</span><br><span class="line">               sign = 1;</span><br><span class="line">           &#125; else if (c == &#x27;)&#x27;) &#123;</span><br><span class="line">               res += sign * num;</span><br><span class="line">               num = 0;</span><br><span class="line">               // 彈出上一層符號與結果</span><br><span class="line">               long prevSign = stk.top(); stk.pop();</span><br><span class="line">               long prevRes  = stk.top(); stk.pop();</span><br><span class="line">               res = prevRes + prevSign * res;</span><br><span class="line">           &#125;</span><br><span class="line">           // 遇到空格則跳過</span><br><span class="line">       &#125;</span><br><span class="line">       // 處理最後一個數字</span><br><span class="line">       res += sign * num;</span><br><span class="line">       return (int)res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>單次線性掃描字串長度 n，每步操作均為常數。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>棧最壞情況儲存所有括號對對應的兩個值。</li>
</ul>
</li>
</ul>
<h3 id="maximum-profit-in-job-scheduling"><a class="markdownIt-Anchor" href="#maximum-profit-in-job-scheduling">#</a> Maximum Profit in Job Scheduling</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1wcm9maXQtaW4tam9iLXNjaGVkdWxpbmcv">題目連結</span><br>
<strong>標籤</strong>: Array, Dynamic Programming, Binary Search<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 30 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定三個等長陣列  <code>startTime</code> ,  <code>endTime</code> ,  <code>profit</code> ，代表有  <code>n</code>  個工作，第  <code>i</code>  個工作在時間區間<br>
 <code>[startTime[i], endTime[i])</code> （前閉後開）執行，完成可獲得  <code>profit[i]</code> 。</p>
<p>你最多只能同一時間執行一個工作（工作之間不能重疊）。求在合理安排工作的前提下，所能獲得的最大總利潤。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：<br>
startTime = [1,2,3,3],<br>
endTime   = [3,4,5,6],<br>
profit    = [50,10,40,70]<br>
output：120<br>
Explanation：<br>
排程可選擇工作 0（時間 [1,3)、利潤 50）和工作 3（時間 [3,6)、利潤 70），總利潤 120。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：<br>
startTime = [1,2,3,4,6],<br>
endTime   = [3,5,10,6,9],<br>
profit    = [20,20,100,70,60]<br>
output：150<br>
Explanation：<br>
最佳排程為工作 0 ([1,3)、20)、工作 3 ([4,6)、70)、工作 2 ([3,10)、100) 中選兩個互不衝突的最大組合，<br>
可選工作 2 本身利潤就是 100，再加工作 3 的 70，但因 [3,10) 與 [4,6) 衝突，故最佳是工作 2 (100) + 工作 0 (20) + 工作 4 (60) = 180?<br>
 實際最佳為工作 2 (100) + 工作 4 (60) = 160。但因範例答案 150，排程應為工作 0+3+4 合法組合為 20+70+60 = 150。</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：<br>
startTime = [1,1,1],<br>
endTime   = [2,3,4],<br>
profit    = [5,6,4]<br>
output：6</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= n == startTime.length == endTime.length == profit.length &lt;= 5×10^4</code></li>
<li><code>1 &lt;= startTime[i] &lt; endTime[i] &lt;= 10^9</code></li>
<li><code>1 &lt;= profit[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>先將所有工作按照結束時間  <code>endTime</code>  升序排序。記  <code>jobs[i] = (end, start, profit)</code> 。</p>
<p>定義動態規劃陣列  <code>dp[i]</code> ：表示考慮前  <code>i</code>  個（排序後）工作，能獲得的最大利潤。</p>
<p>遍歷每個工作  <code>i</code> ：</p>
<ol>
<li>二分搜尋最後一個結束時間  <code>&lt;= start_i</code>  的工作索引  <code>j</code> （在  <code>[0..i-1]</code>  中）。</li>
<li>選擇「接第  <code>i</code>  個工作」時可累加  <code>dp[j+1] + profit_i</code> （ <code>dp</code>  用 1-based， <code>dp[0]=0</code> ）；不選第  <code>i</code>  個則為  <code>dp[i]</code> 。</li>
<li><code>dp[i+1] = max(dp[i], dp[j+1] + profit_i)</code> 。</li>
</ol>
<p>最終答案為  <code>dp[n]</code> 。</p>
<ul>
<li>排序花 O (n log n)。</li>
<li>對每個工作做一次二分搜尋 O (log n)，總 O (n log n)。</li>
<li>空間 O (n)。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jobScheduling</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; startTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="type">int</span>&gt;&amp; endTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                      vector&lt;<span class="type">int</span>&gt;&amp; profit)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = startTime.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 組合並排序</span></span><br><span class="line">        vector&lt;tuple&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">int</span>&gt;&gt; jobs;</span><br><span class="line">        jobs.<span class="built_in">reserve</span>(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            jobs.<span class="built_in">emplace_back</span>(endTime[i], startTime[i], profit[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(jobs.<span class="built_in">begin</span>(), jobs.<span class="built_in">end</span>());  <span class="comment">// 按 endTime 升序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i] 表示前 i 個工作（jobs[0..i-1]）的最優利潤</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 結束時間陣列，用於二分</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ends</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ends[i] = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(jobs[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> end_i, start_i, prof_i;</span><br><span class="line">            <span class="built_in">tie</span>(end_i, start_i, prof_i) = jobs[i];</span><br><span class="line">            <span class="comment">// 找到最右側 j 使 ends[j] &lt;= start_i</span></span><br><span class="line">            <span class="type">int</span> j = <span class="built_in">int</span>(<span class="built_in">upper_bound</span>(ends.<span class="built_in">begin</span>(), ends.<span class="built_in">end</span>(), start_i) - ends.<span class="built_in">begin</span>()) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> includeProfit = prof_i + (j &gt;= <span class="number">0</span> ? dp[j<span class="number">+1</span>] : <span class="number">0</span>);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> excludeProfit = dp[i];</span><br><span class="line">            dp[i<span class="number">+1</span>] = <span class="built_in">max</span>(excludeProfit, includeProfit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(dp[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n log n)</p>
<ul>
<li>排序 O (n log n)，每個工作二分搜尋 O (log n)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>需要儲存排序後的工作列表、dp 陣列與結束時間陣列。</li>
</ul>
</li>
</ul>
<h3 id="merge-k-sorted-lists"><a class="markdownIt-Anchor" href="#merge-k-sorted-lists">#</a> Merge k Sorted Lists</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2Utay1zb3J0ZWQtbGlzdHMv">題目連結</span><br>
<strong>標籤</strong>: Heap, Linked List, Divide and Conquer<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個包含  <code>k</code>  個已排序的鏈表陣列  <code>lists</code> ，將它們合併為一個排序好的鏈表並返回。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：lists = [[1,4,5],[1,3,4],[2,6]]<br>
output：[1,1,2,3,4,4,5,6]<br>
 Explanation：三個鏈表合併後為 1→1→2→3→4→4→5→6。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：lists = []<br>
output：[]</p>
</blockquote>
<blockquote>
<p>Example 3:</p>
<p>input：lists = [[]]<br>
output：[]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>k == lists.length</code></li>
<li><code>0 &lt;= k &lt;= 10^4</code></li>
<li><code>0 &lt;= lists[i].length &lt;= 500</code></li>
<li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li>
<li><code>lists[i]</code>  按升序排列</li>
<li>所有鏈表總節點數不超過 10^4</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>常見兩種做法：</p>
<ol>
<li><strong>最小堆 (Priority Queue)</strong>
<ul>
<li>遍歷每個鏈表的頭節點，將其值與節點指針放入最小堆；</li>
<li>每次從堆中彈出最小節點，接到結果鏈表尾，再將該節點的下一個節點入堆；</li>
<li>重複直到堆空。</li>
</ul>
</li>
<li><strong>分治合併 (Divide and Conquer)</strong>
<ul>
<li>將 k 個鏈表兩兩合併，形成 k/2 個，重複此過程直到合併為一個；</li>
<li>使用「合併兩個已排序鏈表」的線性時間方法。</li>
</ul>
</li>
</ol>
<p>第一種方法時間複雜度 O (N log k)，第二種也為 O (N log k)，其中 N 為所有節點總數。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x): <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小根堆，存 pair&lt;節點值, 節點指針&gt;</span></span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode* a, ListNode* b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">pq</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始將每個鏈表頭 push 進堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) pq.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虛擬頭節點</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span>, *tail </span>= &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">            tail-&gt;next = node;</span><br><span class="line">            tail = tail-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next) pq.<span class="built_in">push</span>(node-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (N log k)</p>
<ul>
<li>每個節點進堆與出堆各一次，堆大小最多為 k，故為 O (N log k)。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (k)</p>
<ul>
<li>最小堆最多存放 k 個節點指針。</li>
</ul>
</li>
</ul>
<h3 id="largest-rectangle-in-histogram"><a class="markdownIt-Anchor" href="#largest-rectangle-in-histogram">#</a> Largest Rectangle in Histogram</h3>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGFyZ2VzdC1yZWN0YW5nbGUtaW4taGlzdG9ncmFtLw==">題目連結</span><br>
<strong>標籤</strong>: Stack, Array, Monotonic Stack<br>
<strong> 語言</strong>: C++<br>
<strong> 難度</strong>: Hard<br>
<strong> 解題時間</strong>: 25 分鐘</p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列  <code>heights</code> ，其中每個元素代表寬度為 1 的直方圖柱子的高度，請找出能夠形成的最大長方形面積。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:</p>
<p>input：heights = [2,1,5,6,2,3]<br>
output：10<br>
Expllanation：最大長方形由高度 5 和 6 組成，寬度 2，面積 5×2=10。</p>
</blockquote>
<blockquote>
<p>Example 2:</p>
<p>input：heights = [2,4]<br>
output：4<br>
Explanation：最大長方形由高度 4，寬度 1，面積 4。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= heights.length &lt;= 10^5</code></li>
<li><code>0 &lt;= heights[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>使用 <strong>單調棧</strong>（Monotonic Stack）維護遞增高度：</p>
<ol>
<li>在  <code>heights</code>  末尾加上  <code>0</code>  作為哨兵，保證最後可將棧中所有柱子彈出處理；</li>
<li>迭代  <code>i</code>  從  <code>0</code>  到  <code>n</code> ：
<ul>
<li>當前高度  <code>h = heights[i]</code> ；</li>
<li>若棧為空或  <code>h &gt;= heights[stk.top()]</code> ，則將  <code>i</code>  推入棧；</li>
<li>否則，反覆彈出棧頂  <code>top</code> ，計算以  <code>heights[top]</code>  為高度的最大寬度：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">height = heights[top];</span><br><span class="line">width  = stk.<span class="built_in">empty</span>() ? i : (i - stk.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">area   = height * width;</span><br></pre></td></tr></table></figure>
更新全局最大面積後，繼續比較新的棧頂直到  <code>h &gt;= heights[stk.top()]</code> ，最後再把  <code>i</code>  推入。</li>
</ul>
</li>
</ol>
<p>這樣每個索引最多進棧和出棧一次，時間複雜度 O (n)，空間複雜度 O (n)。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) h[i] = heights[i];</span><br><span class="line">        h[n] = <span class="number">0</span>;  <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() &amp;&amp; h[i] &lt; h[stk.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> height = h[stk.<span class="built_in">top</span>()];</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> width = stk.<span class="built_in">empty</span>() ? i : (i - stk.<span class="built_in">top</span>() - <span class="number">1</span>);</span><br><span class="line">                maxArea = <span class="built_in">max</span>(maxArea, height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>
<p>時間複雜度：O (n)</p>
<ul>
<li>每個索引至多進棧與出棧一次。</li>
</ul>
</li>
<li>
<p>空間複雜度：O (n)</p>
<ul>
<li>單調棧最壞情況存儲所有索引。</li>
</ul>
</li>
</ul>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2025-06-21 08:12:09" itemprop="dateModified" datetime="2025-06-21T08:12:09+08:00">2025-06-21</time>
  </span>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>品逸 <i class="ic i-at"><em>@</em></i>Joseph's Blog
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://localhost:4000/grind75/index.html" title="LeetCode Grind 75">http://localhost:4000/grind75/index.html</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9odHRwczovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMtc2EvNC4wL2xlZ2FsY29kZS56aC10dw=="><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#grind-75"><span class="toc-number">1.</span> <span class="toc-text"> Grind 75</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#week-1-1313"><span class="toc-number">1.1.</span> <span class="toc-text"> Week 1 (13&#x2F;13)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#two-sum"><span class="toc-number">1.1.1.</span> <span class="toc-text"> Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#valid-parentheses"><span class="toc-number">1.1.2.</span> <span class="toc-text"> Valid Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-two-sorted-lists"><span class="toc-number">1.1.3.</span> <span class="toc-text"> Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#best-time-to-buy-and-sell-stock"><span class="toc-number">1.1.4.</span> <span class="toc-text"> Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#valid-palindrome"><span class="toc-number">1.1.5.</span> <span class="toc-text"> Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invert-binary-tree"><span class="toc-number">1.1.6.</span> <span class="toc-text"> Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#valid-anagram"><span class="toc-number">1.1.7.</span> <span class="toc-text"> Valid Anagram</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binary-search"><span class="toc-number">1.1.8.</span> <span class="toc-text"> Binary Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flood-fill"><span class="toc-number">1.1.9.</span> <span class="toc-text"> Flood Fill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lowest-common-ancestor-of-a-binary-search-tree"><span class="toc-number">1.1.10.</span> <span class="toc-text"> Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#balanced-binary-tree"><span class="toc-number">1.1.11.</span> <span class="toc-text"> Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linked-list-cycle"><span class="toc-number">1.1.12.</span> <span class="toc-text"> Linked List Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implement-queue-using-stacks"><span class="toc-number">1.1.13.</span> <span class="toc-text"> Implement Queue using Stacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-2-1212"><span class="toc-number">1.2.</span> <span class="toc-text"> Week 2 (12&#x2F;12)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#first-bad-version"><span class="toc-number">1.2.1.</span> <span class="toc-text"> First Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ransom-note"><span class="toc-number">1.2.2.</span> <span class="toc-text"> Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#climbing-stairs"><span class="toc-number">1.2.3.</span> <span class="toc-text"> Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longest-palindrome"><span class="toc-number">1.2.4.</span> <span class="toc-text"> Longest Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse-linked-list"><span class="toc-number">1.2.5.</span> <span class="toc-text"> Reverse Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#majority-element"><span class="toc-number">1.2.6.</span> <span class="toc-text"> Majority Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-binary"><span class="toc-number">1.2.7.</span> <span class="toc-text"> Add Binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diameter-of-binary-tree"><span class="toc-number">1.2.8.</span> <span class="toc-text"> Diameter of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#middle-of-the-linked-list"><span class="toc-number">1.2.9.</span> <span class="toc-text"> Middle of the Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maximum-depth-of-binary-tree"><span class="toc-number">1.2.10.</span> <span class="toc-text"> Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#contains-duplicate"><span class="toc-number">1.2.11.</span> <span class="toc-text"> Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maximum-subarray"><span class="toc-number">1.2.12.</span> <span class="toc-text"> Maximum Subarray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-3-88"><span class="toc-number">1.3.</span> <span class="toc-text"> Week 3 (8&#x2F;8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-interval"><span class="toc-number">1.3.1.</span> <span class="toc-text"> Insert Interval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-matrix"><span class="toc-number">1.3.2.</span> <span class="toc-text"> 01 Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k-closest-points-to-origin"><span class="toc-number">1.3.3.</span> <span class="toc-text"> K Closest Points to Origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longest-substring-without-repeating-characters"><span class="toc-number">1.3.4.</span> <span class="toc-text"> Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3sum"><span class="toc-number">1.3.5.</span> <span class="toc-text"> 3Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binary-tree-level-order-traversal"><span class="toc-number">1.3.6.</span> <span class="toc-text"> Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone-graph"><span class="toc-number">1.3.7.</span> <span class="toc-text"> Clone Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#evaluate-reverse-polish-notation"><span class="toc-number">1.3.8.</span> <span class="toc-text"> Evaluate Reverse Polish Notation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-4-88"><span class="toc-number">1.4.</span> <span class="toc-text"> Week 4 (8&#x2F;8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#course-schedule"><span class="toc-number">1.4.1.</span> <span class="toc-text"> Course Schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#implement-trie-prefix-tree"><span class="toc-number">1.4.2.</span> <span class="toc-text"> Implement Trie (Prefix Tree)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#coin-change"><span class="toc-number">1.4.3.</span> <span class="toc-text"> Coin Change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#product-of-array-except-self"><span class="toc-number">1.4.4.</span> <span class="toc-text"> Product of Array Except Self</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-stack"><span class="toc-number">1.4.5.</span> <span class="toc-text"> Min Stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#validate-binary-search-tree"><span class="toc-number">1.4.6.</span> <span class="toc-text"> Validate Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#number-of-islands"><span class="toc-number">1.4.7.</span> <span class="toc-text"> Number of Islands</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rotting-oranges"><span class="toc-number">1.4.8.</span> <span class="toc-text"> Rotting Oranges</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-5-88"><span class="toc-number">1.5.</span> <span class="toc-text"> Week 5 (8&#x2F;8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#search-in-rotated-sorted-array"><span class="toc-number">1.5.1.</span> <span class="toc-text"> Search in Rotated Sorted Array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#combination-sum"><span class="toc-number">1.5.2.</span> <span class="toc-text"> Combination Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#permutations"><span class="toc-number">1.5.3.</span> <span class="toc-text"> Permutations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-intervals"><span class="toc-number">1.5.4.</span> <span class="toc-text"> Merge Intervals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lowest-common-ancestor-of-a-binary-tree"><span class="toc-number">1.5.5.</span> <span class="toc-text"> Lowest Common Ancestor of a Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-based-key-value-store"><span class="toc-number">1.5.6.</span> <span class="toc-text"> Time Based Key-Value Store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accounts-merge"><span class="toc-number">1.5.7.</span> <span class="toc-text"> Accounts Merge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-colors"><span class="toc-number">1.5.8.</span> <span class="toc-text"> Sort Colors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-6-99"><span class="toc-number">1.6.</span> <span class="toc-text"> Week 6 (9&#x2F;9)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#word-break"><span class="toc-number">1.6.1.</span> <span class="toc-text"> Word Break</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#partition-equal-subset-sum"><span class="toc-number">1.6.2.</span> <span class="toc-text"> Partition Equal Subset Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-to-integer-atoi"><span class="toc-number">1.6.3.</span> <span class="toc-text"> String to Integer (atoi)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spiral-matrix"><span class="toc-number">1.6.4.</span> <span class="toc-text"> Spiral Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#binary-tree-right-side-view"><span class="toc-number">1.6.5.</span> <span class="toc-text"> Binary Tree Right Side View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longest-palindromic-substring"><span class="toc-number">1.6.6.</span> <span class="toc-text"> Longest Palindromic Substring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-paths"><span class="toc-number">1.6.7.</span> <span class="toc-text"> Unique Paths</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#construct-binary-tree-from-preorder-and-inorder-traversal"><span class="toc-number">1.6.8.</span> <span class="toc-text"> Construct Binary Tree from Preorder and Inorder Traversal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-7-77"><span class="toc-number">1.7.</span> <span class="toc-text"> Week 7 (7&#x2F;7)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#container-with-most-water"><span class="toc-number">1.7.1.</span> <span class="toc-text"> Container With Most Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#letter-combinations-of-a-phone-number"><span class="toc-number">1.7.2.</span> <span class="toc-text"> Letter Combinations of a Phone Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#word-search"><span class="toc-number">1.7.3.</span> <span class="toc-text"> Word Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-all-anagrams-in-a-string"><span class="toc-number">1.7.4.</span> <span class="toc-text"> Find All Anagrams in a String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minimum-height-trees"><span class="toc-number">1.7.5.</span> <span class="toc-text"> Minimum Height Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#task-scheduler"><span class="toc-number">1.7.6.</span> <span class="toc-text"> Task Scheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lru-cache"><span class="toc-number">1.7.7.</span> <span class="toc-text"> LRU Cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#week-8-88"><span class="toc-number">1.8.</span> <span class="toc-text"> Week 8 (8&#x2F;8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kth-smallest-element-in-a-bst"><span class="toc-number">1.8.1.</span> <span class="toc-text"> Kth Smallest Element in a BST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#minimum-window-substring"><span class="toc-number">1.8.2.</span> <span class="toc-text"> Minimum Window Substring</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serialize-and-deserialize-binary-tree"><span class="toc-number">1.8.3.</span> <span class="toc-text"> Serialize and Deserialize Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trapping-rain-water"><span class="toc-number">1.8.4.</span> <span class="toc-text"> Trapping Rain Water</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-median-from-data-stream"><span class="toc-number">1.8.5.</span> <span class="toc-text"> Find Median from Data Stream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#word-ladder"><span class="toc-number">1.8.6.</span> <span class="toc-text"> Word Ladder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#basic-calculator"><span class="toc-number">1.8.7.</span> <span class="toc-text"> Basic Calculator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#maximum-profit-in-job-scheduling"><span class="toc-number">1.8.8.</span> <span class="toc-text"> Maximum Profit in Job Scheduling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge-k-sorted-lists"><span class="toc-number">1.8.9.</span> <span class="toc-text"> Merge k Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largest-rectangle-in-histogram"><span class="toc-number">1.8.10.</span> <span class="toc-text"> Largest Rectangle in Histogram</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="品逸"
      data-src="/website/images/avatar.jpg">
  <p class="name" itemprop="name">品逸</p>
  <div class="description" itemprop="description">品逸的網站</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/website/archives/">
        <span class="count">1</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/website/categories/">
        <span class="count">1</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/website/tags/">
        <span class="count">1</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2pqampvc2VwaA==" title="https:&#x2F;&#x2F;github.com&#x2F;jjjjoseph"><i class="ic i-github"></i></span>
      <span class="exturl item instagram" data-url="aHR0cHM6Ly93d3cuaW5zdGFncmFtLmNvbS9oc2pvc2VwaF8wMzE3Lw==" title="https:&#x2F;&#x2F;www.instagram.com&#x2F;hsjoseph_0317&#x2F;"><i class="ic i-instagram"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/website/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/website/grind75/" rel="section"><i class="ic i-book"></i>grind75</a>
  </li>

    
  <li class="item">
    <a href="/website/archives/" rel="section"><i class="ic i-archive"></i>Archives</a>
  </li>

    
  <li class="item">
    <a href="/website/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

    
  <li class="item">
    <a href="/website/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/website/categories/uncategorized/" title="In uncategorized">uncategorized</a>
</div>

    <span><a href="/website/2025/05/31/hello-world/" title="Hello World">Hello World</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">品逸 @ Hi~~</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'grind75/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/website/js/app.js?v=0.2.5"></script>




</body>
</html>
