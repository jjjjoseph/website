



<!DOCTYPE html>
<html lang="zh-tw">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/website/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/website/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Joseph's Blog" href="http://localhost:4000/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Joseph's Blog" href="http://localhost:4000/atom.xml" />
<link rel="alternate" type="application/json" title="Joseph's Blog" href="http://localhost:4000/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/website/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://localhost:4000/grind75/">



  <title>LeetCode Grind 75 |
Hi~~ = Joseph's Blog</title>
<meta name="generator" content="Hexo 7.3.0"><link rel="stylesheet" href="/website/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/website/css/prism-line-numbers.css" type="text/css"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">LeetCode Grind 75
  </h1>

          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="ナビゲーションバーの切り替え">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/website/" rel="start">Hi~~</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm0fdw5cj20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicm07ih54j20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipew8gmvyj20zk0m87wh.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipet4bz0yj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gicliierfjj20zk0m8npd.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="page wrap">
    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-tw">
  <link itemprop="mainEntityOfPage" href="http://localhost:4000/grind75/index.html">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/website/images/avatar.jpg">
    <meta itemprop="name" content="品逸">
    <meta itemprop="description" content=", 使用 Hexo + Shoka 架設的靜態網站">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Joseph's Blog">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="Grind-75"><a href="#Grind-75" class="headerlink" title="Grind 75"></a>Grind 75</h1><blockquote>
<p>Grind 75 是 Leetcode 推出的刷題路線，適合給準備面試的同學。</p>
</blockquote>
<h2 id="Week-1-13-13"><a href="#Week-1-13-13" class="headerlink" title="Week 1 (13&#x2F;13)"></a>Week 1 (13&#x2F;13)</h2><h3 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdHdvLXN1bS8=">題目連結</span><br><strong>標籤</strong>: Array, Hash Table<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.  </p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.  </p>
<p>You can return the answer in any order.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: nums &#x3D; [2,7,11,15], target &#x3D; 9<br>Output: [0,1]<br>Explanation: Because nums[0] + nums[1] &#x3D;&#x3D; 9, we return [0, 1].  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: nums &#x3D; [3,2,4], target &#x3D; 6<br>Output: [1,2]  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: nums &#x3D; [3,3], target &#x3D; 6<br>Output: [0,1]  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4  </li>
<li>-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9  </li>
<li>-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9  </li>
<li>只有一個有效答案</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>用 Hash Map 儲存已經看過的數字及其 index  </li>
<li>遍歷陣列，對於每個數字 <code>nums[i]</code>，檢查 <code>target - nums[i]</code> 是否已經在 map 裡  </li>
<li>如果有，回傳 <code>&#123; map[補數], i &#125;</code>  </li>
<li>否則把 <code>nums[i]</code> 加進 map</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">const</span> <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; num_to_complement_idx; <span class="comment">// 儲存「補數 → 索引」</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 遍歷 nums 陣列</span></span><br><span class="line">            <span class="keyword">auto</span> it = num_to_complement_idx.<span class="built_in">find</span>(nums[i]); <span class="comment">// 查找當前值是否為之前存的補數</span></span><br><span class="line">            <span class="keyword">if</span> (it != num_to_complement_idx.<span class="built_in">end</span>()) &#123;       <span class="comment">// 若找到匹配</span></span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;                    <span class="comment">// 回傳「先前元素的索引, 當前索引」</span></span><br><span class="line">            &#125;</span><br><span class="line">            num_to_complement_idx[target - nums[i]] = i;    <span class="comment">// 存入「target - nums[i]（補數） → i（索引）」</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 理論上不會執行到，因為題目保證至少有一組解</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>我們只需一次迴圈遍歷整個陣列，對每個元素執行一次雜湊表（Hash Map）的查找與插入操作，而這些操作均攤銷為 O(1)。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)</p>
<ul>
<li>最壞情況下，雜湊表需要儲存所有 n 個元素的（補數→索引）對。</li>
</ul>
</li>
</ul>
<h3 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFyZW50aGVzZXMv">題目連結</span><br><strong>標籤</strong>: Stack, String<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a string <code>s</code> containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.  </p>
<p>An input string is valid if:  </p>
<ol>
<li>Open brackets must be closed by the same type of brackets.  </li>
<li>Open brackets must be closed in the correct order.  </li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
</blockquote>
<p><strong>範例（Input &amp; Output）</strong></p>
<blockquote>
<p>Input: s &#x3D; “()”<br>Output: true</p>
</blockquote>
<blockquote>
<p>Input: s &#x3D; “()[]{}”<br>Output: true</p>
</blockquote>
<blockquote>
<p>Input: s &#x3D; “(]”<br>Output: false</p>
</blockquote>
<blockquote>
<p>Input: s &#x3D; “{[]}”<br>Output: true</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^4</code>  </li>
<li><code>s</code> consists only of the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;&#123;&#39;</code>, <code>&#39;&#125;&#39;</code>, <code>&#39;[&#39;</code>, <code>&#39;]&#39;</code>.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用一個 <code>stack&lt;char&gt;</code> 來追蹤尚未配對的開括號。  </li>
<li>遍歷字串中每個字元 <code>c</code>：  <ol>
<li>若 <code>c</code> 是開括號（<code>&#39;(&#39;</code>、<code>&#39;&#123;&#39;</code>、<code>&#39;[&#39;</code>），則推入堆疊。  </li>
<li>否則若 <code>c</code> 是閉括號，必須檢查堆疊頂端是否有對應的開括號：  <ul>
<li>如果堆疊為空，或頂端字元不是對應類型的開括號，即可立即回傳 <code>false</code>。  </li>
<li>否則彈出堆疊頂端，繼續遍歷。</li>
</ul>
</li>
</ol>
</li>
<li>最後遍歷完字串，如果堆疊為空表示所有括號都正確配對，回傳 <code>true</code>；否則回傳 <code>false</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;                    <span class="comment">// 用來存放開括號</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;                 <span class="comment">// 遍歷字串中的每個字元</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(c);                <span class="comment">// 若是開括號，推入堆疊</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若遇到閉括號但堆疊空，無法配對 -&gt; false</span></span><br><span class="line">                <span class="type">char</span> top = st.<span class="built_in">top</span>();      <span class="comment">// 取出堆疊頂端開括號</span></span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; top != <span class="string">&#x27;(&#x27;</span>) || <span class="comment">// 檢查是否為對應的左括號</span></span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; top != <span class="string">&#x27;&#123;&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; top != <span class="string">&#x27;[&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;         <span class="comment">// 若不匹配，回傳 false</span></span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">pop</span>();                 <span class="comment">// 匹配成功，彈出堆疊頂端</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();                <span class="comment">// 遍歷結束後若堆疊為空，代表所有括號都配對成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)  </p>
<ul>
<li>一次遍歷長度為 n 的字串，對每個字元做常數次的 <code>stack</code> 操作（<code>push</code>、<code>pop</code>、<code>empty</code>、<code>top</code>），皆為 O(1)。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)  </p>
<ul>
<li>最壞情況下所有字元都是開括號，<code>stack</code> 大小會達到 n，故額外空間為 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="Merge-Two-Sorted-Lists"><a href="#Merge-Two-Sorted-Lists" class="headerlink" title="Merge Two Sorted Lists"></a>Merge Two Sorted Lists</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWVyZ2UtdHdvLXNvcnRlZC1saXN0cy8=">題目連結</span><br><strong>標籤</strong>: Linked List, Recursion<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are given the heads of two sorted linked lists <code>l1</code> and <code>l2</code>.<br>Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.<br>Return the head of the merged linked list.  </p>
</blockquote>
<p><strong>範例（Input &amp; Output）</strong></p>
<blockquote>
<p>Input: l1 &#x3D; [1, 2, 4], l2 &#x3D; [1, 3, 4]<br>Output: [1, 1, 2, 3, 4, 4]</p>
</blockquote>
<blockquote>
<p>Input: l1 &#x3D; [], l2 &#x3D; []<br>Output: []</p>
</blockquote>
<blockquote>
<p>Input: l1 &#x3D; [], l2 &#x3D; [0]<br>Output: [0]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in both lists is in the range <code>[0, 50]</code>.  </li>
<li><code>-100 &lt;= Node.val &lt;= 100</code>  </li>
<li>Both <code>l1</code> and <code>l2</code> are sorted in non-decreasing order.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用一個虛擬頭節點（dummy head）來簡化合併過程的邊界處理。  </li>
<li>令 <code>curr</code> 指向這個虛擬頭節點，當作合併後鏈結串列的尾巴指標。  </li>
<li>同時維護指標 <code>p1</code> 指向 <code>l1</code> 的當前節點，<code>p2</code> 指向 <code>l2</code> 的當前節點。  </li>
<li>迴圈比較 <code>p1-&gt;val</code> 和 <code>p2-&gt;val</code>：  <ol>
<li>如果 <code>p1-&gt;val &lt;= p2-&gt;val</code>，將 <code>p1</code> 節點接到 <code>curr-&gt;next</code>，並讓 <code>p1</code> 移到下一個節點；  </li>
<li>否則，將 <code>p2</code> 節點接到 <code>curr-&gt;next</code>，並讓 <code>p2</code> 移到下一個節點；  </li>
<li>將 <code>curr</code> 一併移到剛接上的節點，保證尾巴始終指向最新節點。</li>
</ol>
</li>
<li>當 <code>l1</code> 或 <code>l2</code> 其中一方先到達末端（<code>nullptr</code>）時，直接把另一個尚未遍歷完的鏈結串列「接」到 <code>curr-&gt;next</code>。  </li>
<li>最後回傳 <code>dummy-&gt;next</code> 作為合併後的頭節點。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 建立虛擬頭節點，方便處理合併時的邊界</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指標 p1 指向 l1，p2 指向 l2</span></span><br><span class="line">        ListNode* p1 = l1;</span><br><span class="line">        ListNode* p2 = l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要兩個串列都還沒走到尾端，就繼續比較並合併</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt;= p2-&gt;val) &#123;</span><br><span class="line">                <span class="comment">// 若 l1 節點較小或相等，就把 p1 節點接到 curr</span></span><br><span class="line">                curr-&gt;next = p1;</span><br><span class="line">                p1 = p1-&gt;next;  <span class="comment">// p1 移到下一個</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否則把 p2 節點接到 curr</span></span><br><span class="line">                curr-&gt;next = p2;</span><br><span class="line">                p2 = p2-&gt;next;  <span class="comment">// p2 移到下一個</span></span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;  <span class="comment">// curr 移到最新接上的節點</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 當其中一個串列提前結束，直接把另一串列剩餘部分接上</span></span><br><span class="line">        <span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curr-&gt;next = p1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合併後的頭節點是 dummy-&gt;next</span></span><br><span class="line">        ListNode* head = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;  <span class="comment">// 釋放虛擬頭節點</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n + m)</p>
<ul>
<li>其中 n 為 l1 節點數，m 為 l2 節點數；合併過程中每個節點只會被訪問一次。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>除了輸入的兩個鏈結串列節點外，只使用了常數個輔助指標（dummy、curr、p1、p2），不額外配置與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmVzdC10aW1lLXRvLWJ1eS1hbmQtc2VsbC1zdG9jay8=">題目連結</span><br><strong>標籤</strong>: Array, Dynamic Programming<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the i-th day.<br>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.<br>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: prices &#x3D; [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price &#x3D; 1) and sell on day 5 (price &#x3D; 6), profit &#x3D; 6-1 &#x3D; 5.<br>Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: prices &#x3D; [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done and the max profit &#x3D; 0.  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= prices.length &lt;= 10^5</code>  </li>
<li><code>0 &lt;= prices[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>只需一次遍歷陣列，記錄到目前為止見過的最低價格 <code>minPrice</code>，以及最大收益 <code>maxProfit</code>。  </li>
<li>對於第 <code>i</code> 天的價格 <code>prices[i]</code>：  <ol>
<li>如果 <code>prices[i] &lt; minPrice</code>，則更新 <code>minPrice = prices[i]</code>。  </li>
<li>否則，計算當前收益 <code>prices[i] - minPrice</code>，若大於 <code>maxProfit</code>，則更新 <code>maxProfit</code>。</li>
</ol>
</li>
<li>最終 <code>maxProfit</code> 即為答案，如果始終沒有正收益，則回傳 <code>0</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minPrice = INT_MAX;    <span class="comment">// 初始化為極大值</span></span><br><span class="line">        <span class="type">int</span> maxProfit = <span class="number">0</span>;         <span class="comment">// 初始化最大收益為 0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            <span class="comment">// 更新見過的最低價格</span></span><br><span class="line">            <span class="keyword">if</span> (price &lt; minPrice) &#123;</span><br><span class="line">                minPrice = price;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 計算當前收益，並更新最大收益</span></span><br><span class="line">                <span class="type">int</span> profit = price - minPrice;</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxProfit) &#123;</span><br><span class="line">                    maxProfit = profit;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需要遍歷一次長度為 n 的陣列，對每個元素進行常數次操作。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用固定數量的輔助變數，與輸入規模無關。</li>
</ul>
</li>
</ul>
<h3 id="Valid-Palindrome"><a href="#Valid-Palindrome" class="headerlink" title="Valid Palindrome"></a>Valid Palindrome</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtcGFsaW5kcm9tZS8=">題目連結</span><br><strong>標籤</strong>: Two Pointers, String<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given a string <code>s</code>, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.  </p>
<p>Return <code>true</code> if it is a palindrome, otherwise return <code>false</code>.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: s &#x3D; <code>&quot;A man, a plan, a canal: Panama&quot;</code><br>Output: <code>true</code><br>Explanation: <code>&quot;amanaplanacanalpanama&quot;</code> is a palindrome.  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: s &#x3D; <code>&quot;race a car&quot;</code><br>Output: <code>false</code><br>Explanation: <code>&quot;raceacar&quot;</code> is not a palindrome.  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: s &#x3D; <code>&quot; &quot;</code><br>Output: <code>true</code><br>Explanation: 空字串視為回文。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 2 * 10^5</code>  </li>
<li><code>s</code> 只包含英文字母、數字、空格，以及標點符號等可列印字符。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用左右兩個指標 <code>left</code>、<code>right</code> 分別指向字串開頭與結尾。  </li>
<li>迴圈中：  <ol>
<li>若 <code>s[left]</code> 不是字母或數字，就將 <code>left</code> 向右移動直到遇到合法字符或 <code>left &gt;= right</code>。  </li>
<li>若 <code>s[right]</code> 不是字母或數字，就將 <code>right</code> 向左移動直到遇到合法字符或 <code>left &gt;= right</code>。  </li>
<li>當左右指標都指向合法字符時，比較將 <code>s[left]</code>、<code>s[right]</code> 都轉為小寫之後是否相等；  <ul>
<li>若不相等，直接回傳 <code>false</code>。  </li>
<li>若相等，則 <code>left++</code>、<code>right--</code>，繼續下一輪比較。</li>
</ul>
</li>
</ol>
</li>
<li>若整個過程中都未發現不相等的情況，最終 <code>left &gt;= right</code> 時，回傳 <code>true</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = (<span class="type">int</span>)s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 左指標跳過非字母或數字字符</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右指標跳過非字母或數字字符</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 比較忽略大小寫後的字符</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">char</span> c1 = <span class="built_in">tolower</span>(s[left]);</span><br><span class="line">                <span class="type">char</span> c2 = <span class="built_in">tolower</span>(s[right]);</span><br><span class="line">                <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 發現不匹配，直接回傳 false</span></span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 走到這裡表示所有字符都匹配，回傳 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需一次從頭到尾的掃描，左右指標共移動至多 n 次，對每個字符做常數次 isalnum 和 tolower 操作。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>僅使用常數個指標與臨時變數，不依賴額外與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="Invert-Binary-Tree"><a href="#Invert-Binary-Tree" class="headerlink" title="Invert Binary Tree"></a>Invert Binary Tree</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW52ZXJ0LWJpbmFyeS10cmVlLw==">題目連結</span><br><strong>標籤</strong>: Tree, Depth-First Search, Breadth-First Search<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given the root of a binary tree, invert the tree, and return its root.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>root = [4,2,7,1,3,6,9]</code><br>Output: <code>[4,7,2,9,6,3,1]</code><br>Explanation:  </p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  2   7</span><br><span class="line"> / \ / \</span><br><span class="line">1  3 6  9</span><br><span class="line"></span><br><span class="line">Output:  </span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  7   2</span><br><span class="line"> / \ / \</span><br><span class="line">9  6 3  1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2:<br>Input: <code>root = [2,1,3]</code><br>Output: <code>[2,3,1]</code>  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>root = []</code><br>Output: <code>[]</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.  </li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題可利用遞迴（DFS）或層序遍歷（BFS）來交換每個節點的左右子樹。  </li>
<li>遞迴（DFS）做法：  <ol>
<li>若當前節點為 <code>nullptr</code>，直接回傳 <code>nullptr</code>。  </li>
<li>交換當前節點的左右子節點指標。  </li>
<li>對左右子節點分別遞迴執行相同操作。  </li>
<li>最後回傳當前節點。</li>
</ol>
</li>
<li>或者使用迴圈搭配佇列（BFS）：  <ol>
<li>將根節點放入佇列。  </li>
<li>每次從佇列取出一個節點，交換其左右子節點，並將非空的左右子節點推入佇列。  </li>
<li>直到佇列為空，最後回傳根節點。</li>
</ol>
</li>
<li>遞迴版本較為簡潔，空間複雜度取決於遞迴深度；BFS 版本需要額外佇列空間。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 遞迴（DFS）解法</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先交換左右子節點</span></span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line">        <span class="comment">// 分別對交換後的左右子樹遞迴調用</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若要使用 BFS（迴圈）解法，可替換為以下函式：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    TreeNode* invertTree(TreeNode* root) &#123;</span></span><br><span class="line"><span class="comment">        if (root == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return nullptr;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        queue&lt;TreeNode*&gt; q;</span></span><br><span class="line"><span class="comment">        q.push(root);</span></span><br><span class="line"><span class="comment">        while (!q.empty()) &#123;</span></span><br><span class="line"><span class="comment">            TreeNode* node = q.front();</span></span><br><span class="line"><span class="comment">            q.pop();</span></span><br><span class="line"><span class="comment">            // 交換當前節點的左右子節點</span></span><br><span class="line"><span class="comment">            TreeNode* temp = node-&gt;left;</span></span><br><span class="line"><span class="comment">            node-&gt;left = node-&gt;right;</span></span><br><span class="line"><span class="comment">            node-&gt;right = temp;</span></span><br><span class="line"><span class="comment">            if (node-&gt;left) q.push(node-&gt;left);</span></span><br><span class="line"><span class="comment">            if (node-&gt;right) q.push(node-&gt;right);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return root;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li>時間複雜度：O(n)<ul>
<li>每個節點訪問一次並交換左右子節點，總計 n 個節點，因此時間複雜度為 O(n)。</li>
</ul>
</li>
<li>空間複雜度（遞迴版本）：O(h)<ul>
<li>h 為二元樹高度，最壞情況（樹為一條鍊狀）時 h &#x3D; n，空間複雜度為 O(n)。平均情況下若為平衡樹，h &#x3D; O(log n)。</li>
</ul>
</li>
<li>空間複雜度（BFS 版本）：O(n)<ul>
<li>需使用佇列儲存節點，最壞情況時可能將 O(n&#x2F;2) 個節點同時放入佇列，空間複雜度為 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="Valid-Anagram"><a href="#Valid-Anagram" class="headerlink" title="Valid Anagram"></a>Valid Anagram</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvdmFsaWQtYW5hZ3JhbS8=">題目連結</span><br><strong>標籤</strong>: Hash Table, String, Sorting<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> <em>if</em> <code>t</code> <em>is an anagram of</em> <code>s</code>, and <code>false</code> <em>otherwise</em>.  </p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: s &#x3D; <code>&quot;anagram&quot;</code>, t &#x3D; <code>&quot;nagaram&quot;</code><br>Output: <code>true</code>  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: s &#x3D; <code>&quot;rat&quot;</code>, t &#x3D; <code>&quot;car&quot;</code><br>Output: <code>false</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code>  </li>
<li><code>s</code> 和 <code>t</code> 只包含小寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li><p>方法一（排序 Sort）：  </p>
<ol>
<li>如果 <code>s.length() != t.length()</code>，直接回傳 <code>false</code>。  </li>
<li>將 <code>s</code>、<code>t</code> 轉為字母陣列並排序。  </li>
<li>如果排序後的兩個字串相等，回傳 <code>true</code>；否則回傳 <code>false</code>。</li>
</ol>
<ul>
<li>時間複雜度主要在排序：O(n log n)，其中 n 為字串長度。  </li>
<li>空間複雜度取決於排序所需緩衝（取決於標準庫實現），額外可視為 O(1)。</li>
</ul>
</li>
<li><p>方法二（雜湊表 Hash Table &#x2F; 計數）：  </p>
<ol>
<li>如果 <code>s.length() != t.length()</code>，直接回傳 <code>false</code>。  </li>
<li>建立長度為 26 的整數陣列 <code>count[26]</code>，初始化為 0。  </li>
<li>迴圈遍歷 <code>s</code>，對每個字符 <code>c = s[i]</code> 做 <code>count[c - &#39;a&#39;]++</code>。  </li>
<li>迴圈遍歷 <code>t</code>，對每個字符 <code>c = t[i]</code> 做 <code>count[c - &#39;a&#39;]--</code>，若減到小於 0，代表字符出現次數不匹配，可直接回傳 <code>false</code>。  </li>
<li>最後如果所有 <code>count[i] == 0</code>，回傳 <code>true</code>；否則 <code>false</code>。</li>
</ol>
<ul>
<li>時間複雜度為 O(n)，只需兩次線性掃描（n 為字串長度）。  </li>
<li>空間複雜度為 O(1)，由於計數陣列大小固定為 26。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 長度不同則不可能為 anagram</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() != t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用長度為 26 的計數陣列</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 對 s 中字符計數 +1，對 t 中字符計數 -1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            count[t[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 檢查是否全部歸零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需對長度為 n 的字串各做一次線性掃描，計數與檢查操作均為 O(1)。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>使用固定大小為 26 的整數陣列作為計數，與輸入長度無關。</li>
</ul>
</li>
</ul>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXNlYXJjaC8=">題目連結</span><br><strong>標籤</strong>: Array, Binary Search<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.  </p>
<p>You must write an algorithm with O(log n) runtime complexity.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9<br>Output: 4<br>Explanation: 9 exists in nums and its index is 4  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2<br>Output: -1<br>Explanation: 2 does not exist in nums so return -1  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^4</code>  </li>
<li><code>-10^4 &lt; nums[i], target &lt; 10^4</code>  </li>
<li>All the integers in <code>nums</code> are <strong>unique</strong>.  </li>
<li><code>nums</code> is sorted in ascending order.  </li>
<li><code>target</code> is an integer.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用二分搜尋法（Binary Search）。  </li>
<li>設定兩個指標 <code>left = 0</code> 與 <code>right = nums.size() - 1</code>，維護當前搜尋範圍。  </li>
<li>迴圈條件為 <code>left &lt;= right</code>：  <ol>
<li>計算 <code>mid = left + (right - left) / 2</code>（避免整數溢位）。  </li>
<li>若 <code>nums[mid] == target</code>，則找到目標，回傳 <code>mid</code>。  </li>
<li>若 <code>nums[mid] &lt; target</code>，代表目標在右半段，將 <code>left = mid + 1</code>。  </li>
<li>否則 <code>nums[mid] &gt; target</code>，代表目標在左半段，將 <code>right = mid - 1</code>。</li>
</ol>
</li>
<li>若迴圈結束都沒找到，回傳 <code>-1</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = (<span class="type">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 避免 (left+right) 溢位</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(log n)</p>
<ul>
<li>每次都將搜尋範圍對半，最多需要 log n 次比較。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個輔助變數，不額外配置與輸入規模相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmxvb2QtZmlsbC8=">題目連結</span><br><strong>標籤</strong>: Depth-First Search, Breadth-First Search, Matrix<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>An image is represented by a 2D integer grid <code>image</code> where <code>image[i][j]</code> represents the pixel value of the image.<br>You are also given three integers <code>sr</code>, <code>sc</code>, and <code>newColor</code>.<br>You should perform a “flood fill” on the image starting from the pixel <code>image[sr][sc]</code>.<br>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.<br>Replace the color of all of the aforementioned pixels with <code>newColor</code>.<br>Return the modified image after performing the flood fill.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: image &#x3D; [[1,1,1],[1,1,0],[1,0,1]], sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2<br>image &#x3D; [[1,1,1],<br>         [1,1,0],<br>         [1,0,1]],<br>  sr &#x3D; 1, sc &#x3D; 1, newColor &#x3D; 2<br>Output: [[2,2,2],[2,2,0],[2,0,1]]<br> [[2,2,2],<br>  [2,2,0],<br>  [2,0,1]]<br>Explanation:<br>From the center of the image (position (1,1)), all pixels connected by a path of the same color as the starting pixel are colored.<br>初始的 image（3×3 矩陣）：<br>1  1  1<br>1  1  0<br>1  0  1<br>起始位置 (sr, sc) &#x3D; (1, 1)，newColor &#x3D; 2</p>
</blockquote>
<blockquote>
<p>─── 填色過程 ───<br>從 image[1][1]（數值為 1）開始，將和它「上下左右相連且數字相同」的所有 1 全部改成 2。</p>
</blockquote>
<blockquote>
<p>(1) 先把中心點 (1,1) 換色：<br>1  1  1        1  1  1<br>1 [1] 0   →    1 [2] 0<br>1  0  1        1  0  1</p>
</blockquote>
<blockquote>
<p>(2) 看 (1,1) 的上下左右：<br>上方 (0,1) &#x3D; 1 → 也要改成 2<br>下方 (2,1) &#x3D; 0 → 不同，跳過<br>左方 (1,0) &#x3D; 1 → 也要改成 2<br>右方 (1,2) &#x3D; 0 → 跳過  </p>
</blockquote>
<pre><code>**此時的狀態**：  
   1  [2]  1        1  [2]  1
  [2]  2   0   →   [2]  2   0
   1   0   1        1   0   1
</code></pre>
<blockquote>
<p>(3) 再繼續往外擴散：<br>- 處理 (0,1)（目前值 2）的相鄰：<br>  (0,0)&#x3D;1、(0,2)&#x3D;1、(1,1)&#x3D;2（已改）、(-1,1)不存在<br>  其中 (0,0)&#x3D;1、(0,2)&#x3D;1 都屬於要改的範圍 → 改成 2<br>- 處理 (1,0)（目前值 2）的相鄰：<br>  (0,0)&#x3D;1（剛才改過了）、(2,0)&#x3D;1 → 改成 2、(1,-1)不存在、(1,1)&#x3D;2（已改）<br>- 不用再看 (1,2)、(2,1) 因為它們一開始就不是「1」。</p>
</blockquote>
<pre><code>**此時的狀態**：  
  [2]  [2]  [2]        [2]  [2]  [2]
  [2]  [2]  0   →     [2]  [2]  0
  [2]   0   1         [2]   0   1
</code></pre>
<blockquote>
<p>(4) 接著 (2,0) 原本是 1，因為跟 (1,0) 相連，也要改成 2，(2,2)&#x3D;1 則和任何「已改成 2」都不相鄰（中間隔了 0），所以不要改。  </p>
</blockquote>
<pre><code>**最終結果**：  
  2   2   2
  2   2   0
  2   0   1
</code></pre>
<blockquote>
<p>Example 2:<br>Input: image &#x3D; [[0,0,0],[0,0,0]], sr &#x3D; 0, sc &#x3D; 0, newColor &#x3D; 0<br>Output: [[0,0,0],[0,0,0]]<br>Explanation: The new color is the same as the color of the starting pixel, so no changes are made.  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == image.length</code>  </li>
<li><code>n == image[i].length</code>  </li>
<li><code>1 &lt;= m, n &lt;= 50</code>  </li>
<li><code>0 &lt;= image[i][j], newColor &lt; 2^16</code>  </li>
<li><code>0 &lt;= sr &lt; m</code>  </li>
<li><code>0 &lt;= sc &lt; n</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用深度優先搜尋（DFS）或廣度優先搜尋（BFS）來遍歷與起始像素顏色相同且 4 方向相連的所有像素，並將它們的顏色換為 <code>newColor</code>。  </li>
<li>首先記錄起始點的顏色 <code>originalColor</code>，如果 <code>originalColor == newColor</code>，則直接回傳 <code>image</code>（因為無需更改）。  </li>
<li>定義方向陣列 <code>dirs = &#123;&#123;1,0&#125;,&#123;-1,0&#125;,&#123;0,1&#125;,&#123;0,-1&#125;&#125;</code> 方便遍歷 4 個方向。  </li>
<li>使用遞迴函式 <code>dfs(r, c)</code>：  <ol>
<li>如果當前坐標 <code>(r, c)</code> 越界或 <code>image[r][c] != originalColor</code>，則返回。  </li>
<li>否則將 <code>image[r][c]</code> 設為 <code>newColor</code>。  </li>
<li>依序對 4 個方向呼叫 <code>dfs(r + dr, c + dc)</code>。</li>
</ol>
</li>
<li>主函式調用 <code>dfs(sr, sc)</code> 後，回傳更新後的 <code>image</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">floodFill</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> sr, <span class="type">int</span> sc, <span class="type">int</span> newColor) &#123;</span><br><span class="line">        <span class="type">int</span> m = image.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = image[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> originalColor = image[sr][sc];</span><br><span class="line">        <span class="comment">// 若原色與新色相同，直接回傳</span></span><br><span class="line">        <span class="keyword">if</span> (originalColor == newColor) &#123;</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 方向陣列：下、上、右、左</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 開始 DFS</span></span><br><span class="line">        <span class="built_in">dfs</span>(image, sr, sc, originalColor, newColor, m, n, dirs);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; image, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> originalColor, <span class="type">int</span> newColor, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&amp; dirs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 邊界條件與顏色檢查</span></span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || image[r][c] != originalColor) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替換顏色</span></span><br><span class="line">        image[r][c] = newColor;</span><br><span class="line">        <span class="comment">// 遞迴探索四個方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : dirs) &#123;</span><br><span class="line">            <span class="type">int</span> nr = r + d.first;</span><br><span class="line">            <span class="type">int</span> nc = c + d.second;</span><br><span class="line">            <span class="built_in">dfs</span>(image, nr, nc, originalColor, newColor, m, n, dirs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(m * n)</p>
<ul>
<li>最壞情況下，所有像素都需要被訪問一次，因此需要遍歷 m*n 個格子。</li>
</ul>
</li>
<li><p>空間複雜度：O(m * n)（遞迴棧）</p>
<ul>
<li>最壞情況下，遞迴深度可能達到 m*n，若圖像所有像素同色且連通。</li>
</ul>
</li>
</ul>
<h3 id="Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="Lowest Common Ancestor of a Binary Search Tree"></a>Lowest Common Ancestor of a Binary Search Tree</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG93ZXN0LWNvbW1vbi1hbmNlc3Rvci1vZi1hLWJpbmFyeS1zZWFyY2gtdHJlZS8=">題目連結</span><br><strong>標籤</strong>: Tree, Binary Search Tree<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元搜尋樹（BST）的根節點 <code>root</code>，以及樹中兩個節點指標 <code>p</code> 和 <code>q</code>，請找出這兩個節點的最近公共祖先（Lowest Common Ancestor, LCA）。  </p>
<p>在 BST 中，對於任意節點 <code>node</code>，若 <code>p-&gt;val</code> 和 <code>q-&gt;val</code> 分別小於 <code>node-&gt;val</code>，代表兩者都在 <code>node</code> 的左子樹；若都大於 <code>node-&gt;val</code>，則在右子樹。若一個在左、一個在右，或者其中有一個等於 <code>node</code>，則 <code>node</code> 為最近公共祖先。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  6</span><br><span class="line">  / \</span><br><span class="line"> 2   8</span><br><span class="line">/ \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line"> / \</span><br><span class="line">3   5</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p><code>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</code><br>Output: <code>6</code><br>Explanation: 節點 2 和 8 的 LCA 是 6。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  6</span><br><span class="line">  / \</span><br><span class="line"> 2   8</span><br><span class="line">/ \ / \</span><br><span class="line">0  4 7  9</span><br><span class="line"> / \</span><br><span class="line">3   5</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p><code>root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</code><br>Output: <code>2</code><br>Explanation: 節點 2 和 4 的 LCA 是 2（因為 2 是 4 的祖先）。  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>root = [2, 1], p = 2, q = 4</code><br>Output: <code>2</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點數量在範圍 <code>[2, 10^5]</code>。  </li>
<li><code>-10^9 &lt;= Node.val &lt;= 10^9</code>，且樹中的所有 <code>Node.val</code> 皆互不相同。  </li>
<li><code>p</code> 和 <code>q</code> 都是樹中存在的不同節點。  </li>
<li>BST 保證左子樹所有節點值小於根節點值，右子樹所有節點值大於根節點值。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>利用 BST 性質：對於當前節點 <code>cur</code>，比較 <code>p-&gt;val</code>、<code>q-&gt;val</code> 與 <code>cur-&gt;val</code>：  <ol>
<li>若 <code>p-&gt;val &lt; cur-&gt;val</code> 且 <code>q-&gt;val &lt; cur-&gt;val</code>，代表兩個節點都在左子樹，則將 <code>cur</code> 移至 <code>cur-&gt;left</code> 繼續搜尋。  </li>
<li>若 <code>p-&gt;val &gt; cur-&gt;val</code> 且 <code>q-&gt;val &gt; cur-&gt;val</code>，代表兩個節點都在右子樹，則將 <code>cur</code> 移至 <code>cur-&gt;right</code> 繼續搜尋。  </li>
<li>否則（即一個小於或等於 <code>cur-&gt;val</code>，另一個大於或等於 <code>cur-&gt;val</code>），當前 <code>cur</code> 即為最近公共祖先，可直接回傳。</li>
</ol>
</li>
<li>由於每次都往該方向跨越一個子樹，最壞情況需遍歷至樹高。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="comment">// 若兩者都小於當前節點，往左子樹找</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; cur-&gt;val &amp;&amp; q-&gt;val &lt; cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 若兩者都大於當前節點，往右子樹找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; cur-&gt;val &amp;&amp; q-&gt;val &gt; cur-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否則當前節點即為 LCA</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 理論上不會到這裡，因為 p 和 q 一定存在於 BST 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(h)</p>
<ul>
<li>h 為樹的高度。最壞情況（退化成鏈）時 h &#x3D; n，時間為 O(n)；若為平衡 BST，h &#x3D; O(log n)。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個指標，不需額外空間儲存與遞迴棧。</li>
</ul>
</li>
</ul>
<h3 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree"></a>Balanced Binary Tree</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmFsYW5jZWQtYmluYXJ5LXRyZWUv">題目連結</span><br><strong>標籤</strong>: Tree, Depth-First Search<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點 <code>root</code>，判斷該二元樹是否為「平衡二元樹」（Balanced Binary Tree）。  </p>
<p>定義：「平衡二元樹」是指每個節點的左右子樹高度差的絕對值至多為 1，且它的左右子樹皆為平衡二元樹。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>root = [3,9,20,null,null,15,7]</code><br>Output: <code>true</code><br>Explanation:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   / \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>root = [1,2,2,3,3,null,null,4,4]</code><br>Output: <code>false</code><br>Explanation:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     / \</span><br><span class="line">    2   2</span><br><span class="line">   / \</span><br><span class="line">  3   3</span><br><span class="line"> / \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure></blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>root = []</code><br>Output: <code>true</code><br>Explanation: 空樹被視為平衡二元樹。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>二元樹節點數量在範圍 <code>[0, 10^4]</code>。  </li>
<li><code>-10^4 &lt;= Node.val &lt;= 10^4</code>。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>我們可以透過遞迴（DFS）在一次遍歷中，同時計算子樹高度並檢查平衡性。  </li>
<li>定義一個輔助函式 <code>height(TreeNode* node)</code>，回傳該節點為根時的子樹高度；若該子樹不平衡，則回傳 <code>-1</code> 作為標記。  <ol>
<li>如果 <code>node</code> 為 <code>nullptr</code>，回傳高度 <code>0</code>。  </li>
<li>遞迴計算左子樹高度 <code>leftH = height(node-&gt;left)</code>，若 <code>leftH == -1</code>，直接回傳 <code>-1</code>（代表左子樹已經不平衡）。  </li>
<li>遞迴計算右子樹高度 <code>rightH = height(node-&gt;right)</code>，若 <code>rightH == -1</code>，直接回傳 <code>-1</code>（代表右子樹已經不平衡）。  </li>
<li>如果 <code>abs(leftH - rightH) &gt; 1</code>，代表當前節點不平衡，回傳 <code>-1</code>。  </li>
<li>否則回傳 <code>max(leftH, rightH) + 1</code> 作為當前子樹高度。</li>
</ol>
</li>
<li>最後在主函式 <code>isBalanced(TreeNode* root)</code> 中，只需檢查 <code>height(root) != -1</code> 即可判定是否為平衡二元樹。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若子樹不平衡，回傳 -1；否則回傳子樹高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 計算左子樹高度</span></span><br><span class="line">        <span class="type">int</span> leftH = <span class="built_in">height</span>(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftH == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 左子樹不平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 計算右子樹高度</span></span><br><span class="line">        <span class="type">int</span> rightH = <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightH == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 右子樹不平衡</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右高度差超過 1，當前節點不平衡</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftH - rightH) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否則回傳當前節點子樹的高度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>每個節點只會被訪問一次；透過遞迴自底向上計算高度並檢查平衡，總共 O(n) 次呼叫。</li>
</ul>
</li>
<li><p>空間複雜度：O(h)（遞迴棧）</p>
<ul>
<li>h 為二元樹高度；最壞情況（樹為一條鏈）時 h &#x3D; n，空間複雜度為 O(n)；若為平衡樹，h &#x3D; O(log n)。</li>
</ul>
</li>
</ul>
<h3 id="Linked-List-Cycle"><a href="#Linked-List-Cycle" class="headerlink" title="Linked List Cycle"></a>Linked List Cycle</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbGlua2VkLWxpc3QtY3ljbGUv">題目連結</span><br><strong>標籤</strong>: 鏈表 (Linked List)、雙指針 (Two Pointers)<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個單向鏈表的頭節點 <code>head</code>，判斷鏈表中是否存在環 (cycle)。如果存在，則返回 <code>true</code>；否則返回 <code>false</code>。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(3) → (2) → (0) → (-4)</span><br><span class="line">      ↑           │</span><br><span class="line">      └───────────┘</span><br></pre></td></tr></table></figure>
<p>Input: head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>Output: true<br>Explanation: 尾節點指向第二個節點，形成環。</p>
</blockquote>
<blockquote>
<p>Example 2:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1) → (2)</span><br><span class="line">↑     │</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>
<p>Input: head &#x3D; [1,2], pos &#x3D; 0<br>Output: true<br>Explanation: 尾節點指向第一個節點，形成環。</p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: head &#x3D; [1], pos &#x3D; -1<br>Output: false<br>Explanation: 無環，pos &#x3D; -1 表示沒有環。</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為 <code>[0, 10^4]</code>。  </li>
<li><code>-10^5 &lt;= Node.val &lt;= 10^5</code>。  </li>
<li><code>pos</code> 表示尾節點指向的位置索引，<code>pos = -1</code> 表示沒有環。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用「快慢指針」(tortoise and hare) 方法：  <ol>
<li>初始化慢指針 <code>slow = head</code>，快指針 <code>fast = head</code>。  </li>
<li>每一步中，慢指針前進一個節點 (<code>slow = slow-&gt;next</code>)，快指針前進兩個節點 (<code>fast = fast-&gt;next-&gt;next</code>)。  </li>
<li>如果在某一步驟中 <code>fast == nullptr</code> 或 <code>fast-&gt;next == nullptr</code>，說明鏈表到達末端，沒有環，返回 <code>false</code>。  </li>
<li>如果 <code>slow == fast</code>，說明快指針已經追上慢指針，存在環，返回 <code>true</code>。  </li>
<li>重複步驟直到返回結果。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 空鏈表或僅一個節點，不可能有環</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;          <span class="comment">// 慢指針，每次走一步</span></span><br><span class="line">        ListNode *fast = head-&gt;next;    <span class="comment">// 快指針，每次走兩步</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 快指針到達末端，無環</span></span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;           <span class="comment">// 慢指針向前一步</span></span><br><span class="line">            fast = fast-&gt;next-&gt;next;     <span class="comment">// 快指針向前兩步</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 慢指針與快指針相遇，有環</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>快慢指針最多各自遍歷 O(n) 次，在鏈表長度為 n 時，通過有限次迭代即可判斷是否有環。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個指針，不需要額外記憶體，空間複雜度為常數。</li>
</ul>
</li>
</ul>
<h3 id="Implement-Queue-using-Stacks"><a href="#Implement-Queue-using-Stacks" class="headerlink" title="Implement Queue using Stacks"></a>Implement Queue using Stacks</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW1wbGVtZW50LXF1ZXVlLXVzaW5nLXN0YWNrcy8=">題目連結</span><br><strong>標籤</strong>: Stack, Design<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (<code>push</code>, <code>pop</code>, <code>peek</code>, and <code>empty</code>).  </p>
<p>Implement the <code>MyQueue</code> class:  </p>
<ul>
<li><code>void push(int x)</code> Pushes element <code>x</code> to the back of the queue.  </li>
<li><code>int pop()</code> Removes the element from the front of the queue and returns it.  </li>
<li><code>int peek()</code> Returns the element at the front of the queue.  </li>
<li><code>boolean empty()</code> Returns <code>true</code> if the queue is empty, <code>false</code> otherwise.</li>
</ul>
<p><strong>Notes:</strong>  </p>
<ul>
<li>You must use only standard operations of a stack, which means only <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, and <code>is empty</code> operations are valid.  </li>
<li>Depending on your language, stack may not be supported natively. You may simulate a stack using a list or deque (as long as you use only standard stack operations).</li>
</ul>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line">Explanation</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek();  // return 1</span><br><span class="line">myQueue.pop();   // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure></blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= x &lt;= 9</code>  </li>
<li>最多呼叫 <code>push</code>, <code>pop</code>, <code>peek</code>, <code>empty</code> 共 <code>100</code> 次  </li>
<li>當呼叫 <code>pop</code> 或 <code>peek</code> 時，保證隊列不為空</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用兩個堆疊：一個作為「輸入棧（inStack）」用來接收 <code>push</code> 的元素；另一個作為「輸出棧（outStack）」用來做 <code>pop</code> 或 <code>peek</code> 操作。  </li>
<li>當執行 <code>push(x)</code> 時，直接將 <code>x</code> 推入 <code>inStack</code>。  </li>
<li>當執行 <code>pop()</code> 或 <code>peek()</code> 時，若 <code>outStack</code> 為空，則將 <code>inStack</code> 內所有元素依次彈出並推入 <code>outStack</code>（這樣可以將最早推入的元素放到 <code>outStack</code> 頂部）。之後，<code>pop()</code> 就從 <code>outStack.top()</code> 取出並 <code>pop</code>；<code>peek()</code> 則回傳 <code>outStack.top()</code>。  </li>
<li><code>empty()</code> 只需檢查 <code>inStack</code> 和 <code>outStack</code> 是否都為空。  </li>
<li>這樣可以保證隊列操作的正確性：每當需要出隊時，如果 <code>outStack</code> 有元素就直接對應隊首，否則就把所有「輸入棧」的元素移到「輸出棧」，完成先進先出行為。  </li>
<li>每個元素最多從 <code>inStack</code> 移到 <code>outStack</code> 一次，因此攤銷時間複雜度仍為 O(1)。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveInToOut</span>();</span><br><span class="line">        <span class="type">int</span> frontVal = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> frontVal;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">moveInToOut</span>();</span><br><span class="line">        <span class="keyword">return</span> outStack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack;   <span class="comment">// 用來接收 push 的元素</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack;  <span class="comment">// 用來執行 pop 和 peek</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 inStack 中的所有元素移動到 outStack，僅在 outStack 為空時呼叫</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveInToOut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (outStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!inStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(1)（攤銷）</p>
<ul>
<li>每個元素最多被移動一次：從 inStack 推到 outStack；其餘操作（push、pop、peek、empty）均為常數時間。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)</p>
<ul>
<li>需要額外使用兩個堆疊來儲存最多 n 個元素。</li>
</ul>
</li>
</ul>
<h2 id="Week-2-12-12"><a href="#Week-2-12-12" class="headerlink" title="Week 2 (12&#x2F;12)"></a>Week 2 (12&#x2F;12)</h2><h3 id="First-Bad-Version"><a href="#First-Bad-Version" class="headerlink" title="First Bad Version"></a>First Bad Version</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZmlyc3QtYmFkLXZlcnNpb24v">題目連結</span><br><strong>標籤</strong>: Binary Search<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.  </p>
<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.  </p>
<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>n = 5</code>, <code>bad = 4</code><br>Output: <code>4</code><br>Explanation:<br>call <code>isBadVersion(3)</code> → false<br>call <code>isBadVersion(5)</code> → true<br>call <code>isBadVersion(4)</code> → true<br>So, 4 is the first bad version.  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>n = 1</code>, <code>bad = 1</code><br>Output: <code>1</code><br>Explanation: Only one version and it is bad.</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= bad &lt;= n &lt;= 2^31 - 1</code>  </li>
<li>呼叫 API <code>isBadVersion</code> 次數應盡量少。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用二分搜尋法（Binary Search）定位第一個壞版本：  <ol>
<li>設定 <code>left = 1</code>, <code>right = n</code>。  </li>
<li>在迴圈中計算 <code>mid = left + (right - left) / 2</code>（防止溢位）。  </li>
<li>呼叫 <code>isBadVersion(mid)</code>：  <ul>
<li>如果返回 <code>true</code>，代表第 <code>mid</code> 版是壞的，壞版本範圍縮至 <code>[left, mid]</code>，因此將 <code>right = mid</code>。  </li>
<li>如果返回 <code>false</code>，代表第 <code>mid</code> 版是好的，壞版本必在 <code>mid+1</code> 到 <code>right</code>，因此將 <code>left = mid + 1</code>。</li>
</ul>
</li>
<li>直到 <code>left == right</code>，此時 <code>left</code> 或 <code>right</code> 即為第一個壞版本，返回 <code>left</code>。</li>
</ol>
</li>
<li>二分搜尋可保證最少化函式調用次數，時間複雜度為 <code>O(log n)</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Forward declaration of isBadVersion API.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">long</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) &#123;</span><br><span class="line">                <span class="comment">// mid 及之後皆為壞版本，向左收縮</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mid 為好版本，壞版本在 mid+1 之後</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(log n)</p>
<ul>
<li>每次二分搜尋都將範圍縮減一半，最壞情況下需 log n 次呼叫 isBadVersion。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個輔助變數（left, right, mid），不依賴額外空間。</li>
</ul>
</li>
</ul>
<h3 id="Ransom-Note"><a href="#Ransom-Note" class="headerlink" title="Ransom Note"></a>Ransom Note</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmFuc29tLW5vdGUv">題目連結</span><br><strong>標籤</strong>: Hash Table, String<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given two strings <code>ransomNote</code> and <code>magazine</code>, return <code>true</code> if <code>ransomNote</code> can be constructed by using the letters from <code>magazine</code> and <code>false</code> otherwise.  </p>
<p>Each letter in <code>magazine</code> can only be used once in <code>ransomNote</code>.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: ransomNote &#x3D; <code>&quot;a&quot;</code>, magazine &#x3D; <code>&quot;b&quot;</code><br>Output: <code>false</code>  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: ransomNote &#x3D; <code>&quot;aa&quot;</code>, magazine &#x3D; <code>&quot;ab&quot;</code><br>Output: <code>false</code>  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: ransomNote &#x3D; <code>&quot;aa&quot;</code>, magazine &#x3D; <code>&quot;aab&quot;</code><br>Output: <code>true</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 10^5</code>  </li>
<li><code>ransomNote</code> 和 <code>magazine</code> 只包含小寫英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>方法一（計數陣列）：  <ol>
<li>如果 <code>ransomNote.length() &gt; magazine.length()</code>，直接回傳 <code>false</code>，因為信件請求長度大於雜誌字母總數，不可能構造。  </li>
<li>建立長度為 26 的整數陣列 <code>count[26]</code>，初始化為 0。  </li>
<li>遍歷 <code>magazine</code>，對 <code>magazine[i]</code> 字符做 <code>count[magazine[i] - &#39;a&#39;]++</code>。  </li>
<li>遍歷 <code>ransomNote</code>，對 <code>ransomNote[i]</code> 字符做 <code>count[ransomNote[i] - &#39;a&#39;]--</code>，若減到小於 0，說明雜誌中該字符不足，返回 <code>false</code>。  </li>
<li>整個過程若未出現不足，即可回傳 <code>true</code>。</li>
</ol>
<ul>
<li>時間複雜度 O(n + m)，n 為 <code>magazine</code> 長度，m 為 <code>ransomNote</code> 長度。  </li>
<li>空間複雜度 O(1)，計數陣列大小固定為 26。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="type">const</span> string&amp; ransomNote, <span class="type">const</span> string&amp; magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ransomNote.<span class="built_in">size</span>() &gt; magazine.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 對 magazine 中字符計數 +1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine) &#123;</span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 對 ransomNote 中字符計數 -1，若不足則回傳 false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--count[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n + m)</p>
<ul>
<li>需遍歷 magazine 長度 n 做一次計數，以及遍歷 ransomNote 長度 m 做一次扣減，總共為 O(n + m)。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>使用固定大小為 26 的整數陣列，不隨輸入長度變化。</li>
</ul>
</li>
</ul>
<h3 id="Climbing-Stairs"><a href="#Climbing-Stairs" class="headerlink" title="Climbing Stairs"></a>Climbing Stairs</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xpbWJpbmctc3RhaXJzLw==">題目連結</span><br><strong>標籤</strong>: Dynamic Programming, Math<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.  </p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: n &#x3D; 2<br>Output: 2<br>Explanation: There are two ways to climb to the top:  </p>
<ol>
<li>1 step + 1 step  </li>
<li>2 steps</li>
</ol>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: n &#x3D; 3<br>Output: 3<br>Explanation: There are three ways to climb to the top:  </p>
<ol>
<li>1 step + 1 step + 1 step  </li>
<li>1 step + 2 steps  </li>
<li>2 steps + 1 step</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= n &lt;= 45</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題屬於經典的動態規劃 (Dynamic Programming) 問題，也可用數學的方法（Fibonacci）解決。  </li>
<li>設 <code>dp[i]</code> 為爬到第 <code>i</code> 級台階的所有可能方式數。  </li>
<li>由於每次只能爬 1 或 2 級，因此到達第 <code>i</code> 級的方式可由到達第 <code>i-1</code> 級再跨 1 步，或到達第 <code>i-2</code> 級再跨 2 步：  <blockquote>
<p><code>dp[i] = dp[i-1] + dp[i-2]</code>  </p>
</blockquote>
</li>
<li>初始條件：  <blockquote>
<p><code>dp[1] = 1</code> （只有一種方式：跨 1 步）<br><code>dp[2] = 2</code> （兩種方式：1+1 或 2）  </p>
</blockquote>
</li>
<li>依此遞推至 <code>dp[n]</code> 即為答案。  </li>
<li>為節省空間，可只用兩個變數滾動更新，不需整個 <code>dp</code> 陣列。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prev2 代表 dp[i-2]，初始為 dp[1] = 1</span></span><br><span class="line">        <span class="type">int</span> prev2 = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// prev1 代表 dp[i-1]，初始為 dp[2] = 2</span></span><br><span class="line">        <span class="type">int</span> prev1 = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> curr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            curr = prev1 + prev2; <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">            prev2 = prev1;        <span class="comment">// 滾動更新：下一輪的 dp[i-2]</span></span><br><span class="line">            prev1 = curr;         <span class="comment">// 更新 dp[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需要一次從 3 到 n 的迴圈，每次操作為常數時間。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個變數，不需額外與 n 線性相關的空間。</li>
</ul>
</li>
</ul>
<h3 id="Longest-Palindrome"><a href="#Longest-Palindrome" class="headerlink" title="Longest Palindrome"></a>Longest Palindrome</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1wYWxpbmRyb21lLw==">題目連結</span><br><strong>標籤</strong>: Hash Table, String, Greedy<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由大小寫英文字母組成的字串 <code>s</code>，請你找出可以由這些字母「組成」的最長回文串的長度。你可以假設字母的大小寫有區分，例如 <code>&#39;A&#39;</code> 和 <code>&#39;a&#39;</code> 被視為不同字元。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: s &#x3D; <code>&quot;abccccdd&quot;</code><br>Output: <code>7</code><br>Explanation: 可以構造的最長回文串為 <code>&quot;dccaccd&quot;</code>，長度為 7。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: s &#x3D; <code>&quot;a&quot;</code><br>Output: <code>1</code><br>Explanation: 回文串就是 <code>&quot;a&quot;</code>，長度為 1。   </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code>  </li>
<li><code>s</code> 只包含英文字母（大寫、小寫）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>要構造最長回文串，回文的特性是中間可以有一個單獨的字元，其餘字元必須成對出現（左右對稱）。  </li>
<li>可以先統計每個字元出現次數，對於每個字元：  <ol>
<li>如果該字元出現次數為偶數，則可全部用於回文，長度直接加上該偶數。  </li>
<li>如果該字元出現次數為奇數，則可用 <code>count - 1</code>（偶數部分）來組成對稱部分，並且保留一個候選作為中心字元（如果尚未使用中心字元）。</li>
</ol>
</li>
<li>最終，只要有至少一個字元出現次數為奇數，就可以在中心放置一個字元讓回文長度加 1。  </li>
<li>因此流程為：  <ol>
<li>建立 <code>unordered_map&lt;char,int&gt;</code> 或長度 128 的陣列來統計字元出現次數。  </li>
<li>遍歷所有字元計算總可用偶數長度，並記錄是否存在奇數出現。  </li>
<li>如果存在任一奇數，總長度再加 1；否則直接回傳偶數總和。</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用大小為 128 的計數陣列統計所有 ASCII 字元</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">128</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> hasOdd = <span class="literal">false</span>; <span class="comment">// 標記是否存在出現次數為奇數的字元</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> freq : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 偶數次數全部可以用</span></span><br><span class="line">                length += freq;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 奇數次數只能用 freq - 1，並標記可放置中心字元</span></span><br><span class="line">                length += freq - <span class="number">1</span>;</span><br><span class="line">                hasOdd = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有任何一個字元出現次數為奇數，可以把其中一個放到回文中心</span></span><br><span class="line">        <span class="keyword">if</span> (hasOdd) &#123;</span><br><span class="line">            length += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>n 為字串長度。需要一次掃描字串進行統計，然後再掃描長度固定（128）的計數陣列。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>使用固定大小（128）的計數陣列，與輸入長度無關。</li>
</ul>
</li>
</ul>
<h3 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvcmV2ZXJzZS1saW5rZWQtbGlzdC8=">題目連結</span><br><strong>標籤</strong>: Linked List, Iteration, Recursion<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個單向鏈表的頭節點 <code>head</code>，將該鏈表反轉，並返回反轉後的頭節點。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>head = [1,2,3,4,5]</code><br>Output: <code>[5,4,3,2,1]</code>  </p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始鏈結串列：</span><br><span class="line">(1) → (2) → (3) → (4) → (5)</span><br><span class="line"></span><br><span class="line">              ↓</span><br><span class="line">              ↓</span><br><span class="line"></span><br><span class="line">反轉後鏈結串列：</span><br><span class="line">(5) → (4) → (3) → (2) → (1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2:<br>Input: <code>head = [1,2]</code><br>Output: <code>[2,1]</code>  </p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原始：</span><br><span class="line">(1) → (2)</span><br><span class="line"></span><br><span class="line">   ↓</span><br><span class="line"></span><br><span class="line">反轉後：</span><br><span class="line">(2) → (1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 3:<br>Input: <code>head = []</code><br>Output: <code>[]</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為 <code>[0, 5000]</code>。  </li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code>。  </li>
<li>必須在 O(n) 時間內完成，且使用 O(1) 額外空間（不含遞迴棧空間）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li><p><strong>迭代法 (Iteration)</strong>：  </p>
<ol>
<li>使用三個指標：<code>prev = nullptr</code>（指向已反轉部分的尾節點）、<code>curr = head</code>（當前要處理的節點）、<code>nextTemp</code>（暫存 <code>curr-&gt;next</code>）。  </li>
<li>迴圈條件為 <code>curr != nullptr</code>：  <ul>
<li>先將 <code>curr-&gt;next</code> 暫存到 <code>nextTemp</code>。  </li>
<li>將 <code>curr-&gt;next</code> 指向 <code>prev</code>，完成節點反向指向。  </li>
<li>更新 <code>prev = curr</code>（新的已反轉部分尾巴），並將 <code>curr = nextTemp</code>（繼續處理下一個節點）。</li>
</ul>
</li>
<li>迴圈結束時，<code>prev</code> 即為反轉後的新頭節點，返回 <code>prev</code>。</li>
</ol>
<ul>
<li>此方法只需一趟遍歷，並且使用常數級輔助變數。</li>
</ul>
</li>
<li><p><strong>遞迴法 (Recursion)</strong>：  </p>
<ol>
<li>如果 <code>head == nullptr</code> 或 <code>head-&gt;next == nullptr</code>，直接返回 <code>head</code>（空表或單節點就是反轉後本身）。  </li>
<li>呼叫 <code>ListNode* p = reverseList(head-&gt;next)</code> 取得反轉後的尾部節點 <code>p</code>。  </li>
<li>將 <code>head-&gt;next-&gt;next = head</code>，使下一節點指回 <code>head</code>，再將 <code>head-&gt;next = nullptr</code> 斷開。  </li>
<li>返回 <code>p</code>（整個反轉後的頭節點）。</li>
</ol>
<ul>
<li>遞迴法的呼叫深度為鏈表長度 h，因此額外空間為遞迴棧 O(h)。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* nextTemp = curr-&gt;next; <span class="comment">// 暫存下一節點</span></span><br><span class="line">            curr-&gt;next = prev;               <span class="comment">// 反轉指向</span></span><br><span class="line">            prev = curr;                     <span class="comment">// 移動 prev</span></span><br><span class="line">            curr = nextTemp;                 <span class="comment">// 處理下一節點</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev; <span class="comment">// prev 即為新的頭節點</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遞迴法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    ListNode* reverseList(ListNode* head) &#123;</span></span><br><span class="line"><span class="comment">        if (head == nullptr || head-&gt;next == nullptr) &#123;</span></span><br><span class="line"><span class="comment">            return head;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        ListNode* p = reverseList(head-&gt;next); </span></span><br><span class="line"><span class="comment">        head-&gt;next-&gt;next = head; // 下個節點指回 current</span></span><br><span class="line"><span class="comment">        head-&gt;next = nullptr;    // 斷開 current 節點的 next</span></span><br><span class="line"><span class="comment">        return p;                // p 是反轉後的新頭節點</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>單趟遍歷整個鏈表，共有 n 個節點，每個節點只處理一次。</li>
</ul>
</li>
<li><p>空間複雜度 (迭代法)：O(1)</p>
<ul>
<li>只使用常數個指標變數，不額外配置與 n 相關的空間。</li>
</ul>
</li>
<li><p>空間複雜度 (遞迴法)：O(n)（遞迴棧）</p>
<ul>
<li>遞迴深度等於鏈表長度 n，遞迴棧使用空間為 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="Majority-Element"><a href="#Majority-Element" class="headerlink" title="Majority Element"></a>Majority Element</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWFqb3JpdHktZWxlbWVudC8=">題目連結</span><br><strong>標籤</strong>: Array, Divide and Conquer, Hash Table, Sorting<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個大小為 <code>n</code> 的陣列 <code>nums</code>，請找出其中的「主元素」（Majority Element），即在陣列中出現次數 <strong>嚴格大於</strong> ⌊n&#x2F;2⌋ 的元素。<br>你可以假設主元素一定存在於陣列中。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>nums = [3,2,3]</code><br>Output: <code>3</code>  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>nums = [2,2,1,1,1,2,2]</code><br>Output: <code>2</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5 * 10^4</code>  </li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code>  </li>
<li>主元素一定存在。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以使用 <strong>Boyer–Moore 投票演算法（Boyer–Moore Voting Algorithm）</strong>，時間複雜度 O(n)、空間複雜度 O(1)。  </p>
<p>演算法流程：  </p>
<ol>
<li>初始化 <code>candidate</code>（候選元素）為任意值、<code>count = 0</code>。  </li>
<li>遍歷陣列 <code>nums</code> 中的每個元素 <code>num</code>：  <ul>
<li>當 <code>count == 0</code> 時，將 <code>candidate = num</code>。  </li>
<li>若 <code>num == candidate</code>，<code>count++</code>；否則 <code>count--</code>。</li>
</ul>
</li>
<li>最終 <code>candidate</code> 即為主元素。</li>
</ol>
<p>原理：因為主元素出現次數大於 ⌊n&#x2F;2⌋，當我們遍歷時，凡是當前值與候選相同，就增加計數；若不同，就抵消一個候選的影響。由於主元素出現次數占大多數，最終剩下的候選必為主元素。  </p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candidate = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需一次線性掃描陣列。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>僅使用常數個輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="Add-Binary"><a href="#Add-Binary" class="headerlink" title="Add Binary"></a>Add Binary</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYWRkLWJpbmFyeS8=">題目連結</span><br><strong>標籤</strong>: String, Math<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定兩個二進位字串 <code>a</code> 和 <code>b</code>，請回傳它們相加後的二進位字串。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: a &#x3D; <code>&quot;11&quot;</code>, b &#x3D; <code>&quot;1&quot;</code><br>Output: <code>&quot;100&quot;</code>  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: a &#x3D; <code>&quot;1010&quot;</code>, b &#x3D; <code>&quot;1011&quot;</code><br>Output: <code>&quot;10101&quot;</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= a.length, b.length &lt;= 10^4</code>  </li>
<li><code>a</code> 和 <code>b</code> 只包含字符 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code>。  </li>
<li>每個字串除非整串為 <code>&quot;0&quot;</code>，否則不含前導零。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用雙指標從字串末端開始遍歷，同時維護進位 <code>carry</code>。  </li>
<li>設定 <code>i = a.length() - 1</code>, <code>j = b.length() - 1</code>。  </li>
<li>當 <code>i &gt;= 0 || j &gt;= 0 || carry != 0</code>：  <ol>
<li>取 <code>digitA = (i &gt;= 0) ? a[i] - &#39;0&#39; : 0</code>，<code>digitB = (j &gt;= 0) ? b[j] - &#39;0&#39; : 0</code>。  </li>
<li>計算總和 <code>sum = digitA + digitB + carry</code>。  </li>
<li>當前位結果為 <code>sum % 2</code>，更新 <code>carry = sum / 2</code>。  </li>
<li>將 <code>(sum % 2)</code> 推入答案字串（先收集後反轉）。  </li>
<li><code>i--</code>, <code>j--</code>，重複上述步驟。</li>
</ol>
</li>
<li>最後反轉收集到的結果並回傳。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(<span class="type">const</span> string&amp; a, <span class="type">const</span> string&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = (<span class="type">int</span>)a.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> j = (<span class="type">int</span>)b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        string result;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> digitA = (i &gt;= <span class="number">0</span>) ? a[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> digitB = (j &gt;= <span class="number">0</span>) ? b[j] - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = digitA + digitB + carry;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + (sum % <span class="number">2</span>)));</span><br><span class="line">            carry = sum / <span class="number">2</span>;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(max(m, n))</p>
<ul>
<li>其中 m &#x3D; a.length(), n &#x3D; b.length()；需要遍歷最長字串長度次數。</li>
</ul>
</li>
<li><p>空間複雜度：O(max(m, n))</p>
<ul>
<li>用於存儲結果的字串長度最多為 max(m, n) + 1。</li>
</ul>
</li>
</ul>
<h3 id="Diameter-of-Binary-Tree"><a href="#Diameter-of-Binary-Tree" class="headerlink" title="Diameter of Binary Tree"></a>Diameter of Binary Tree</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZGlhbWV0ZXItb2YtYmluYXJ5LXRyZWUv">題目連結</span><br><strong>標籤</strong>: Tree, Depth-First Search, Recursion<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點 <code>root</code>，請你計算並回傳該二元樹的「直徑」（diameter）。  </p>
<p>二元樹的直徑定義為任意兩個節點之間的最長路徑邊數。這條路徑可以不經過根節點。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>root = [1,2,3,4,5]</code><br>Output: <code>3</code><br>Explanation: 最長路徑為節點 4 → 2 → 1 → 3（或 5 → 2 → 1 → 3），邊的數量為 3。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>root = [1,2]</code><br>Output: <code>1</code><br>Explanation: 最長路徑為節點 2 → 1，邊的數量為 1。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>二元樹節點數量在範圍 <code>[1, 10^4]</code>。  </li>
<li><code>-100 &lt;= Node.val &lt;= 100</code>。  </li>
<li>結果保證在 32 位整數範圍內。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>我們需要計算任意兩個節點之間的最長路徑邊數。  </li>
<li>對於某個節點 <code>node</code>，以該節點為「橋梁」的最長路徑長度可以表示為「左子樹最大深度」加上「右子樹最大深度」。  </li>
<li>因此，只要在一次遞迴遍歷中，同時計算每個節點的子樹高度，並在計算過程中更新全域的 <code>diameter</code> 為 <code>max(diameter, leftHeight + rightHeight)</code>，即可得到最終答案。  </li>
<li>定義輔助函式 <code>height(TreeNode* node)</code>：  <ol>
<li>若 <code>node == nullptr</code>，回傳高度 0。  </li>
<li>透過遞迴，先取得 <code>leftH = height(node-&gt;left)</code>，再取得 <code>rightH = height(node-&gt;right)</code>。  </li>
<li>更新全域變數 <code>diameter = max(diameter, leftH + rightH)</code>。  </li>
<li>回傳 <code>max(leftH, rightH) + 1</code> 作為該節點的高度。</li>
</ol>
</li>
<li>最後在主函式中呼叫 <code>height(root)</code>，並回傳紀錄到的 <code>diameter</code>。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        diameter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">height</span>(root);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> diameter;  <span class="comment">// 紀錄當前最長直徑（邊數）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回以 node 為根的子樹高度，同時更新 diameter</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftH = <span class="built_in">height</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightH = <span class="built_in">height</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">// 以當前節點為橋梁，左右子樹高度之和就是通過此節點的最大邊數</span></span><br><span class="line">        diameter = <span class="built_in">max</span>(diameter, leftH + rightH);</span><br><span class="line">        <span class="comment">// 返回該子樹高度：較高的子樹高度 + 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftH, rightH) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>每個節點只會被訪問一次，計算左右子樹高度與更新 diameter 均為常數時間。</li>
</ul>
</li>
<li><p>空間複雜度：O(h)（遞迴棧空間）</p>
<ul>
<li>h 為二元樹高度，最壞情況（樹退化為鏈）時 h &#x3D; n，空間複雜度為 O(n)；若為平衡樹，h &#x3D; O(log n)。</li>
</ul>
</li>
</ul>
<h3 id="Middle-of-the-Linked-List"><a href="#Middle-of-the-Linked-List" class="headerlink" title="Middle of the Linked List"></a>Middle of the Linked List</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWlkZGxlLW9mLXRoZS1saW5rZWQtbGlzdC8=">題目連結</span><br><strong>標籤</strong>: Linked List, Two Pointers<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定單向鏈表的頭節點 <code>head</code>，請返回鏈表的中間節點。如果鏈表有兩個中間節點，則返回第二個中間節點。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: head &#x3D; [1,2,3,4,5]<br>Output: [3,4,5]<br>Explanation: 中間節點為 3。返回節點 3 及其後所有節點。<br>(1) → (2) → [3] → (4) → (5)</p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: head &#x3D; [1,2,3,4,5,6]<br>Output: [4,5,6]<br>Explanation: 鏈表有兩個中間節點（3 和 4），因此返回第二個中間節點 4 及其後所有節點。<br>(1) → (2) → (3) → [4] → (5) → (6)</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>鏈表節點數量範圍為 <code>[1, 100]</code>。  </li>
<li><code>1 &lt;= Node.val &lt;= 100</code>。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用「快慢指針」（Two Pointers）：  <ol>
<li>初始化兩個指針 <code>slow = head</code>（每次走一步）和 <code>fast = head</code>（每次走兩步）。  </li>
<li>當 <code>fast</code> 不為 <code>nullptr</code> 且 <code>fast-&gt;next</code> 不為 <code>nullptr</code> 時，執行：  <ul>
<li><code>slow = slow-&gt;next;</code>  </li>
<li><code>fast = fast-&gt;next-&gt;next;</code></li>
</ul>
</li>
<li>當迴圈結束時，<code>slow</code> 指向的即為中間節點（如果長度為偶數，則指向第二個中間節點）。  </li>
<li>直接返回 <code>slow</code>。</li>
</ol>
</li>
<li>此方法只需一次遍歷，時間複雜度 O(n)，且空間複雜度 O(1)。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指針都從 head 開始</span></span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="comment">// fast 每次走兩步，slow 每次走一步</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最後 slow 指向中間節點（若為偶數長度，為第二中間節點）</span></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需一次遍歷鏈表，快指針走兩步、慢指針走一步，最多迴圈 ⌈n&#x2F;2⌉ 次。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>只使用常數個輔助指針，不使用額外空間。</li>
</ul>
</li>
</ul>
<h3 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree"></a>Maximum Depth of Binary Tree</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1kZXB0aC1vZi1iaW5hcnktdHJlZS8=">題目連結</span><br><strong>標籤</strong>: Tree, Depth-First Search, Breadth-First Search<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Given the root of a binary tree, return its maximum depth.  </p>
<p>A binary tree’s <code>maximum depth</code> is the number of nodes along the longest path from the root node down to the farthest leaf node.  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>root = [3,9,20,null,null,15,7]</code><br>Output: <code>3</code><br>Explanation: The maximum depth is 3 because the longest path is 3 → 20 → 7 (or 3 → 20 → 15).  </p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  (3)</span><br><span class="line">  /   \</span><br><span class="line">(9)   (20)</span><br><span class="line">      /  \</span><br><span class="line">   (15)  (7)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2:<br>Input: <code>root = [1,null,2]</code><br>Output: <code>2</code>  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>root = []</code><br>Output: <code>0</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>The number of nodes in the tree is in the range <code>[0, 10^4]</code>.  </li>
<li><code>-100 &lt;= Node.val &lt;= 100</code>。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>可以使用遞迴（Depth-First Search）或迭代（Breadth-First Search）來計算最大深度。  </li>
<li><strong>遞迴（DFS）做法</strong>：  <ol>
<li>如果當前節點為 <code>nullptr</code>，回傳深度 <code>0</code>。  </li>
<li>否則遞迴計算左子樹深度 <code>leftDepth = maxDepth(root-&gt;left)</code>，再計算右子樹深度 <code>rightDepth = maxDepth(root-&gt;right)</code>。  </li>
<li>當前節點的最大深度即為 <code>max(leftDepth, rightDepth) + 1</code>，其中 <code>+1</code> 代表包含當前節點。</li>
</ol>
</li>
<li><strong>迭代（BFS）做法</strong>：  <ol>
<li>如果根為 <code>nullptr</code>，回傳 <code>0</code>。  </li>
<li>使用一個佇列 <code>queue&lt;TreeNode*&gt; q</code>，先將 <code>root</code> 推入佇列。  </li>
<li>初始化 <code>depth = 0</code>。  </li>
<li>當佇列不為空時：  <ul>
<li>令 <code>levelSize = q.size()</code>（當前層節點數），並遍歷這一層所有節點：  <ul>
<li>取出節點 <code>node = q.front()</code> 並 <code>q.pop()</code>，若 <code>node-&gt;left</code> 非空則 <code>q.push(node-&gt;left)</code>、若 <code>node-&gt;right</code> 非空則 <code>q.push(node-&gt;right)</code>。</li>
</ul>
</li>
<li>這一層處理完畢後，<code>depth++</code> 表示深度加 1。</li>
</ul>
</li>
<li>最終 <code>depth</code> 即為最大深度。</li>
</ol>
</li>
<li>在簡單易實現的情況下，遞迴寫法最為直觀。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>需要訪問每個節點一次，n 為節點總數。</li>
</ul>
</li>
<li><p>空間複雜度：O(h)（遞迴棧空間）</p>
<ul>
<li>h 為樹的高度；最壞情況（樹退化成鏈）時 h &#x3D; n，空間複雜度為 O(n)；若樹較平衡，h &#x3D; O(log n)。</li>
</ul>
</li>
</ul>
<h3 id="Contains-Duplicate"><a href="#Contains-Duplicate" class="headerlink" title="Contains Duplicate"></a>Contains Duplicate</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY29udGFpbnMtZHVwbGljYXRlLw==">題目連結</span><br><strong>標籤</strong>: Array, Hash Table<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 10 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列 <code>nums</code>，判斷是否存在至少一個值在陣列中出現兩次。如果任意值出現至少兩次，回傳 <code>true</code>；如果所有元素皆只出現一次，回傳 <code>false</code>。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: nums &#x3D; [1,2,3,1]<br>Output: true  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: nums &#x3D; [1,2,3,4]<br>Output: false  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: nums &#x3D; [1,1,1,3,3,4,3,2,4,2]<br>Output: true  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code>  </li>
<li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>方法一（使用哈希集合）：  <ol>
<li>建立一個空的 <code>unordered_set&lt;int&gt; seen</code>。  </li>
<li>遍歷陣列 <code>nums</code> 的每個元素 <code>x</code>：  <ul>
<li>如果 <code>x</code> 已存在於 <code>seen</code> 中，表示該值重複，立即回傳 <code>true</code>。  </li>
<li>否則將 <code>x</code> 插入 <code>seen</code> 中。</li>
</ul>
</li>
<li>如果遍歷結束都沒有發現重複元素，則回傳 <code>false</code>。</li>
</ol>
</li>
<li>方法二（排序）：  <ol>
<li>將 <code>nums</code> 進行排序，時間複雜度為 O(n log n)。  </li>
<li>遍歷排序後的陣列，檢查任意相鄰元素是否相等，如果相等，則回傳 <code>true</code>。  </li>
<li>若遍歷完整沒有相等的相鄰元素，回傳 <code>false</code>。</li>
</ol>
</li>
<li>由於限制 n 可達 10^5，方法一時間複雜度 O(n)、空間複雜度 O(n)；方法二時間為 O(n log n)、空間為 O(1)（排序視為額外空間由語言實現決定）。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seen.<span class="built_in">count</span>(x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.<span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>複雜度分析</strong></p>
<ul>
<li>時間複雜度：O(n)<ul>
<li>遍歷陣列一次，對每個元素進行哈希集合查找和插入，平均均攤時間為 O(1)。</li>
</ul>
</li>
<li>空間複雜度：O(n)<ul>
<li>最壞情況下，所有元素都被插入集合，共需額外 O(n) 空間。</li>
</ul>
</li>
</ul>
<h3 id="Maximum-Subarray"><a href="#Maximum-Subarray" class="headerlink" title="Maximum Subarray"></a>Maximum Subarray</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbWF4aW11bS1zdWJhcnJheS8=">題目連結</span><br><strong>標籤</strong>: Array, Dynamic Programming, Divide and Conquer<br><strong>語言</strong>: C++<br><strong>難度</strong>: Easy<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列 <code>nums</code>，請計算具有最大和的連續子陣列，並返回其最大和。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code><br>Output: <code>6</code><br>Explanation: 最大子陣列為 <code>[4,-1,2,1]</code>，其和為 6。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>nums = [1]</code><br>Output: <code>1</code>  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>nums = [5,4,-1,7,8]</code><br>Output: <code>23</code>  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code>  </li>
<li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>常見解法是 <strong>Kadane’s Algorithm</strong>，時間複雜度 O(n)，只需一次線性掃描。  </li>
<li>使用兩個變數：<code>currentSum</code> 表示以當前位置結尾且和最大的子陣列和，<code>maxSum</code> 表示迄今為止見過的最大子陣列和。  </li>
<li>初始化：  <ul>
<li><code>currentSum = nums[0]</code>  </li>
<li><code>maxSum = nums[0]</code></li>
</ul>
</li>
<li>從索引 1 開始，對每個元素 <code>num = nums[i]</code>：  <ol>
<li>如果在 <code>currentSum + num</code> 與 <code>num</code> 之間，<code>num</code> 本身比較大，表示重新從當前元素開始累積，因此 <code>currentSum = max(num, currentSum + num)</code>。  </li>
<li>更新 <code>maxSum = max(maxSum, currentSum)</code>。</li>
</ol>
</li>
<li>掃描結束後，<code>maxSum</code> 即為答案。  </li>
<li>此方法的核心在於：若前面累積的和是負數，加上後續的元素只會讓總和更小，因此在遇到負累積時就重置為當前元素。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> currentSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxSum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            currentSum = <span class="built_in">max</span>(nums[i], currentSum + nums[i]);</span><br><span class="line">            maxSum = <span class="built_in">max</span>(maxSum, currentSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>只需一次遍歷長度為 n 的陣列，每次計算和更新均為 O(1)。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>僅使用固定數量的輔助變數，不依賴輸入規模。</li>
</ul>
</li>
</ul>
<h2 id="Week-3-8-8"><a href="#Week-3-8-8" class="headerlink" title="Week 3 (8&#x2F;8)"></a>Week 3 (8&#x2F;8)</h2><h3 id="Insert-Interval"><a href="#Insert-Interval" class="headerlink" title="Insert Interval"></a>Insert Interval</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvaW5zZXJ0LWludGVydmFsLw==">題目連結</span><br><strong>標籤</strong>: Array, Sorting<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由不重疊且依照起點排序的區間列表 <code>intervals</code>，以及一個新的區間 <code>newInterval</code>，請在列表中插入 <code>newInterval</code>，並確保最終結果中的區間仍然是不重疊且已排序。如果插入後有任何區間重疊，請將它們合併為一個區間。  </p>
<p>每個區間由 <code>[start, end]</code> 表示，且 <code>start &lt;= end</code>。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: intervals &#x3D; [[1,3],[6,9]], newInterval &#x3D; [2,5]<br>Output: [[1,5],[6,9]]<br>Explanation: 插入 [2,5] 後，與 [1,3] 重疊，合併為 [1,5]。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: intervals &#x3D; [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval &#x3D; [4,9]<br>Output: [[1,2],[3,10],[12,16]]<br>Explanation:<br>插入 [4,9] 後，會與 [3,5],[6,7],[8,10] 三個區間重疊，合併為 [3,10]。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= intervals.length &lt;= 10^4</code>  </li>
<li><code>intervals[i].length == 2</code>  </li>
<li><code>0 &lt;= intervals[i][0] &lt;= intervals[i][1] &lt;= 10^5</code>  </li>
<li><code>intervals</code> 依照 <code>intervals[i][0]</code>（起點）嚴格遞增排序，且彼此不重疊。  </li>
<li><code>newInterval.length == 2</code>  </li>
<li><code>0 &lt;= newInterval[0] &lt;= newInterval[1] &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li><p>因為原本的 <code>intervals</code> 已經依起點排序，且彼此不重疊，我們只需將 <code>newInterval</code> 插入適當位置，並與相鄰的重疊區間做合併。整體流程可分為三個階段：  </p>
<ol>
<li><p><strong>將所有在 <code>newInterval</code> 之前且不會重疊的區間先加入結果</strong>  </p>
<ul>
<li>換言之，遍歷原列表，對於每個區間 <code>intervals[i]</code>，如果其結束時間 <code>intervals[i][1] &lt; newInterval[0]</code>（比 <code>newInterval</code> 的起點還要早結束），則代表這些區間完全在 <code>newInterval</code> 之前且不重疊，直接推入結果 <code>result</code>。</li>
</ul>
</li>
<li><p><strong>處理與 <code>newInterval</code> 可能重疊的區間，進行合併</strong>  </p>
<ul>
<li>當遇到某個區間 <code>intervals[i]</code> 的起點 <code>intervals[i][0] &lt;= newInterval[1]</code> 時，代表它與 <code>newInterval</code> 有重疊，需更新：  <ul>
<li><code>newInterval[0] = min(newInterval[0], intervals[i][0])</code>  </li>
<li><code>newInterval[1] = max(newInterval[1], intervals[i][1])</code></li>
</ul>
</li>
<li>此時不立即將 <code>intervals[i]</code> 推入 <code>result</code>，而是持續向後合併所有重疊區間。只要 <code>intervals[i][0] &lt;= newInterval[1]</code>，就持續更新 <code>newInterval</code>。</li>
</ul>
</li>
<li><p><strong>將合併完成的 <code>newInterval</code> 推入結果</strong>  </p>
<ul>
<li>當遇到第一個不與 <code>newInterval</code> 重疊的區間時（或原列表已遍歷完），將合併後的 <code>newInterval</code> 推入 <code>result</code>，並切換到下一個階段。</li>
</ul>
</li>
<li><p><strong>將所有在 <code>newInterval</code> 之後且不會重疊的區間加入結果</strong>  </p>
<ul>
<li>從目前位置繼續遍歷，每個區間的起點都比 <code>newInterval[1]</code> 大，直接推入 <code>result</code> 即可。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p>以上步驟保證最終的 <code>result</code> 依然是按照起點排序，且所有重疊區間已經被合併。</p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 處理所有在 newInterval 之前且不重疊的區間</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 處理與 newInterval 重疊的區間，合併到 newInterval 中</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]) &#123;</span><br><span class="line">            newInterval[<span class="number">0</span>] = <span class="built_in">min</span>(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>]);</span><br><span class="line">            newInterval[<span class="number">1</span>] = <span class="built_in">max</span>(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 合併完成後，把 newInterval 加入結果</span></span><br><span class="line">        result.<span class="built_in">push_back</span>(newInterval);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 處理所有在 newInterval 之後且不重疊的區間</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>我們僅對 intervals 列表做一次線性掃描，n 為原列表長度。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)</p>
<ul>
<li>除了用於輸出結果的 result，僅使用常數級別的額外變數（i, n 及更新 newInterval 的空間），因此額外空間為 O(1)。最終輸出空間則為 O(n + 1)，可視為 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="01-Matrix"><a href="#01-Matrix" class="headerlink" title="01 Matrix"></a>01 Matrix</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvMDEtbWF0cml4Lw==">題目連結</span><br><strong>標籤</strong>: Breadth-First Search, Dynamic Programming, Queue, Matrix<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個由 0 和 1 組成的 m x n 二維矩陣 <code>mat</code>，請返回一個同樣大小的矩陣 <code>res</code>，其中 <code>res[i][j]</code> 是原矩陣中位置 <code>(i, j)</code> 到最近的 0 的距離。距離由上下左右四個方向的一步算作 1。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input:<br>mat &#x3D; [<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]</p>
</blockquote>
<blockquote>
<p>Output:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]</p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input:<br>mat &#x3D; [<br>  [0,0,0],<br>  [0,1,0],<br>  [1,1,1]<br>]</p>
</blockquote>
<blockquote>
<p>Output:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [1,2,1]<br>]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>m == mat.length</code>  </li>
<li><code>n == mat[i].length</code>  </li>
<li><code>1 &lt;= m, n &lt;= 10^4</code>  </li>
<li><code>1 &lt;= m * n &lt;= 10^5</code>  </li>
<li><code>mat[i][j]</code> 為 <code>0</code> 或 <code>1</code>  </li>
<li>保證至少有一個 <code>0</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>由於每個格子的值要計算到最近的 0 的最短步數，若對每個 1 單獨做 BFS，複雜度將高達 O((mn)·(mn))，在大矩陣中無法接受。  </p>
<p>我們可以反向思考，將所有值為 0 的位置作為 BFS 的多源起點，同時從每個 0 開始向外擴散，逐步標記各 1 到「其最近 0」的距離。  </p>
<p>演算法步驟如下：  </p>
<ol>
<li><strong>初始化距離矩陣 <code>dist</code></strong>  <ul>
<li>建立與 <code>mat</code> 同維度的距離矩陣 <code>dist</code>，初始化為一個很大的整數（如 <code>INT_MAX</code> 或 <code>m+n</code>）。</li>
</ul>
</li>
<li><strong>多源 BFS</strong>  <ul>
<li>建立一個佇列 <code>queue&lt;pair&lt;int,int&gt;&gt; q</code>。  </li>
<li>遍歷 <code>mat</code> 中所有格子，若 <code>mat[i][j] == 0</code>，則將 <code>(i, j)</code> 推入佇列 <code>q</code>，並將 <code>dist[i][j] = 0</code>。  </li>
<li>四個方向的偏移陣列 <code>dirs = &#123;&#123;1,0&#125;, &#123;-1,0&#125;, &#123;0,1&#125;, &#123;0,-1&#125;&#125;</code> 用於遍歷相鄰格子。</li>
</ul>
</li>
<li><strong>執行 BFS 擴散</strong>  <ul>
<li>當 <code>q</code> 不為空時，不斷取出當前格 <code>(r, c)</code>：  <ol>
<li>對於四個方向 <code>d</code>，計算鄰格 <code>(nr, nc) = (r + d.first, c + d.second)</code>。  </li>
<li>檢查 <code>(nr, nc)</code> 是否在矩陣內，且若 <code>dist[nr][nc] &gt; dist[r][c] + 1</code>，代表從當前 0 或已知較近 0 過來能取得更短距離：  <ul>
<li>更新 <code>dist[nr][nc] = dist[r][c] + 1</code>，  </li>
<li>並將 <code>(nr, nc)</code> 推入佇列 <code>q</code>。</li>
</ul>
</li>
</ol>
</li>
<li>由於所有 0 先入隊，第一輪拓展時距離將被標記為 1，再下一輪擴散將標記距離 2，以此類推。最終 <code>dist[i][j]</code> 即為該格到最近 0 的距離。</li>
</ul>
</li>
</ol>
<p>這種方法相當於從所有 0「同時」開始做 BFS，保證第一次到達某個 1 的距離即為最短距離。整體時間複雜度為 O(mn)。  </p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="type">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 初始化 dist 矩陣，預設為一個足夠大的值</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INF = m + n; </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dist</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INF));</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 將所有 0 的位置入隊，並將 dist 設為 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四個方向偏移：下、上、右、左</span></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 多源 BFS，從所有 0 同時擴散</span></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [r, c] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; d : dirs) &#123;</span><br><span class="line">                <span class="type">int</span> nr = r + d.first;</span><br><span class="line">                <span class="type">int</span> nc = c + d.second;</span><br><span class="line">                <span class="comment">// 若鄰格在範圍內，且可用更短距離更新</span></span><br><span class="line">                <span class="keyword">if</span> (nr &gt;= <span class="number">0</span> &amp;&amp; nr &lt; m &amp;&amp; nc &gt;= <span class="number">0</span> &amp;&amp; nc &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dist[nr][nc] &gt; dist[r][c] + <span class="number">1</span>) &#123;</span><br><span class="line">                        dist[nr][nc] = dist[r][c] + <span class="number">1</span>;</span><br><span class="line">                        q.<span class="built_in">emplace</span>(nr, nc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(mn)</p>
<ul>
<li>每個格子最多被加入佇列一次，且從佇列中彈出後最多檢查 4 個鄰格，總共為 O(mn)。</li>
</ul>
</li>
<li><p>空間複雜度：O(mn)</p>
<ul>
<li>使用一個與輸入矩陣等大的距離矩陣 dist，以及最壞情況下可達 O(mn) 大小的佇列。</li>
</ul>
</li>
</ul>
<h3 id="K-Closest-Points-to-Origin"><a href="#K-Closest-Points-to-Origin" class="headerlink" title="K Closest Points to Origin"></a>K Closest Points to Origin</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvay1jbG9zZXN0LXBvaW50cy10by1vcmlnaW4v">題目連結</span><br><strong>標籤</strong>: Array, Math, Divide and Conquer, Sorting, Heap (Priority Queue)<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個「點」的列表 <code>points</code>，其中 <code>points[i] = [xi, yi]</code> 表示第 i 個點在 2D 平面上的座標。請返回距離原點 (0,0) 最近的 k 個點。  </p>
<p>所有點到原點的距離由歐幾里得距離計算：<code>sqrt(xi^2 + yi^2)</code>。你可以按任何順序返回答案。答案傳回的 k 個點必須精確為「距離最小的 k 個」，不需要排序。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: points &#x3D; [[1,3],[-2,2]], k &#x3D; 1<br>Output: [[-2,2]]<br>Explanation:<br>點 (-2,2) 到原點距離為 sqrt(4+4) &#x3D; sqrt(8) ≈ 2.828；<br>而點 (1,3) 到原點距離為 sqrt(1+9) &#x3D; sqrt(10) ≈ 3.162。<br>因此最近的 1 個點為 [-2,2]。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: points &#x3D; [[3,3],[5,-1],[-2,4]], k &#x3D; 2<br>Output: [[3,3],[-2,4]]<br>Explanation:<br>距離分別為：<br>(3,3) → sqrt(9+9)&#x3D;sqrt(18) ≈ 4.243<br>(5,-1) → sqrt(25+1)&#x3D;sqrt(26) ≈ 5.099<br>(-2,4) → sqrt(4+16)&#x3D;sqrt(20) ≈ 4.472<br>最近的兩個點為 (3,3) 與 (-2,4)，順序可以互換。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= k &lt;= points.length &lt;= 10^4</code>  </li>
<li><code>-10^4 &lt;= xi, yi &lt;= 10^4</code>  </li>
<li>答案保證是唯一的（除了順序）。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題要求返回距離原點最近的 k 個點，可使用以下常見方法：  </p>
<ol>
<li><p><strong>Max-Heap (Priority Queue) 維護大小為 k 的集合</strong>  </p>
<ul>
<li>我們可以維護一個「最大堆」，堆中保存當前距離最小的 k 個點，並以距離作為比較依據。  </li>
<li>遍歷所有 <code>points</code>：  <ol>
<li>對第 i 個點 <code>(x, y)</code>，計算其「距離平方」<code>d = x*x + y*y</code>（不需開根號，比較平方即可）。  </li>
<li>如果堆的大小小於 k，就直接將 <code>(d, i)</code> 推入最大堆；  </li>
<li>否則，比較當前點距離 <code>d</code> 與堆頂元素的距離（即目前 k 個最遠點的距離），若 <code>d</code> 比堆頂小，代表這個點更接近原點，應該將堆頂彈出、並把 <code>(d, i)</code> 推入，否則跳過。</li>
</ol>
</li>
<li>最終，堆中就保留了 k 個「距離最小」的點；取出它們的索引即可。  </li>
<li><strong>時間複雜度</strong>：O(n log k)，其中 n 為點的數量；每次對堆操作為 log k，總共 n 次插入／比較。  </li>
<li><strong>空間複雜度</strong>：O(k)，最大堆中最多保存 k 個點。</li>
</ul>
</li>
<li><p><strong>快速選擇法 (Quickselect)</strong>  </p>
<ul>
<li>類似快速排序的「分區」操作，利用 <code>nth_element</code> 或手動實現 partition，一次可以將第 k 小(距離)的點放到正確位置，左側都是更小距離的點。  </li>
<li><code>nth_element(points.begin(), points.begin()+k, points.end(), cmp)</code> 之後，前 k 個元素即為距離最小的 k 個點，但不保證排序。  </li>
<li><strong>時間複雜度</strong>：平均 O(n)，最壞 O(n^2)（但使用標準庫的 <code>nth_element</code> 大多能保證線性平均）。  </li>
<li><strong>空間複雜度</strong>：O(1)（就地在原陣列操作）。</li>
</ul>
</li>
</ol>
<p>此處我們以 <strong>最大堆</strong> 方法示範，因為邏輯清晰易理解。  </p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">kClosest</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 定義一個「最大堆」，元素對以 pair&lt;distanceSquared, index&gt;</span></span><br><span class="line">        <span class="comment">// distanceSquared 用作比較（距離平方越大排越前面）</span></span><br><span class="line">        <span class="keyword">using</span> PII = pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](<span class="type">const</span> PII&amp; a, <span class="type">const</span> PII&amp; b) &#123;</span><br><span class="line">            <span class="comment">// 距離平方大的排在堆頂（最大堆）</span></span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;PII, vector&lt;PII&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">maxHeap</span>(cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 遍歷所有點，維護一個大小最多為 k 的最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x = points[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = points[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> distSq = x * x + y * y;  <span class="comment">// 距離平方</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)maxHeap.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">                <span class="comment">// 先把前 k 個點放入堆</span></span><br><span class="line">                maxHeap.<span class="built_in">emplace</span>(distSq, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (distSq &lt; maxHeap.<span class="built_in">top</span>().first) &#123;</span><br><span class="line">                <span class="comment">// 若當前點更接近原點，彈出堆頂後推入</span></span><br><span class="line">                maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">                maxHeap.<span class="built_in">emplace</span>(distSq, i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否則，當前點距離比堆中最遠的 k 個點還大，跳過</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 現在堆中有 k 個「距離最小」的點，把它們取出</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">reserve</span>(k);</span><br><span class="line">        <span class="keyword">while</span> (!maxHeap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> idx = maxHeap.<span class="built_in">top</span>().second;</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(points[idx]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;  <span class="comment">// 返回順序可不固定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n log k)</p>
<ul>
<li>n &#x3D; points.size()，每次插入／彈出堆的操作為 O(log k)，共進行 n 次。</li>
</ul>
</li>
<li><p>空間複雜度：O(k)</p>
<ul>
<li>最大堆中最多保存 k 個元素，此外只使用常數級輔助變數。</li>
</ul>
</li>
</ul>
<h3 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvbG9uZ2VzdC1zdWJzdHJpbmctd2l0aG91dC1yZXBlYXRpbmctY2hhcmFjdGVycy8=">題目連結</span><br><strong>標籤</strong>: Hash Table, Two Pointers, String, Sliding Window<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個字串 <code>s</code>，請找出不含重複字符的最長子字串的長度。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>s = &quot;abcabcbb&quot;</code><br>Output: <code>3</code><br>Explanation: 最長不含重複字符的子字串是 <code>&quot;abc&quot;</code>，長度為 3。  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>s = &quot;bbbbb&quot;</code><br>Output: <code>1</code><br>Explanation: 最長不含重複字符的子字串是 <code>&quot;b&quot;</code>，長度為 1。  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>s = &quot;pwwkew&quot;</code><br>Output: <code>3</code><br>Explanation: 最長不含重複字符的子字串是 <code>&quot;wke&quot;</code>（注意是子字串，必須是連續的），長度為 3。<br>   請注意，你的答案必須是子字串的長度，<code>&quot;pwke&quot;</code> 不是連續的子字串。  </p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 10^4</code>  </li>
<li><code>s</code> 由英文字母、數字、符號和空格組成。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>本題可以利用「滑動視窗」（Sliding Window）＋「哈希表（字元映射）」技巧，在 O(n) 時間內找出最長不含重複字符的子字串長度。  </p>
<ol>
<li><p><strong>定義左右指標</strong>  </p>
<ul>
<li>使用兩個指標 <code>left</code>、<code>right</code> 表示視窗範圍，初始都指向 0。視窗代表目前考慮的子字串 <code>s[left..right-1]</code>。  </li>
<li>我們會讓 <code>right</code> 向右逐步擴展，同時保證視窗內沒有重複字符；只要發現重複，就移動 <code>left</code> 直到視窗內不含該重複字元為止。</li>
</ul>
</li>
<li><p><strong>哈希表記錄最近出現位置</strong>  </p>
<ul>
<li>建立一個大小至少為 128（覆蓋 ASCII 範圍）的整數陣列 <code>lastIndex[128]</code>，初始值皆設為 -1。當我們遍歷到 <code>s[right]</code>，若之前 <code>lastIndex[s[right]]</code> ≠ -1，代表在 <code>s[right]</code> 字符上次出現的位置。  </li>
<li>每次右指標 <code>right</code> 移動到新字元時，檢查該字元上次出現的位置 <code>prev = lastIndex[s[right]]</code>：  <ol>
<li>如果 <code>prev &gt;= left</code>，代表該字符之前在當前視窗範圍內出現過，因此必須將 <code>left</code> 更新到 <code>prev + 1</code>，才能移除重複。  </li>
<li>將 <code>lastIndex[s[right]] = right</code> 作為該字符的新紀錄。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>更新答案</strong>  </p>
<ul>
<li>在每次擴展 <code>right</code> 之前或之後（都可，只要維持視窗內無重複即可），計算當前視窗長度 <code>right - left + 1</code>，並與 <code>maxLen</code> 比較取最大值。</li>
</ul>
</li>
<li><p><strong>遍歷終止條件</strong>  </p>
<ul>
<li>讓 <code>right</code> 從 0 一路移動到 <code>n-1</code>，整個過程 O(n)；更新 <code>left</code> 最多也 O(n) 次，因此總複雜度 O(n)。</li>
</ul>
</li>
</ol>
<p>下面以範例 <code>s = &quot;abba&quot;</code> 來示範：  </p>
<ul>
<li><p>初始化：<code>left = 0, maxLen = 0, lastIndex 全部為 -1</code>  </p>
</li>
<li><p><code>right = 0</code>，<code>s[0] = &#39;a&#39;</code>：  </p>
<ul>
<li><code>prev = lastIndex[&#39;a&#39;] = -1</code>，不需移動 <code>left</code>。  </li>
<li>更新 <code>lastIndex[&#39;a&#39;] = 0</code>。  </li>
<li>當前視窗長度 <code>0 - 0 + 1 = 1</code>，<code>maxLen = 1</code>。</li>
</ul>
</li>
<li><p><code>right = 1</code>，<code>s[1] = &#39;b&#39;</code>：  </p>
<ul>
<li><code>prev = lastIndex[&#39;b&#39;] = -1</code>，不需移動 <code>left</code>。  </li>
<li>更新 <code>lastIndex[&#39;b&#39;] = 1</code>。  </li>
<li>當前視窗長度 <code>1 - 0 + 1 = 2</code>，<code>maxLen = 2</code>。</li>
</ul>
</li>
<li><p><code>right = 2</code>，<code>s[2] = &#39;b&#39;</code>：  </p>
<ul>
<li><code>prev = lastIndex[&#39;b&#39;] = 1</code>，此時 <code>1 &gt;= left(0)</code>，表示重複出現在視窗內。  </li>
<li>更新 <code>left = prev + 1 = 2</code>，移除先前的 <code>&#39;b&#39;</code>。  </li>
<li>更新 <code>lastIndex[&#39;b&#39;] = 2</code>。  </li>
<li>當前視窗長度 <code>2 - 2 + 1 = 1</code>，<code>maxLen = max(2,1) = 2</code>。</li>
</ul>
</li>
<li><p><code>right = 3</code>，<code>s[3] = &#39;a&#39;</code>：  </p>
<ul>
<li><code>prev = lastIndex[&#39;a&#39;] = 0</code>，因為 <code>0 &lt; left(2)</code>，表示上次的 <code>&#39;a&#39;</code> 已不在當前視窗內，故不移動 <code>left</code>。  </li>
<li>更新 <code>lastIndex[&#39;a&#39;] = 3</code>。  </li>
<li>當前視窗長度 <code>3 - 2 + 1 = 2</code>，<code>maxLen = max(2,2) = 2</code>。</li>
</ul>
</li>
</ul>
<p>最終 <code>maxLen = 2</code>，對應的最長子字串例如 <code>&quot;ab&quot;</code> 或 <code>&quot;ba&quot;</code>。  </p>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// lastIndex 用於記錄每個 ASCII 字元上次出現的位置，初始化為 -1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lastIndex</span><span class="params">(<span class="number">128</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;  <span class="comment">// 滑動視窗左邊界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right = <span class="number">0</span>; right &lt; n; right++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right];</span><br><span class="line">            <span class="type">int</span> prev = lastIndex[c];</span><br><span class="line">            <span class="comment">// 如果該字元上次出現在視窗內，則移動左邊界</span></span><br><span class="line">            <span class="keyword">if</span> (prev &gt;= left) &#123;</span><br><span class="line">                left = prev + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新該字元最近出現的位置</span></span><br><span class="line">            lastIndex[c] = right;</span><br><span class="line">            <span class="comment">// 計算當前視窗長度並更新最大值</span></span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>right 指標從 0 到 n-1 各走一次；left 最多向右移動 n 次，整體加起來為線性時間。</li>
</ul>
</li>
<li><p>空間複雜度：O(1)</p>
<ul>
<li>我們只使用固定大小為 128 的陣列儲存 ASCII 字元的最近位置，不隨字串長度 n 增長。</li>
</ul>
</li>
</ul>
<h3 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvM3N1bS8=">題目連結</span><br><strong>標籤</strong>: Array, Two Pointers, Sorting<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個整數陣列 <code>nums</code>，請找出所有不重複且總和為 0 的三元組 <code>[nums[i], nums[j], nums[k]]</code>，並將這些三元組以二維陣列形式回傳。  </p>
<p>注意：答案中不能包含重複的三元組。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: nums &#x3D; [-1,0,1,2,-1,-4]<br>Output: [[-1,-1,2],[-1,0,1]]<br>Explanation:<br>三元組 [-1,-1,2] 和 [-1,0,1] 的元素和均為 0，且不重複。</p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: nums &#x3D; [0, 1, 1]<br>Output: []</p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: nums &#x3D; [0, 0, 0]<br>Output: [[0, 0, 0]]</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code>  </li>
<li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ol>
<li><p><strong>排序 (Sorting)</strong>  </p>
<ul>
<li>先將陣列 <code>nums</code> 依升冪排序，方便後續使用雙指針掃描並去重。</li>
</ul>
</li>
<li><p><strong>固定第一個數字，對剩餘部分做雙指針搜尋</strong>  </p>
<ul>
<li>令三元組的第一個元素索引為 <code>i</code>，遍歷 <code>i</code> 從 <code>0</code> 到 <code>n-3</code>（因為至少要三個元素）。  </li>
<li>為了避免重複，在遍歷 <code>i</code> 時，如果 <code>i &gt; 0</code> 且 <code>nums[i] == nums[i-1]</code>，直接跳過。  </li>
<li>接著在排序好的陣列中，對 <code>i</code> 之後的子陣列使用左右指標 <code>left = i+1</code>、<code>right = n-1</code>，在 <code>left &lt; right</code> 的情況下：  <ol>
<li>計算三數總和 <code>sum = nums[i] + nums[left] + nums[right]</code>。  </li>
<li>如果 <code>sum == 0</code>，則找到一組符合條件的三元組，將其加入結果，並同時移動 <code>left++</code>、<code>right--</code>，但要跳過重複元素（<code>while (left &lt; right &amp;&amp; nums[left] == nums[left-1]) left++;</code>、<code>while (left &lt; right &amp;&amp; nums[right] == nums[right+1]) right--;</code>），以避免重複三元組。  </li>
<li>如果 <code>sum &lt; 0</code>，代表總和太小，需要增大 <code>left</code> 對應的值，故 <code>left++</code>。  </li>
<li>如果 <code>sum &gt; 0</code>，代表總和太大，需要減小 <code>right</code> 對應的值，故 <code>right--</code>。</li>
</ol>
</li>
<li>重複上述雙指針搜尋流程直到 <code>left &gt;= right</code>。</li>
</ul>
</li>
<li><p><strong>去重技巧</strong>  </p>
<ul>
<li>在固定 <code>i</code> 時：若 <code>i &gt; 0</code> 且 <code>nums[i] == nums[i-1]</code>，直接跳過，避免第一個數字重複。  </li>
<li>找到 <code>sum == 0</code> 後，移動 <code>left</code>、<code>right</code> 時，跳過相鄰且相同的值。</li>
</ul>
</li>
</ol>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1. 排序</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 遍歷 i 作為三元組的第一個元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 避免第一個元素重複</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3. 雙指針搜尋其餘兩個元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="type">long</span> sum = (<span class="type">long</span>)nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 找到一組符合條件的三元組</span></span><br><span class="line">                    result.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 跳過重複的 left 元素</span></span><br><span class="line">                    <span class="type">int</span> leftVal = nums[left];</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == leftVal) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 跳過重複的 right 元素</span></span><br><span class="line">                    <span class="type">int</span> rightVal = nums[right];</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == rightVal) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 總和太小，left 往右移動</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// sum &gt; 0</span></span><br><span class="line">                    <span class="comment">// 總和太大，right 往左移動</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n²)</p>
<ul>
<li>排序 O(n log n)；主迴圈遍歷 i 為 O(n)，每次在子陣列執行雙指針搜尋為 O(n)，合計為 O(n²)。</li>
</ul>
</li>
<li><p>空間複雜度：O(log n)（排序所需）</p>
<ul>
<li>若忽略返回結果所佔空間，只使用排程排序遞迴空間為 O(log n)。若計算輸出占用，則最壞情況 O(n²)（取決於可形成幾組三元組）。</li>
</ul>
</li>
</ul>
<h3 id="Binary-Tree-Level-Order-Traversal"><a href="#Binary-Tree-Level-Order-Traversal" class="headerlink" title="Binary Tree Level Order Traversal"></a>Binary Tree Level Order Traversal</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvYmluYXJ5LXRyZWUtbGV2ZWwtb3JkZXItdHJhdmVyc2FsLw==">題目連結</span><br><strong>標籤</strong>: Tree, Breadth-First Search, Queue<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個二元樹的根節點 <code>root</code>，請返回其「層序遍歷」（level order traversal）的節點值——即從左到右，逐層訪問所有節點。輸出結果應為一個二維陣列，其中第 <code>i</code> 個子陣列包含樹的第 <code>i</code> 層所有節點的值。  </p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: root &#x3D; [3,9,20,null,null,15,7]<br>Output: [[3],[9,20],[15,7]]<br>Explanation:<br>層序遍歷結果為 [[3], [9,20], [15,7]]。</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">   / \</span><br><span class="line">  15  7</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2:<br>Input: root &#x3D; [1]<br>Output: [[1]]</p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: root &#x3D; []<br>Output: []</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li>樹中節點總數在範圍 <code>[0, 2000]</code>。  </li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code>。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>本題最常用的做法是「廣度優先搜尋」（Breadth-First Search, BFS），利用佇列（queue）按層次逐層訪問。  </li>
<li>具體流程：  <ol>
<li>如果 <code>root</code> 為 <code>nullptr</code>，直接回傳空陣列 <code>[]</code>。  </li>
<li>建立一個佇列 <code>queue&lt;TreeNode*&gt; q</code>，先將 <code>root</code> 推入。  </li>
<li>當佇列不為空時，先記錄當前層的節點數 <code>levelSize = q.size()</code>，這個值代表本次要從佇列中取出的節點數量（相當於本層的節點數）。  </li>
<li>建立一個臨時容器 <code>vector&lt;int&gt; levelVals</code>，用來儲存本層所有節點的值。  </li>
<li>用一個迴圈跑 <code>levelSize</code> 次，每次從佇列中取出一個節點 <code>node = q.front()</code>、<code>q.pop()</code>，並把 <code>node-&gt;val</code> 加入 <code>levelVals</code>。若 <code>node-&gt;left</code> 非空，則 <code>q.push(node-&gt;left)</code>；若 <code>node-&gt;right</code> 非空，則 <code>q.push(node-&gt;right)</code>。  </li>
<li>當 <code>levelSize</code> 次迴圈結束，代表本層所有節點都處理完，將 <code>levelVals</code> 推入結果二維陣列 <code>result</code>。  </li>
<li>重複步驟 3～6，直到佇列為空。</li>
</ol>
</li>
<li>這樣可以保證每次只將同一層的節點值收集一次，並依序推入結果。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;  <span class="comment">// 空樹返回空陣列</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> levelSize = q.<span class="built_in">size</span>();  <span class="comment">// 當前層的節點數</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; levelVals;</span><br><span class="line">            levelVals.<span class="built_in">reserve</span>(levelSize);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                levelVals.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result.<span class="built_in">push_back</span>(levelVals);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>n 為樹中節點總數。每個節點會被加入佇列並彈出一次，並進行常數次操作（讀值、推入子節點），整體為 O(n)。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)</p>
<ul>
<li>佇列最壞情況下可能儲存一整層所有節點，例如接近 n&#x2F;2 個（若樹為完全二元樹）。此外，結果的二維陣列也會儲存所有節點值，需 O(n)。</li>
</ul>
</li>
</ul>
<h3 id="Clone-Graph"><a href="#Clone-Graph" class="headerlink" title="Clone Graph"></a>Clone Graph</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvY2xvbmUtZ3JhcGgv">題目連結</span><br><strong>標籤</strong>: Hash Table, Depth-First Search, Breadth-First Search, Graph<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 20 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>給定一個無向連通圖的節點 <code>node</code>，請返回此圖的深拷貝（Clone）。  </p>
<p>圖中每個節點包含一個整數 <code>val</code>（節點編號），以及一個鄰居列表 <code>vector&lt;Node*&gt; neighbors</code>，代表與該節點相連的所有節點。節點編號範圍為 1 到 N（N ≤ 100）。  </p>
<p>需構造一個與原圖結構、節點值完全相同的新圖，且新舊圖之間的節點指標互不相同。</p>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>adjList &#x3D; [[2,4],[1,3],[2,4],[1,3]]<br>返回：[[2,4],[1,3],[2,4],[1,3]]<br>圖結構：</p>
</blockquote>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 -- 2</span><br><span class="line">|    |</span><br><span class="line">4 -- 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Example 2:<br>adjList &#x3D; [[]]<br>圖只有一個節點，且沒有鄰居，返回：[[]]</p>
</blockquote>
<blockquote>
<p>Example 3:<br>adjList &#x3D; []<br>空圖，返回：nullptr</p>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<p>節點數量不超過 100。<br>節點值 val 範圍為 1 &lt;&#x3D; val &lt;&#x3D; 100，且圖為無向連通圖。<br>同一節點的鄰居列表中不含重複節點。<br>圖中無自環或重邊。</p>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<p>複製一個圖的常見方法是透過 深度優先搜尋（DFS） 或 廣度優先搜尋（BFS），並使用一個 哈希映射 來保存「原節點指標 → 新節點指標」的映射，避免重複複製同一個節點。<br>　下面以 DFS 方式示範：</p>
<ol>
<li><strong>建立映射表</strong></li>
</ol>
<ul>
<li>使用 unordered_map&lt;Node*, Node*&gt; visited;<ul>
<li>Key：原圖的節點指標</li>
<li>Value：對應已創建的複製節點指標</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>遞迴 DFS 函式 <code>clone(Node* node)</code></strong></li>
</ol>
<ul>
<li>如果 <code>node == nullptr</code>，直接返回 <code>nullptr</code>。</li>
<li>如果 <code>visited.count(node)</code> 已包含此 <code>node</code>，代表該節點已被複製過，直接返回 <code>visited[node]</code>。</li>
<li>否則：<ul>
<li>創建一個新節點 Node* copy &#x3D; new Node(node-&gt;val);，先只複製節點值，不處理鄰居列表。</li>
<li>在 visited[node] &#x3D; copy; 中記錄這個映射關係，避免後續重複複製。</li>
<li>遍歷 node-&gt;neighbors 中的每個鄰居 nei：呼叫 clone(nei)，並將返回的新節點指標加入 copy-&gt;neighbors。</li>
<li>返回 copy。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>主函式 <code>cloneGraph(Node* node)</code></li>
</ol>
<ul>
<li>如果輸入 node &#x3D;&#x3D; nullptr，直接返回 nullptr。</li>
<li>否則呼叫並返回 clone(node)，即可獲得整個圖的克隆。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    vector&lt;Node*&gt; neighbors;</span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">neighbors</span>(<span class="built_in">vector</span>&lt;Node*&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">neighbors</span>(<span class="built_in">vector</span>&lt;Node*&gt;()) &#123;&#125;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val, vector&lt;Node*&gt; _neighbors) : <span class="built_in">val</span>(_val), <span class="built_in">neighbors</span>(_neighbors) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">clone</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">clone</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">count</span>(node)) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        &#125;</span><br><span class="line">        Node* copy = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = copy;</span><br><span class="line">        <span class="keyword">for</span> (Node* nei : node-&gt;neighbors) &#123;</span><br><span class="line">            copy-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">clone</span>(nei));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(N + M)</p>
<ul>
<li>N 為節點數量，M 為邊的數量。每個節點只會被 clone 訪問一次，並處理它所有的鄰邊。</li>
</ul>
</li>
<li><p>空間複雜度：O(N)</p>
<ul>
<li>使用 visited 哈希映射存儲 N 個節點，遞迴棧最壞情況也為 O(N)。</li>
</ul>
</li>
</ul>
<h3 id="Evaluate-Reverse-Polish-Notation"><a href="#Evaluate-Reverse-Polish-Notation" class="headerlink" title="Evaluate Reverse Polish Notation"></a>Evaluate Reverse Polish Notation</h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jb20vcHJvYmxlbXMvZXZhbHVhdGUtcmV2ZXJzZS1wb2xpc2gtbm90YXRpb24v">題目連結</span><br><strong>標籤</strong>: Stack, Array<br><strong>語言</strong>: C++<br><strong>難度</strong>: Medium<br><strong>解題時間</strong>: 15 分鐘  </p>
</blockquote>
<p><strong>題目描述</strong></p>
<blockquote>
<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation.  </p>
<p>有效的運算符為 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>。每個運算符都應該作用於最近的兩個操作數之上。除法運算符 <code>/</code> 表示整數除法，結果會向零取整。  </p>
<p>你可以假設給定的 RPN 表達式總是有效的，也就是說運算過程中不會出現除以零的情況，並且最終得到的結果只會有一個值。  </p>
<p>舉例來說，給定 RPN 表達式索引為 <code>[&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code>，其對應的計算步驟為：  </p>
<ol>
<li>遇到 <code>&quot;2&quot;</code> 與 <code>&quot;1&quot;</code>，先把兩個數字當作操作數推入堆疊。  </li>
<li>遇到 <code>&quot;+&quot;</code>，從堆疊彈出 <code>1</code> 和 <code>2</code>，計算 <code>2 + 1 = 3</code>，再把結果 <code>3</code> 推回堆疊。  </li>
<li>接著讀到 <code>&quot;3&quot;</code>，把 <code>3</code> 推入堆疊。  </li>
<li>最後讀到 <code>&quot;*&quot;</code>，從堆疊彈出剛剛的 <code>3</code>（結果）和新推入的 <code>3</code>，計算 <code>3 * 3 = 9</code>，再把結果 <code>9</code> 推回。  </li>
<li>到達結尾，堆疊中只剩下一個值 <code>9</code>，即為最終答案。</li>
</ol>
</blockquote>
<p><strong>範例</strong></p>
<blockquote>
<p>Example 1:<br>Input: <code>tokens = [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</code><br>Output: <code>9</code><br>Explanation: <code>((2 + 1) * 3) = 9</code>  </p>
</blockquote>
<blockquote>
<p>Example 2:<br>Input: <code>tokens = [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</code><br>Output: <code>6</code><br>Explanation: <code>(4 + (13 / 5)) = 6</code>  </p>
</blockquote>
<blockquote>
<p>Example 3:<br>Input: <code>tokens = [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</code><br>Output: <code>22</code><br>Explanation:  </p>
<ol>
<li>當前堆疊狀態：<code>[10, 6, 9, 3]</code>  </li>
<li>遇到 <code>&quot;+&quot;</code>：彈出 <code>3, 9</code> → <code>9 + 3 = 12</code> → 推入 <code>12</code> → <code>[10, 6, 12]</code>  </li>
<li>遇到 <code>&quot;-11&quot;</code>：推入 <code>-11</code> → <code>[10, 6, 12, -11]</code>  </li>
<li>遇到 <code>&quot;*&quot;</code>：彈出 <code>-11, 12</code> → <code>12 * -11 = -132</code> → 推入 <code>-132</code> → <code>[10, 6, -132]</code>  </li>
<li>遇到 <code>&quot;/&quot;</code>：彈出 <code>-132, 6</code> → <code>6 / -132 = 0</code>（整數除法向零取整）→ 推入 <code>0</code> → <code>[10, 0]</code>  </li>
<li>遇到 <code>&quot;*&quot;</code>：彈出 <code>0, 10</code> → <code>10 * 0 = 0</code> → 推入 <code>0</code> → <code>[0]</code>  </li>
<li>遇到 <code>&quot;17&quot;</code>：推入 <code>17</code> → <code>[0, 17]</code>  </li>
<li>遇到 <code>&quot;+&quot;</code>：彈出 <code>17, 0</code> → <code>0 + 17 = 17</code> → 推入 <code>17</code> → <code>[17]</code>  </li>
<li>遇到 <code>&quot;5&quot;</code>：推入 <code>5</code> → <code>[17, 5]</code>  </li>
<li>遇到 <code>&quot;+&quot;</code>：彈出 <code>5, 17</code> → <code>17 + 5 = 22</code> → 推入 <code>22</code> → <code>[22]</code>  </li>
<li>最終答案 <code>22</code>。</li>
</ol>
</blockquote>
<p><strong>限制</strong></p>
<blockquote>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 10^4</code>  </li>
<li>每個 <code>tokens[i]</code> 要麼是一個整數（可能帶負號），要麼是運算符 <code>&quot;+&quot;</code>, <code>&quot;-&quot;</code>, <code>&quot;*&quot;</code>, <code>&quot;/&quot;</code>  </li>
<li>在 RPN 運算過程中，不會出現除以零的情況  </li>
<li>最終結果一定是一個整數，且範圍在 32 位元整數之內</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<blockquote>
<ul>
<li>使用棧（Stack）來模擬 RPN 計算：  <ol>
<li>遍歷 <code>tokens</code> 陣列，若當前元素是數字字串，就將其轉換成 <code>int</code> 後推入棧中。  </li>
<li>若當前元素是運算符（<code>&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;</code>），則從棧中先後彈出兩個操作數（右操作數先彈出，左操作數後彈出）。  </li>
<li>根據運算符對這兩個操作數執行相應運算，並把計算結果再推回棧中。  </li>
<li>反覆上述步驟，直到遍歷結束，棧中只剩一個元素，即為最終答案。</li>
</ol>
</li>
<li>注意：除法運算時要做整數除法，向零取整。C++ 中使用 <code>/</code> 即可滿足該條件。</li>
</ul>
</blockquote>
<p><strong>程式碼</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>   <span class="comment">// for std::stoi</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tok : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tok == <span class="string">&quot;+&quot;</span> || tok == <span class="string">&quot;-&quot;</span> || tok == <span class="string">&quot;*&quot;</span> || tok == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="comment">// 先彈出右操作數，再彈出左操作數</span></span><br><span class="line">                <span class="type">int</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (tok == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                    res = a + b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                    res = a - b;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                    res = a * b;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// tok == &quot;/&quot;</span></span><br><span class="line">                    <span class="comment">// C++ / 即為向零取整</span></span><br><span class="line">                    res = a / b;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                st.<span class="built_in">push</span>(res);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 整數字串，轉成 int 並推入棧中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tok));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最終棧中只剩一個結果</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>複雜度分析</strong></p>
<ul>
<li><p>時間複雜度：O(n)</p>
<ul>
<li>需要對 tokens 進行一次線性遍歷。對於每個元素，要麼做一次 push（O(1)），要麼做一次 pop、運算、再 push（都為 O(1) 操作）。因此整體為 O(n)。</li>
</ul>
</li>
<li><p>空間複雜度：O(n)</p>
<ul>
<li>最壞情況下（所有元素都是數字），棧中最多會存 n 個數字，所以需要 O(n) 的額外空間。</li>
</ul>
</li>
</ul>
<h2 id="Week-4-8-8"><a href="#Week-4-8-8" class="headerlink" title="Week 4 (8&#x2F;8)"></a>Week 4 (8&#x2F;8)</h2>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">編集日</span>
    <time title="修正日：2025-06-06 01:15:33" itemprop="dateModified" datetime="2025-06-06T01:15:33+08:00">2025-06-06</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> 寄付</button>
  <p>*~(￣▽￣)~[お茶]を一杯ください</p>
  <div id="qr">
      
      <div>
        <img data-src="/website/images/wechatpay.png" alt="品逸 WeChat 支払う">
        <p>WeChat 支払う</p>
      </div>
      
      <div>
        <img data-src="/website/images/alipay.png" alt="品逸 Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/website/images/paypal.png" alt="品逸 PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>著者： </strong>品逸 <i class="ic i-at"><em>@</em></i>Joseph's Blog
  </li>
  <li class="link">
    <strong>記事へのリンク：</strong>
    <a href="http://localhost:4000/grind75/index.html" title="LeetCode Grind 75">http://localhost:4000/grind75/index.html</a>
  </li>
  <li class="license">
    <strong>著作権表示： </strong>このブログ内のすべての記事は、特別な記載がない限り <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> の下のライセンスで保護されています。
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="見出し">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Grind-75"><span class="toc-number">1.</span> <span class="toc-text">Grind 75</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-1-13-13"><span class="toc-number">1.1.</span> <span class="toc-text">Week 1 (13&#x2F;13)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Two-Sum"><span class="toc-number">1.1.1.</span> <span class="toc-text">Two Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Parentheses"><span class="toc-number">1.1.2.</span> <span class="toc-text">Valid Parentheses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Merge-Two-Sorted-Lists"><span class="toc-number">1.1.3.</span> <span class="toc-text">Merge Two Sorted Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">1.1.4.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Palindrome"><span class="toc-number">1.1.5.</span> <span class="toc-text">Valid Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Invert-Binary-Tree"><span class="toc-number">1.1.6.</span> <span class="toc-text">Invert Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Anagram"><span class="toc-number">1.1.7.</span> <span class="toc-text">Valid Anagram</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search"><span class="toc-number">1.1.8.</span> <span class="toc-text">Binary Search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flood-Fill"><span class="toc-number">1.1.9.</span> <span class="toc-text">Flood Fill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><span class="toc-number">1.1.10.</span> <span class="toc-text">Lowest Common Ancestor of a Binary Search Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Balanced-Binary-Tree"><span class="toc-number">1.1.11.</span> <span class="toc-text">Balanced Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linked-List-Cycle"><span class="toc-number">1.1.12.</span> <span class="toc-text">Linked List Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implement-Queue-using-Stacks"><span class="toc-number">1.1.13.</span> <span class="toc-text">Implement Queue using Stacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-2-12-12"><span class="toc-number">1.2.</span> <span class="toc-text">Week 2 (12&#x2F;12)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-Bad-Version"><span class="toc-number">1.2.1.</span> <span class="toc-text">First Bad Version</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ransom-Note"><span class="toc-number">1.2.2.</span> <span class="toc-text">Ransom Note</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Climbing-Stairs"><span class="toc-number">1.2.3.</span> <span class="toc-text">Climbing Stairs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Palindrome"><span class="toc-number">1.2.4.</span> <span class="toc-text">Longest Palindrome</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reverse-Linked-List"><span class="toc-number">1.2.5.</span> <span class="toc-text">Reverse Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Majority-Element"><span class="toc-number">1.2.6.</span> <span class="toc-text">Majority Element</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add-Binary"><span class="toc-number">1.2.7.</span> <span class="toc-text">Add Binary</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diameter-of-Binary-Tree"><span class="toc-number">1.2.8.</span> <span class="toc-text">Diameter of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Middle-of-the-Linked-List"><span class="toc-number">1.2.9.</span> <span class="toc-text">Middle of the Linked List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Depth-of-Binary-Tree"><span class="toc-number">1.2.10.</span> <span class="toc-text">Maximum Depth of Binary Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Contains-Duplicate"><span class="toc-number">1.2.11.</span> <span class="toc-text">Contains Duplicate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maximum-Subarray"><span class="toc-number">1.2.12.</span> <span class="toc-text">Maximum Subarray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-3-8-8"><span class="toc-number">1.3.</span> <span class="toc-text">Week 3 (8&#x2F;8)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Insert-Interval"><span class="toc-number">1.3.1.</span> <span class="toc-text">Insert Interval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-Matrix"><span class="toc-number">1.3.2.</span> <span class="toc-text">01 Matrix</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Closest-Points-to-Origin"><span class="toc-number">1.3.3.</span> <span class="toc-text">K Closest Points to Origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Longest-Substring-Without-Repeating-Characters"><span class="toc-number">1.3.4.</span> <span class="toc-text">Longest Substring Without Repeating Characters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3Sum"><span class="toc-number">1.3.5.</span> <span class="toc-text">3Sum</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Tree-Level-Order-Traversal"><span class="toc-number">1.3.6.</span> <span class="toc-text">Binary Tree Level Order Traversal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clone-Graph"><span class="toc-number">1.3.7.</span> <span class="toc-text">Clone Graph</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Evaluate-Reverse-Polish-Notation"><span class="toc-number">1.3.8.</span> <span class="toc-text">Evaluate Reverse Polish Notation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Week-4-8-8"><span class="toc-number">1.4.</span> <span class="toc-text">Week 4 (8&#x2F;8)</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="関連記事">
      </div>
      <div class="overview panel" data-title="概要">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="品逸"
      data-src="/website/images/avatar.jpg">
  <p class="name" itemprop="name">品逸</p>
  <div class="description" itemprop="description">使用 Hexo + Shoka 架設的靜態網站</div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/website/archives/">
        <span class="count">1</span>
        <span class="name">ポスト</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/website/categories/">
        <span class="count">1</span>
        <span class="name">カテゴリ</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/website/tags/">
        <span class="count">1</span>
        <span class="name">タグ</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/website/" rel="section"><i class="ic i-home"></i>ホーム</a>
  </li>

    
  <li class="item">
    <a href="/website/grind75/" rel="section"><i class="ic i-book"></i>grind75</a>
  </li>

    
  <li class="item">
    <a href="/website/archives/" rel="section"><i class="ic i-archive"></i>アーカイブ</a>
  </li>

    
  <li class="item">
    <a href="/website/categories/" rel="section"><i class="ic i-th"></i>カテゴリ</a>
  </li>

    
  <li class="item">
    <a href="/website/about/" rel="section"><i class="ic i-user"></i>プロフィール</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>ランダムな記事</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/website/categories/uncategorized/" title="カテゴリ uncategorized">uncategorized</a>
</div>

    <span><a href="/website/2025/05/31/hello-world/" title="Hello World">Hello World</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>最近のコメント</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">品逸 @ Hi~~</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: 'grind75/',
    favicon: {
      show: "（●´3｀●）やれやれだぜ",
      hide: "(´Д｀)大変だ！"
    },
    search : {
      placeholder: "検索…",
      empty: "「 ${query} 」については何も見つかりませんでした",
      stats: "${time} ms以内に ${hits} 件の結果が見つかりました"
    },
    valine: true,fancybox: true,
    copyright: 'コピーは成功しました。 <br> 再印刷については、 ％s 契約に従ってください。',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/website/js/app.js?v=0.2.5"></script>




</body>
</html>
